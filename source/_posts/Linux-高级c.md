---
title: Linux-高级c
img: 
top: false
cover: false
toc: true
mathjax: false
date: 2020-07-16 22:11:12
author: xing xiao
coverImg:
password:
summary:
tags: C
categories: Linux
---
## GCC

- 全称为GNUCC，GNU项目中符合ANSIC标准的编译系统编译如C、C++、Object C、Java、Fortran、Pascal、Modula-3和Ada等多种语言
- GCC是可以在多种硬体平台上编译出可执行程序的超级编译器，其执行效率与一般的编译器相比平均效率要高20%~30%
- 一个交叉平台编译器，适合在嵌入式领域的开发编译

### 1.GCC简介

- gcc所支持后缀名解释
  - .c							C原始程序
  - -.C/.cc/.cxx				C++原始程序
  - .m						   Objective-C原始程序
  - .i								已经过预处理的C原始程序
  - .ii							已经过预处理的C++原始程序
  - .s/.S						  汇编语言原始程序
  - .h							  预处理文件（头文件）
  - .a/.so						编译后的库文件

### 2.编译器的主要组件

- 分析器：分析器将源语言程序代码转换为汇编语言。因为要从一种格式转换为另一种格式（C到汇编），所以分析器需要知道目标机器的汇编语言。
- 汇编器：汇编器将汇编语言代码转换为CPU可以执行字节码。
- 链接器：链接器将汇编器生成的单独的目标文件组合成可执行的应用程序。链接器需要知道这种目标格式以便工作。
- 标准C库：核心的C函数都有一个主要的C库来提供。如果在应用程序中用到了C库中的函数，这个库就会通过链接器和源代码连接来生成最终的可执行程序。

### 3.GCC的基本用法和选项

- Gcc最基本的用法是：gcc[options][filenamesl
  - ·c，只编译，不连接成为可执行文件，编译器只是由输入的.c等源代码文件生成.o为后缀的目标文件，通常用于编译不包含主程序的子程序文件。
  - ·o output filename，确定输出文件的名称为output filename，同时这个名称不能和源文件同名。如果不给出这个选项，gcc就给出预设的可执行文件a.out。
  - ·-g，产生符号调试工具（GNU的gdb）所必要的符号资讯，要想对源代码进行调试，我们就必须加入这个选项。
  - ·-0，对程序进行优化编译、连接，采用这个选项，整个源代码会在编译、连接过程中进行优化处理，这样产生的可执行文件的执行效率可以提高，但是，编译、连接的速度就相应地要慢一些。
  - ·-02，比-0更好的优化编译、连接，当然整个编译、连接过程会更慢。
  - ·-I dirname，将dirname所指出的目录加入到程序头文件目录列表中，是在预编译过程中使用的参数。
  - ·-Ldirname，将dirname所指出的目录加入到程序函数档案库文件的目录列表中，是在链接过程中使用的参数。

### 4.GCC的错误类型及对策

- 第一类：C语法错误
  - 错误信息：文件source.c中第n行有语法错误（syntex errror）。有些情况下，一个很简单的语法错误，gcc会给出一大堆错误，我们最主要的是要保持清醒的头脑，不要被其吓倒，必要的时候再参考一下C语言的基本教材。
- 第二类：头文件错误
  - 错误信息：找不到头文件head.h（Can not find include file head.h）。
    这类错误是源代码文件中的包含头文件有问题，可能的原因有头文件名错误、指定的头文件所在目录名错误等，也可能是错误地使用了双引号和尖括号。
- 第三类：档案库错误
  - 错误信息：链接程序找不到所需的函数库（1d:-1m:No such file or directory）。
    这类错误是与目标文件相连接的函数库有错误，可能的原因是函数库名错误、指定的函数库所在目录名称错误等，检查的方法是使用find命令在可能的目录中寻找相应的函数库名，确定档案库及目录的名称并修改程序中及编译选项中的名称。
- 第四类：未定义符号
  - 错误信息：有未定义的符号（Undefined symbo1）。这类错误是在连接过程中出现的，可能有两种原因：一是使用者自己定义的函数或者全局变量所在源代码文件，没有被编译、连接，或者干脆还没有定义，这需要使用者根据实际情况修改源程序，给出全局变量或者函数的定义体；二是未定义的符号是一个标准的库函数，在源程序中使用了该库函数，而连接过程中还没有给定相应的函数库的名称，或者是该档案库的目录名称有问题，这时需要使用档案库维护命令ar检查我们需要的库函数到底位于哪一个函数库中，确定之后，修改gcc连接选项中的-1和-L项。

### 5.GCC编译过程

- GCC的编译流程分为四个步骤：  

  1.预处理（Pre-Processing）   

  2.编译（Compiling）  

  3.汇编（Assembling）  

  4.链接（Linking）

### 6.调试器——Gdb调试流程

- 首先使用gcc对test.c进行编译，注意一定要加上选项‘-g’ 

  #gcc-g test.c-o test  

  #gdb test GNU gdb Red Hat Linux（6.3.0.0-1.21rh）  

  Copyright 2004 Free Software Foundation，Inc.
  GDB is free software，covered by the GNU General Public License，and you are welcome to change it and/or distribute copies of it under certain conditions.  

  Type"show copying"to see the conditions.  

  There is absolutely no warranty for GDB.Type"show warranty"for details.
  This GDB was configured as"i386-redhat-linux-gnu'...Using host libthread_db library"/lib/libthread db.so.1".
  （gdb）

![](https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P1594892943886.png)

### 7.Gdb的使用切记点

- 在gcc编译选项中一定要加入‘-g'。
- 只有在代码处于“运行”或“暂停”状态时才能查看变量值。
- 设置断点后程序在指定行之前停止

## 条件编译

- 编译器根据条件的真假决定是否编译相关的代码，

- 常见的条件编译有两种方法：

  - 一、根据宏是否定义，其语法如下：  

    #ifdef < macro >

    ........

    #else

    ........

    #endif

  - 二、根据宏的值，其语法如下：  

    #if< macro >

    ............

    #else

    ............

    #endif

## 结构体

### 1.简述

- 在实际的处理对象中，有许多信息是由多个不同类型的数据组合在一起进行描述，而且这些不同类型的数据是互相联系组成了一个有机的整体。此时，就要用到一种新的构造类型数据——结构体（structure），简称结构。
- -结构体的使用为处理复杂的数据结构（如动态数据结构等）提供了有效的手段，而且，它们为函数间传递不同类型的数据提供了方便。

### 2.定义

- 定义一个结构体类型的一般形式为：  

  struct  	结构体名

  {

  ​	数据类型	成员名1；

  ​	数据类型	成员名2；

  ​	：

  ​	数据类型	成员名n；
  }；

- 在大括号中的内容也称为“成员列表”或“域表”。

- 其中，每个成员名的命名规则与变量名相同；

- 数据类型可以是基本变量类型和数组类型，或者是一个结构体类型；

- 用分号“；”作为结束符。整个结构的定义也用分号作为结束符

### 3.说明

- 结构体类型中的成员名可以与程序中的变量名相同，二者并不代表同一对象，编译程序可以自动对它们进行区分。  

  最后，总结一下结构体类型的特点：  

  （1）结构体类型是用户自行构造的。  

  （2）它由若干不同的基本数据类型的数据构成。  

  （3）它属于C语言的一种数据类型，与整型、实型相当。因此，定义它时不分配空间，只有用它定义变量时才分配空间。

### 4.方法

- 1.结构体类型变量的定义方法

  - 先定义结构体类型再定义变量名

  - 这是C语言中定义结构体类型变量最常见的方式

    ​	struct	结构体名

    ​	{

    ​				成员列表；
    ​	}；

    ​	struct结构体名变量名；

- 2.在定义类型的同时定义变量

  - 这种形式的定义的一般形式为：  

    struct	结构体名

    ​	{

    ​				成员列表；

    ​	}变量名；

- 3.直接定义结构类型变量

  - 其一般形式为：  

    struct 	//没有结构体名

    ​	{

    ​			成员列表；

    ​	}变量名；

### 5.大小

- 一个结构体变量占用内存的实际大小，也可以利用sizeof求出。它的运算表达式为：  

  sizeof（运算量）  

  //求出给定的运算量占用内存空间的字节数

  其中运算量可以是变量、数组或结构体变量，可以是数据类型的名称。  

  例如：  

  sizeof（struct worker）  

  sizeof（worker1）

### 6.结构体变量的使用形式

- 结构体变量是不同数据类型的若干数据的集合体。在程序中使用结构体变量时，一般情况下不能把它作为一个整体参加数据处理，而参加各种运算和操作的是结构体变量的各个成员项数据。  

  结构体变量的成员用以下一般形式表示：  
            结构体变量名.成员名  
    	例如，上节给出的结构体变量worker1具有下列七个成员：    
```bash
    		worker1.number；workerl.name；workerl.sex；

  ​		    workerl.age；workerl.salary；workerl.address；

  ​		    worker1.phone
```
- 在定义了结构体变量后，就可以用不同的赋值方法对结构体变量的每个成员赋值。
  例如：
      strcpy（workerl.name，”zhang San”）；

  ​     workerl.age=26；

  ​     strcpy（workerl.phone，"1234567”）；

  ​     workerl.sex='m'；

  除此之外，还可以引用结构体变量成员的地址以及成员中的元素。例如：引用结构体变量成员的首地址&workerl.name；引用结构体变量成员的第二个字符worker1.name[1]；引用结构体变量的首地址&worker1。

### 7.结构体变量的初始化

- 与其他类型变量一样，也可以给结构体的每个成员赋初值，这称为结构体的初始化。一种是在定义结构体变量时进行初始化，语法格式如下：
  struct 结构体名变量名={初始数据表}；

- 另一种是在定义结构体类型时进行结构体变量的初始化。  
      struct结构体名

  ​	{
  ​					成员列表；
  ​	}变量名={初始数据表}；

## 结构体数组

### 1.结构体数组的定义

- 具有相同结构体类型的结构体变量也可以组成数组，称它们为结构体数组。结构体数组的每一个数组元素都是结构体类型的数据，它们都分别包括各个成员（分量）项。

- 定义结构体数组的方法和定义结构体变量的方法相仿，只需说明其为数组即可。
  可以采用三种方法：

  - 1.先定义结构体类型，再用它定义结构体数组。  

    结构体数组的定义形式如下：
    	struct 	结构体名

    ​	{	

    ​				成员表列

    ​	}；

    ​			struct 结构体名

  - 2.在定义结构体类型同时定义结构体数组

    结构体数组的定义形式如下：  
\
    	struct 结构体名

    ​	{

    ​					成员表列；

    ​	}数组名[元素个数]；

  - 3.直接定义结构体数组

    结构体数组的定义形式如下：  
\
    	struct	//没有结构体名

    ​	{

    ​		成员表列；
    ​	}数组名[元素个数]；

  

### 2.结构体数组的初始化

- 结构体数组在定义的同时也可以进行初始化，并且与结构体变量的初始化规定相同，只能对全局的或静态存储类别的结构体数组初始化。
  结构体数组初始化的一般形式是：  

  	struct	结构体名

  ​	{

  ​			成员列表；
  ​	}；struct	结构体名	数组名[元素个数]={初始数据表}；

## 结构体指针

- 可以设定一个指钍变量用来指向一个结构体变量。此时该指针变量的值是结构体变量的起始地址，该指针称为结构体指针。

- 结构体指针与前面介绍的各种指针变量在特性和方法上是相同的。与前述相同，在程序中结构体指针也是通过访问目标运算“ * ”访问它的对象。结构体指针在程序中的一般定义形式为：  

      struct结构体名  *  结构指针名；

  其中的结构体名必须是已经定过的结构体类型。

## 共用体

### 1.共用体的概念

- 在C语言中，不同数据类型的数据可以使用共同的存储区域，这种数据构造类型称为共用体，简称共用，又称联合体。共用体在定义、说明和使用形式上与结构体相似。两者本质上的不同仅在于使用内存的方式上。
  定义一个共用体类型的一般形式为：  

  	union共用体名

  ​	{

  ​			成员表列；
  ​			}；

## typedef

- 在C语言中，允许使用关键字typedef定义新的数据类型

  其语法如下：  

  typedef	〈已有数据类型>	〈新数据类型〉；

  如：

  ​		typedef 	int 	INTEGER；

  这里新定义了数据类型INTEGER，其等价于int 

  ​		INTEGER i；	<==>	int i；

## 动态内存

- malloc/free 
  - void * malloc（size_t num）
    void free（void * p）
    - malloc函数本身并不识别要申请的内存是什么类型，它只关心内存的总字节数。
    - malloc申请到的是一块连续的内存，有时可能会比所申请的空间大。其有时会申请不到内存，返回NULL。
    - malloc返回值的类型是void*，所以在调用malloc时要显式地进行类型转换，将void*转换成所需要的指针类型。
    - 如果free的参数是NULL的话，没有任何效果。
    - 释放一块内存中的一部分是不被允许的。
  - 野指针：
    不是NULL指针，是指向“垃圾”内存的指针。“野指针”是很危险的。
    “野指针”的成因主要有两种：
    - 指针变量没有被初始化。
    - 指针p被free之后，没有置为NULL，让人误以为p是个合法的指针。
    - 指针操作超越了变量的作用范围。这种情况让人防不胜防。

## Make

- 工程管理器，顾名思义，是指管理较多的文件
- Make工程管理器也就是个“自动编译管理器”，这里的“自动”是指它能够根据文件时间戳自动发现更新过的文件而减少编译的工作量，同时，它通过读入Makefile文件的内容来执行大量的编译工作
- Make将只编译改动的代码文件，而不用完全编译。

### 1.结构

- Makefile格式  

  target:dependency_files  

  < TAB >command  

  例子：  

  hello.o:hello.c hello.h  

  gcc-chello.c-o hello.o

  一个复杂一些的例子

  sunq:kang.o yul.o 

  ​		gcc kang.o yul.o-o sunq 

  kang.o:kang.c kang.h 

  ​		gcc-Wall-O-g-c kang.c-o kang.o 

  yul.o:yul.c 

  ​		gcc-Wall-O-g-cyul.c-o yul.o

  注释：-Wa11：表示允许发出gcc所有有用的报警信息.  
\
  			-c：只是编译不链接，生成目标文件”.o”  
\
  			-ofile：表示把输出文件输出到file里

  关于更多的用man工具

### 2.创建和使用变量

- 创建变量的目的：
- 用来代替一个文本字符串：  

  1.系列文件的名字  

  2.传递给编译器的参数  

  3.需要运行的程序  

  4.需要查找源代码的目录5.你需要输出信息的目录  

  6.你想做的其它事情。  

  - 刚才的例子
    OBJS=kang.o yul.o  

    CC=gcc  

    CFLAGS=-Wall-O-g  

    sunq：$（OBJS）  

    S（CC）S（OBJS）-o sunq  

    kang.o:kang.c kang.h'  

    S（CC）S（CFLAGS）-ckang.c-o kang.o  

    yul.o:yul.c yul.h  

    $（CC）S（CFLAGS）-c yul.c-o yul.o

![](https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P1594901447956.png)

### 3.Make使用

- 直接运行make
- 选项
  - -C dir读入指定目录下的Makefile
  - -f file读入当前目录下的file文件作为Makefile
  - -i 忽略所有的命令执行错误
  - -I dir指定被包含的Makefile所在目录
  - -n 只打印要执行的命令，但不执行这些命令
  - -p 显示make变量数据库和隐含规则
  - -s 在执行命令时不显示命令
  - -w 如果make在执行过程中改变目录，打印当前目录名	

### 4.Makefile的VPATH

- VPATH：虚路径
  - 在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。
  - Makefile文件中的特殊变量“VPATH”就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。
  - VPATH=src:../headers
  - 上面的的定义指定两个目录，“src”和“../headers”，make会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）