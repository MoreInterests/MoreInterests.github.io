<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux-进程</title>
      <link href="/2020/072244192.html"/>
      <url>/2020/072244192.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、进程"><a href="#一、进程" class="headerlink" title="一、进程"></a>一、进程</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><ul><li>程序  <ul><li>存放在磁盘上的指令和数据的有序集合（文件）  </li><li>静态的</li></ul></li><li>进程<ul><li>执行一个程序所分配的资源的总称</li><li>进程是程序的一次执行过程</li><li>动态的，包括创建、调度、执行和消亡</li></ul></li></ul><h3 id="2-进程控制块（pcb"><a href="#2-进程控制块（pcb" class="headerlink" title="2.进程控制块（pcb)"></a>2.进程控制块（pcb)</h3><ul><li><p>进程标识PID </p></li><li><p>进程用户</p></li><li><p>进程状态、优先级</p></li><li><p>文件描述符表</p><h3 id="3-进程类型"><a href="#3-进程类型" class="headerlink" title="3.进程类型"></a>3.进程类型</h3></li><li><p>交互进程：在shell下启动。以在前台运行，也可以在后台运行</p></li><li><p>批处理进程：和在终端无关，被提交到一个作业队列中以便顺序执行</p></li><li><p>守护进程：和终端无关，一直在后台运行</p><h3 id="4-进程状态"><a href="#4-进程状态" class="headerlink" title="4.进程状态"></a>4.进程状态</h3></li><li><p>运行态：进程正在运行，或者准备运行</p></li><li><p>等待态：进程在等待一个事件的发生或某种系统资源</p><ul><li>可中断</li><li>不可中断</li></ul></li><li><p>停止态：进程被中止，收到信号后可继续运行</p></li><li><p>死亡态：已终止的进程，但pcb没有被释放</p><h3 id="5-查看进程信息"><a href="#5-查看进程信息" class="headerlink" title="5.查看进程信息"></a>5.查看进程信息</h3></li><li><p>ps     查看系统进程快照</p></li><li><p>top    查看进程动态信息</p></li><li><p>/proc  查看进程详细信息</p><h3 id="6-进程相关命令"><a href="#6-进程相关命令" class="headerlink" title="6.进程相关命令"></a>6.进程相关命令</h3></li><li><p>nice   按用户指定的优先级运行进程</p></li><li><p>renice   改变正在运行进程的优先级</p></li><li><p>jobs   查看后台进程</p></li><li><p>bg     将挂起的进程在后台运行</p></li><li><p>fg      把后台运行的进程放到前台运行</p></li></ul><h3 id="7-进程创建-fork"><a href="#7-进程创建-fork" class="headerlink" title="7.进程创建 - fork"></a>7.进程创建 - fork</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span>  <span class="token string">&lt;unistd.h></span></span> pid_t  <span class="token function">fork</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">-</span> 创建新的进程，失败时返回<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span> 成功时父进程返回子进程的进程号，子进程返回<span class="token number">0</span><span class="token operator">-</span> 通过fork的返回值区分父进程和子进程<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>实例：pid_t  pid<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">perror</span><span class="token punctuation">(</span>“fork”<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">else</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">printf</span><span class="token punctuation">(</span>“child  process <span class="token punctuation">:</span>  my pid  is <span class="token operator">%</span>d\n”<span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token punctuation">{</span>     <span class="token function">printf</span><span class="token punctuation">(</span>“parent  process <span class="token punctuation">:</span>  my pid  is  <span class="token operator">%</span>d\n”<span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-父子进程"><a href="#8-父子进程" class="headerlink" title="8.父子进程"></a>8.父子进程</h3><ul><li><p>子进程继承了父进程的内容</p></li><li><p>父子进程有独立的地址空间，互不影响</p></li><li><p>若父进程先结束</p><ul><li>子进程成为孤儿进程，被init进程收养</li><li>子进程变成后台进程</li></ul></li><li><p>若子进程先结束</p><ul><li>父进程如果没有及时回收，子进程变成僵尸进程</li></ul></li></ul><h3 id="9-进程结束-–-exit-exit"><a href="#9-进程结束-–-exit-exit" class="headerlink" title="9.进程结束 – exit/_exit"></a>9.进程结束 – exit/_exit</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span> </span><span class="token macro property">#<span class="token directive keyword">include</span>  <span class="token string">&lt;unistd.h></span></span><span class="token keyword">void</span>  <span class="token function">exit</span><span class="token punctuation">(</span><span class="token keyword">int</span>  status<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span>  <span class="token function">_exit</span><span class="token punctuation">(</span><span class="token keyword">int</span>  status<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">-</span> 结束当前的进程并将status返回<span class="token operator">-</span> exit结束进程时会刷新<span class="token punctuation">(</span>流<span class="token punctuation">)</span>缓冲区<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>实例：  <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>  <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">printf</span><span class="token punctuation">(</span>“this process will exit<span class="token operator">!</span>\n”<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">printf</span><span class="token punctuation">(</span>“never  be  displayed<span class="token operator">!</span>\n”<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token punctuation">.</span><span class="token operator">/</span>a<span class="token punctuation">.</span>out    this process will be exit<span class="token operator">!</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>实例<span class="token number">2</span>：  <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>  <span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">printf</span><span class="token punctuation">(</span>“using  exit…\n”<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">printf</span><span class="token punctuation">(</span>“This  is  the  end<span class="token operator">!</span>\n”<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token punctuation">.</span><span class="token operator">/</span>a<span class="token punctuation">.</span>out    using  exit…  This  is  the  end<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-进程-–-exec函数族"><a href="#10-进程-–-exec函数族" class="headerlink" title="10.进程 – exec函数族"></a>10.进程 – exec函数族</h3><ul><li><p>进程调用exec函数族执行某个程序</p></li><li><p>进程当前内容被指定的程序替换</p></li><li><p>实现让父子进程执行不同的程序</p><ul><li>父进程创建子进程</li><li>子进程调用exec函数族</li><li>父进程不受影响</li></ul></li></ul><h3 id="11-进程-–-execl-execlp"><a href="#11-进程-–-execl-execlp" class="headerlink" title="11.进程 – execl / execlp"></a>11.进程 – execl / execlp</h3><pre class="line-numbers language-c"><code class="language-c">  <span class="token macro property">#<span class="token directive keyword">include</span>  <span class="token string">&lt;unistd.h></span></span>  <span class="token keyword">int</span> <span class="token function">execl</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span> …<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> <span class="token function">execlp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span> …<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">-</span> 成功时执行指定的程序；失败时返回<span class="token constant">EOF</span> <span class="token operator">-</span> path   执行的程序名称，包含路径 <span class="token operator">-</span> arg…  传递给执行的程序的参数列表 <span class="token operator">-</span> file   执行的程序的名称，在PATH中查找<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> 进程创建 – <span class="token function">execl</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> – 示例<span class="token operator">-</span> 执行ls命令，显示<span class="token operator">/</span>etc目录下所有文件的详细信息  <span class="token keyword">if</span>  <span class="token punctuation">(</span><span class="token function">execl</span><span class="token punctuation">(</span>“<span class="token operator">/</span>bin<span class="token operator">/</span>ls”<span class="token punctuation">,</span> “ls”<span class="token punctuation">,</span> “<span class="token operator">-</span>a”<span class="token punctuation">,</span> “<span class="token operator">-</span>l”<span class="token punctuation">,</span> “<span class="token operator">/</span>etc”<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">perror</span><span class="token punctuation">(</span>“execl”<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token keyword">if</span>  <span class="token punctuation">(</span><span class="token function">execlp</span><span class="token punctuation">(</span>“ls”<span class="token punctuation">,</span> “ls”<span class="token punctuation">,</span> “<span class="token operator">-</span>a”<span class="token punctuation">,</span> “<span class="token operator">-</span>l”<span class="token punctuation">,</span> “<span class="token operator">/</span>etc”<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">perror</span><span class="token punctuation">(</span>“execlp”<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="12-进程-–-execv-execvp"><a href="#12-进程-–-execv-execvp" class="headerlink" title="12.进程 – execv / execvp"></a>12.进程 – execv / execvp</h3><pre class="line-numbers language-c"><code class="language-c">  <span class="token macro property">#<span class="token directive keyword">include</span>  <span class="token string">&lt;unistd.h></span></span>  <span class="token keyword">int</span> <span class="token function">execv</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> <span class="token function">execvp</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>file<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token keyword">const</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">-</span> 成功时执行指定的程序；失败时返回<span class="token constant">EOF</span> <span class="token operator">-</span> arg… 封装成指针数组的形式<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>进程创建 – <span class="token function">execv</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> – 示例<span class="token operator">-</span> 执行ls命令，显示<span class="token operator">/</span>etc目录下所有文件的详细信息  <span class="token keyword">char</span>  <span class="token operator">*</span>arg<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>“ls”<span class="token punctuation">,</span> “<span class="token operator">-</span>a”<span class="token punctuation">,</span> “<span class="token operator">-</span>l”<span class="token punctuation">,</span> “<span class="token operator">/</span>etc”<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token keyword">if</span>  <span class="token punctuation">(</span><span class="token function">execv</span><span class="token punctuation">(</span>“<span class="token operator">/</span>bin<span class="token operator">/</span>ls”<span class="token punctuation">,</span> arg<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">perror</span><span class="token punctuation">(</span>“execv”<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token keyword">if</span>  <span class="token punctuation">(</span><span class="token function">execvp</span><span class="token punctuation">(</span>“ls”<span class="token punctuation">,</span> arg<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">perror</span><span class="token punctuation">(</span>“execvp”<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="13-进程-–-system"><a href="#13-进程-–-system" class="headerlink" title="13.进程 – system"></a>13.进程 – system</h3><pre class="line-numbers language-c"><code class="language-c">  <span class="token macro property">#<span class="token directive keyword">include</span>  <span class="token string">&lt;stdlib.h></span></span>  <span class="token keyword">int</span> <span class="token function">system</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">-</span> 成功时返回命令command的返回值；失败时返回<span class="token constant">EOF</span> <span class="token operator">-</span> 当前进程等待command执行结束后才继续执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="14-进程回收"><a href="#14-进程回收" class="headerlink" title="14.进程回收"></a>14.进程回收</h3><ul><li><p>子进程结束时由父进程回收</p></li><li><p>孤儿进程由init进程回收</p></li><li><p>若没有及时回收会出现僵尸进程</p></li></ul><h3 id="15-进程回收-–-wait"><a href="#15-进程回收-–-wait" class="headerlink" title="15.进程回收 – wait"></a>15.进程回收 – wait</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h></span></span>pid_t <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">-</span> 成功时返回回收的子进程的进程号；失败时返回<span class="token constant">EOF</span><span class="token operator">-</span> 若子进程没有结束，父进程一直阻塞<span class="token operator">-</span> 若有多个子进程，哪个先结束就先回收<span class="token operator">-</span> status 指定保存子进程返回值和结束方式的地址<span class="token operator">-</span> status为<span class="token constant">NULL</span>表示直接释放子进程PCB<span class="token punctuation">,</span>不接收返回值<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>进程回收 – wait – 示例  <span class="token keyword">int</span> status<span class="token punctuation">;</span>  pid_t pid<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">perror</span><span class="token punctuation">(</span>“fork”<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token punctuation">{</span>     <span class="token function">wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span>“<span class="token operator">%</span>x\n”<span class="token punctuation">,</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="16-进程返回值和结束方式"><a href="#16-进程返回值和结束方式" class="headerlink" title="16.进程返回值和结束方式"></a>16.进程返回值和结束方式</h3><ul><li><p>子进程通过exit / _exit / return 返回某个值(0-255)</p></li><li><p>父进程调用wait(&amp;status) 回收</p><ul><li><p>WIFEXITED(status)         判断子进程是否正常结束</p></li><li><p>WEXITSTATUS(status)       获取子进程返回值</p></li><li><p>WIFSIGNALED(status)       判断子进程是否被信号结束</p></li><li><p>WTERMSIG(status)          获取结束子进程的信号类型</p></li></ul></li></ul><h3 id="17-进程回收"><a href="#17-进程回收" class="headerlink" title="17.进程回收"></a>17.进程回收</h3><pre class="line-numbers language-c"><code class="language-c">  <span class="token macro property">#<span class="token directive keyword">include</span>  <span class="token string">&lt;unistd.h></span></span>  pid_t <span class="token function">waitpid</span><span class="token punctuation">(</span>pid_t pid<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>status<span class="token punctuation">,</span> <span class="token keyword">int</span> option<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">-</span> 成功时返回回收的子进程的pid或<span class="token number">0</span>；失败时返回<span class="token constant">EOF</span> <span class="token operator">-</span> pid可用于指定回收哪个子进程或任意子进程 <span class="token operator">-</span> status指定用于保存子进程返回值和结束方式的地址 <span class="token operator">-</span> option指定回收方式，<span class="token number">0</span> 或 WNOHANG<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> 进程回收 – waitpid – 示例    <span class="token function">waitpid</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">waitpid</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> WNOHANG<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>status<span class="token punctuation">,</span> WNOHANG<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="20-守护进程"><a href="#20-守护进程" class="headerlink" title="20.守护进程"></a>20.守护进程</h3><ul><li><p>守护进程(Daemon)是Linux三种进程类型之一</p></li><li><p>通常在系统启动时运行，系统关闭时结束</p></li><li><p>Linux系统中大量使用，很多服务程序以守护进程形式运行</p></li></ul><h3 id="21-守护进程特点"><a href="#21-守护进程特点" class="headerlink" title="21.守护进程特点"></a>21.守护进程特点</h3><ul><li><p>始终在后台运行</p></li><li><p>独立于任何终端</p></li><li><p>周期性的执行某种任务或等待处理特定事件</p></li></ul><h3 id="22-守护进程-–-会话、控制终端"><a href="#22-守护进程-–-会话、控制终端" class="headerlink" title="22.守护进程 – 会话、控制终端"></a>22.守护进程 – 会话、控制终端</h3><ul><li><p>Linux以会话(session)、进程组的方式管理进程</p></li><li><p>每个进程属于一个进程组</p></li><li><p>会话是一个或多个进程组的集合。通常用户打开一个终端时，系统会创建一个会话。所有通过该终端运行的进 程都属于这个会话</p></li><li><p>终端关闭时，所有相关进程会被结束</p></li></ul><h3 id="23-守护进程创建"><a href="#23-守护进程创建" class="headerlink" title="23.守护进程创建"></a>23.守护进程创建</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">(</span>一<span class="token punctuation">)</span>创建子进程，父进程退出     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token operator">-</span> 子进程变成孤儿进程，被init进程收养<span class="token operator">-</span> 子进程在后台运行<span class="token punctuation">(</span>二<span class="token punctuation">)</span>子进程创建新会话     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">setsid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token operator">-</span> 子进程成为新的会话组长<span class="token operator">-</span> 子进程脱离原先的终端<span class="token punctuation">(</span>三<span class="token punctuation">)</span>更改当前工作目录     <span class="token function">chdir</span><span class="token punctuation">(</span>“<span class="token operator">/</span>”<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">chdir</span><span class="token punctuation">(</span>“<span class="token operator">/</span>tmp”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">-</span> 守护进程一直在后台运行，其工作目录不能被卸载<span class="token operator">-</span> 重新设定当前工作目录<span class="token function">cwd</span><span class="token punctuation">(</span>四<span class="token punctuation">)</span>重设文件权限掩码     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">umask</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token operator">-</span> 文件权限掩码设置为<span class="token number">0</span><span class="token operator">-</span> 只影响当前进程<span class="token punctuation">(</span>五<span class="token punctuation">)</span>关闭打开的文件描述符     <span class="token keyword">int</span>  i<span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token function">getdtablesize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">close</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token operator">-</span> 关闭所有从父进程继承的打开文件<span class="token operator">-</span> 已脱离终端，<span class="token constant">stdin</span> <span class="token operator">/</span> <span class="token constant">stdout</span> <span class="token operator">/</span> <span class="token constant">stderr</span>无法再使用<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>守护进程 – 示例<span class="token number">1</span>创建守护进程，每隔<span class="token number">1</span>秒将系统时间写入文件time<span class="token punctuation">.</span>log  <span class="token keyword">int</span>  <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    pid_t pid<span class="token punctuation">;</span>    FILE <span class="token operator">*</span>fp<span class="token punctuation">;</span>    time_t  t<span class="token punctuation">;</span>    <span class="token keyword">int</span>  i<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">perror</span><span class="token punctuation">(</span>“fork”<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>守护进程 – 示例<span class="token number">2</span>    <span class="token function">setsid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">umask</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">chdir</span><span class="token punctuation">(</span>“<span class="token operator">/</span>tmp”<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> <span class="token function">getdtablesize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token function">close</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>“time<span class="token punctuation">.</span>log”<span class="token punctuation">,</span> “a”<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token function">perror</span><span class="token punctuation">(</span>“fopen”<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">while</span>  <span class="token punctuation">(</span> <span class="token number">1</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token function">time</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token function">fprintf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> “<span class="token operator">%</span>s”<span class="token punctuation">,</span> <span class="token function">ctime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token function">fflush</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-IO流</title>
      <link href="/2020/07217580.html"/>
      <url>/2020/07217580.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、标准I-O"><a href="#一、标准I-O" class="headerlink" title="一、标准I/O"></a>一、标准I/O</h2><h3 id="1-标准I-O-介绍"><a href="#1-标准I-O-介绍" class="headerlink" title="1.标准I/O - 介绍"></a>1.标准I/O - 介绍</h3><ul><li><p>标准IO提供了两方面的封装：</p><ul><li>1）操作对象 – FILE*: 封装了不同OS对文件的实现，</li><li>2）封装了缓存支持和优化。<h3 id="2-标准I-O-流和FILE对象"><a href="#2-标准I-O-流和FILE对象" class="headerlink" title="2.标准I/O - 流和FILE对象"></a>2.标准I/O - 流和FILE对象</h3><h4 id="1-流的概念"><a href="#1-流的概念" class="headerlink" title="1.流的概念"></a>1.流的概念</h4></li></ul></li><li><p>在C中引入了流(stream)的概念。它将数据的输入输出看作是数据的流入和流出，这样不管是磁盘文件或者是物理设备(打印机、显示器、键盘等),都可看作一种流的源和目的，视他们为同一种东西，而不管其具体的物理结构，即对他们的操作，就是数据的流入和流出。这种把数据的输入输出操作对象，抽象化为一种流，而不管它的具体结构的方法很有利于编程，而涉及流的输出操作函数可用于各种对象，与其具体的实体无关，即具有通用性。</p></li><li><p>在C中流可分为两大类，即文本流(text stream)和二进制流(binary stream)。</p><h4 id="2-FILE-定义"><a href="#2-FILE-定义" class="headerlink" title="2.FILE 定义"></a>2.FILE 定义</h4></li><li><p>FILE指针：每个被使用的文件都在内存中开辟一个区域，用来存放文件的有关信息，这些信息是保存在一个结构体类型的变量中，该结构体类型是由标准IO库定义的，取名为FILE。FILE封装了系统调用中的文件描述符的概念，所以标准IO中的函数不会直接操作文件描述符。同理：FILE屏蔽了操作系统的差别（标准IO不用文件描述符也是为了屏蔽OS的概念，用FILE这个抽象的概念。而文件描述符绝对是个UNIX/LINUX的概念。）。</p><pre class="line-numbers language-c"><code class="language-c">Show一下：stdio<span class="token punctuation">.</span>h 中<span class="token keyword">typedef</span> <span class="token keyword">struct</span> _IO_FILE FILE<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// /usr/include/libio.h</span>_IO_FILE 定义在libio<span class="token punctuation">.</span>h （Whereis libio<span class="token punctuation">.</span>h）<span class="token punctuation">;</span> 简单浏览一下_IO_FILE对象的数据结构_flags： _IO_LINE_BUF<span class="token operator">/</span>_IO_UNBUFFERED<span class="token operator">/</span>   <span class="token comment" spellcheck="true">//p114</span>fp<span class="token operator">-></span>_IO_buf_end – fp<span class="token operator">-></span>_IO_buf_base 内部分配的缓存大小的首尾地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-文本流和二进制流"><a href="#3-文本流和二进制流" class="headerlink" title="3.文本流和二进制流"></a>3.文本流和二进制流</h4></li><li><p>所谓文本流是指在流中流动的数据是以字符形式出现。在文本流中，’\n’被换成回车CR和换行LF的代码0DH和0AH。而当输出时，则0DH和0AH本换成’\n’。</p><ul><li>二进制流是指流动的是二进制数字序列，若流中有字符，则用一个字节的二进制ASCII码表示，若是数字，则用一个字节的二进制数表示。在流入流出时，对\n符号不进行变换。例如2001这个数，在文本流中用其ASCII码表示为：<pre class="line-numbers language-c"><code class="language-c"><span class="token string">'2'</span> <span class="token string">'0'</span> <span class="token string">'0'</span> <span class="token string">'1'</span><span class="token operator">|</span> <span class="token operator">|</span> <span class="token operator">|</span> <span class="token operator">|</span><span class="token number">50</span> <span class="token number">48</span> <span class="token number">48</span> <span class="token number">49</span>共占<span class="token number">4</span>字节。而在二进制流中则表示为：<span class="token number">00000111</span> <span class="token number">11010001</span> 用十六进制就是07D1。只占两字节。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>由此看出，二进制流比文本流节省空间，且不用进行对\n的转换，这样可以大大加快流的速度，提高效率。因而，对于含有大量数字信息的数字流，可以采用二进制流的方式；对于含有大量字符信息的流，则采用文本流的方式。</p><h3 id="3-标准I-O预定义的3个流。"><a href="#3-标准I-O预定义的3个流。" class="headerlink" title="3.标准I/O预定义的3个流。"></a>3.标准I/O预定义的3个流。</h3></li><li><p>一个进程启动的时候，会打开三个流：标准输入、标准输出、标准出错。</p></li><li><p>和文件IO中的对应关系,可以查看头文件定义.</p><h3 id="4-标准I-O-文件缓冲"><a href="#4-标准I-O-文件缓冲" class="headerlink" title="4.标准I/O -文件缓冲"></a>4.标准I/O -文件缓冲</h3></li><li><p>首先理解为何要设置缓冲区 – 避免频繁地呼叫系统调用；其次缓冲区大小的设置在不同OS上是有技术的，标准库为我们做了优化选择。</p></li><li><p>标准IO函数是根据文件流关联的设备类型，会选择采用何种缓冲区的操作方式。分类如下：</p><h4 id="1）全缓冲区："><a href="#1）全缓冲区：" class="headerlink" title="1）全缓冲区："></a>1）全缓冲区：</h4></li><li><p>这种缓冲区要求填满整个缓冲区后才进行I/O 系统调用操作。对于磁盘文件通常使用全缓冲区访问。第一次执行I/O 操作时，ANSI 标准的文件管理函数通过调用malloc 函数获得需使用的缓冲区。linux默认大小为4096。</p><h4 id="2）行缓冲区："><a href="#2）行缓冲区：" class="headerlink" title="2）行缓冲区："></a>2）行缓冲区：</h4></li><li><p>在这种情况下，当在输入和输出中遇到换行符时，标准I/O 库执行I/O系统调用操作。当流涉及一个终端时（例如标准输入和标准输出），使用行缓冲区。因为标准I/O 库收集的每行的缓冲区长度是固定的，只要填满了缓冲区，即使还没有遇到换行符也将执行I/O 系统调用操作。默认行缓冲区大小为1024 字节。</p><h4 id="3）无缓冲区："><a href="#3）无缓冲区：" class="headerlink" title="3）无缓冲区："></a>3）无缓冲区：</h4></li><li><p>标准I/O 库不对字符进行缓存。如果用标准I/O 函数写若干字符到不带缓冲区的流中，则相当于用write 系统调用函数将这些字符写至相关联的打开文件。标准出错流stderr 通常是不带缓冲区的，这使得出错信息能够尽快地显示出来<br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P0721-1.jpg" alt=""><br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P0721-2.jpg" alt=""></p><h3 id="5-标准I-O-–-读写"><a href="#5-标准I-O-–-读写" class="headerlink" title="5.标准I/O – 读写"></a>5.标准I/O – 读写</h3><pre class="line-numbers language-c"><code class="language-c">fgetc <span class="token operator">/</span> fputcfgets <span class="token operator">/</span> fputsfread <span class="token operator">/</span> fwrite<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="6-标准I-O-–-刷新流"><a href="#6-标准I-O-–-刷新流" class="headerlink" title="6.标准I/O – 刷新流"></a>6.标准I/O – 刷新流</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">fflush</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>成功时返回<span class="token number">0</span>； 出错时返回<span class="token constant">EOF</span>将流缓冲区中的数据写入实际的文件Linux下只能刷新输出缓冲区<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="7-定位流-–-ftell-fseek-rewind"><a href="#7-定位流-–-ftell-fseek-rewind" class="headerlink" title="7.定位流 – ftell/fseek/rewind"></a>7.定位流 – ftell/fseek/rewind</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">long</span> <span class="token function">ftell</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> <span class="token function">fseek</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> whence<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">rewind</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>Ø <span class="token function">ftell</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 成功时返回流的当前读写位置， 出错时返回<span class="token constant">EOF</span>Ø <span class="token function">fseek</span><span class="token punctuation">(</span><span class="token punctuation">)</span>定位一个流， 成功时返回<span class="token number">0</span>， 出错时返回<span class="token constant">EOF</span>Ø whence参数： SEEK_SET<span class="token operator">/</span>SEEK_CUR<span class="token operator">/</span>SEEK_ENDØ offset参数： 偏移量， 可正可负Ø <span class="token function">rewind</span><span class="token punctuation">(</span><span class="token punctuation">)</span>将流定位到文件开始位置Ø 读写流时， 当前读写位置自动后移示例一<span class="token punctuation">(</span>在文件末尾追加字符’t’<span class="token punctuation">)</span>FILE <span class="token operator">*</span>fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>“test<span class="token punctuation">.</span>txt”<span class="token punctuation">,</span> “r<span class="token operator">+</span>”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fseek</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> SEEK_END<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fputc</span><span class="token punctuation">(</span>‘t’<span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">;</span>示例二<span class="token punctuation">(</span>获取文件长度<span class="token punctuation">)</span>FILE <span class="token operator">*</span>fp<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>“test<span class="token punctuation">.</span>txt”<span class="token punctuation">,</span> “r<span class="token operator">+</span>”<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">perror</span><span class="token punctuation">(</span>“fopen”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span> fs<span class="token function">eek</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> SEEK_END<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span>“length is <span class="token operator">%</span>d\n”<span class="token punctuation">,</span> <span class="token function">ftell</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-标准I-O-–-判断流是否出错和结束"><a href="#8-标准I-O-–-判断流是否出错和结束" class="headerlink" title="8.标准I/O – 判断流是否出错和结束"></a>8.标准I/O – 判断流是否出错和结束</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">ferror</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">feof</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>Ø<span class="token function">ferror</span><span class="token punctuation">(</span><span class="token punctuation">)</span>返回<span class="token number">1</span>表示流出错； 否则返回<span class="token number">0</span>Ø<span class="token function">feof</span><span class="token punctuation">(</span><span class="token punctuation">)</span>返回<span class="token number">1</span>表示文件已到末尾； 否则返回<span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9-标准I-O-–-格式化输出"><a href="#9-标准I-O-–-格式化输出" class="headerlink" title="9.标准I/O – 格式化输出"></a>9.标准I/O – 格式化输出</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>fmt<span class="token punctuation">,</span> …<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">fprintf</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>stream<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>fmt<span class="token punctuation">,</span> …<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">sprintf</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>fmt<span class="token punctuation">,</span> …<span class="token punctuation">)</span><span class="token punctuation">;</span>Ø成功时返回输出的字符个数； 出错时返回<span class="token constant">EOF</span>Ø使用起来很方便， 强烈推荐！以指定格式 “年<span class="token operator">-</span>月<span class="token operator">-</span>日” 分别写入文件和缓冲区<span class="token keyword">int</span> year<span class="token punctuation">,</span> month<span class="token punctuation">,</span> date<span class="token punctuation">;</span>FILE <span class="token operator">*</span>fp<span class="token punctuation">;</span><span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span>year <span class="token operator">=</span> <span class="token number">2014</span><span class="token punctuation">;</span> month <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> date <span class="token operator">=</span> <span class="token number">26</span><span class="token punctuation">;</span>fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>“test<span class="token punctuation">.</span>txt”<span class="token punctuation">,</span> “a<span class="token operator">+</span>”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fprintf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> “<span class="token operator">%</span>d<span class="token operator">-</span><span class="token operator">%</span>d<span class="token operator">-</span><span class="token operator">%</span>d\n”<span class="token punctuation">,</span> year<span class="token punctuation">,</span> month<span class="token punctuation">,</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sprintf</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> “<span class="token operator">%</span>d<span class="token operator">-</span><span class="token operator">%</span>d<span class="token operator">-</span><span class="token operator">%</span>d\n”<span class="token punctuation">,</span> year<span class="token punctuation">,</span> month<span class="token punctuation">,</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、文件I-O"><a href="#二、文件I-O" class="headerlink" title="二、文件I/O"></a>二、文件I/O</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h3><ul><li>posix(可移植操作系统接口)定义的一组函数</li><li>不提供缓冲机制， 每次读写操作都引起系统调用</li><li>核心概念是文件描述符</li><li>访问各种类型文件</li><li>Linux下, 标准IO基于文件IO实现</li></ul><h3 id="2-文件I-O-–-文件描述符"><a href="#2-文件I-O-–-文件描述符" class="headerlink" title="2.文件I/O – 文件描述符"></a>2.文件I/O – 文件描述符</h3><ul><li>每个打开的文件都对应一个文件描述符</li><li>文件描述符是一个非负整数。 Linux为程序中每个打开的文件分配一个文件描述符</li><li>文件描述符从0开始分配， 依次递增。</li><li>文件IO操作通过文件描述符来完成</li><li>0, 1, 2 的含义？</li></ul><h3 id="3-文件I-O-–-open"><a href="#3-文件I-O-–-open" class="headerlink" title="3.文件I/O – open"></a>3.文件I/O – open</h3><pre class="line-numbers language-c"><code class="language-c">open函数用来创建或打开一个文件<span class="token punctuation">:</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span></span><span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">int</span> oflag<span class="token punctuation">,</span> …<span class="token punctuation">)</span><span class="token punctuation">;</span>Ø 成功时返回文件描述符； 出错时返回<span class="token constant">EOF</span>Ø 打开文件时使用两个参数Ø 创建文件时第三个参数指定新文件的权限Ø 只能打开设备文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P0721-3.jpg" alt=""></p><ul><li>文件I/O – open – 示例1<pre class="line-numbers language-c"><code class="language-c">以只写方式打开文件<span class="token number">1</span><span class="token punctuation">.</span>txt。 如果文件不存在则创建， 如果文件存在则清空：<span class="token keyword">int</span> fd<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>“<span class="token number">1</span><span class="token punctuation">.</span>txt”<span class="token punctuation">,</span> O_WRONLY<span class="token operator">|</span>O_CREAT<span class="token operator">|</span>O_TRUNC<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">perror</span><span class="token punctuation">(</span>“open”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>文件I/O – open – 示例2<pre class="line-numbers language-c"><code class="language-c">以读写方式打开文件<span class="token number">1</span><span class="token punctuation">.</span>txt。 如果文件不存在则创建， 如果文件存在则报错：<span class="token keyword">int</span> fd<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>“<span class="token number">1</span><span class="token punctuation">.</span>txt”<span class="token punctuation">,</span> O_RDWR<span class="token operator">|</span>O_CREAT<span class="token operator">|</span>O_EXCL<span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>errno <span class="token operator">==</span> EEXIST<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">perror</span><span class="token punctuation">(</span>“exist error”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token function">perror</span><span class="token punctuation">(</span>“other error”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-文件I-O-–-close"><a href="#4-文件I-O-–-close" class="headerlink" title="4.文件I/O – close"></a>4.文件I/O – close</h3><pre class="line-numbers language-c"><code class="language-c">close函数用来关闭一个打开的文件<span class="token punctuation">:</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>Ø 成功时返回0； 出错时返回EOF<br>Ø 程序结束时自动关闭所有打开的文件<br>Ø 文件关闭后， 文件描述符不再代表文件</p><pre><code>### 5.文件I/O – read- read函数用来从文件中读取数据:```c#include &lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t count);Ø 成功时返回实际读取的字节数； 出错时返回EOFØ 读到文件末尾时返回0Ø buf是接收数据的缓冲区Ø count不应超过buf大小</code></pre><ul><li>文件I/O – read – 示例<pre class="line-numbers language-c"><code class="language-c">从指定的文件<span class="token punctuation">(</span>文本文件<span class="token punctuation">)</span>中读取内容并统计大小<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> n<span class="token punctuation">,</span> total <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span>“Usage <span class="token punctuation">:</span> <span class="token operator">%</span>s <span class="token operator">&lt;</span>file<span class="token operator">></span>\n”<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> O_RDONLY<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">perror</span><span class="token punctuation">(</span>“open”<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>w<span class="token function">hile</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>total <span class="token operator">+</span><span class="token operator">=</span> n<span class="token punctuation">;</span><span class="token punctuation">}</span>……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-文件I-O-–-write"><a href="#6-文件I-O-–-write" class="headerlink" title="6.文件I/O – write"></a>6.文件I/O – write</h3><pre class="line-numbers language-c"><code class="language-c">write函数用来向文件写入数据<span class="token punctuation">:</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>ssize_t <span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t count<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>Ø 成功时返回实际写入的字节数； 出错时返回EOF<br>Ø buf是发送数据的缓冲区<br>Ø count不应超过buf大小</p><pre><code>- 文件I/O – write – 示例```c将键盘输入的内容写入文件， 直到输入quitint fd;char buf[20];if ((fd = open(argv[1], O_WRONLY|O_CREAT|O_TRUNC, 0666)) &lt; 0) {perror(“open”); return -1;}while (fgets(buf, 20, stdin) != NULL) {if (strcmp(buf, “quit\n”) == 0) break;write(fd, buf, strlen(buf));}……</code></pre><h3 id="7-文件IO-–-lseek"><a href="#7-文件IO-–-lseek" class="headerlink" title="7.文件IO – lseek"></a>7.文件IO – lseek</h3><pre class="line-numbers language-c"><code class="language-c">lseek函数用来定位文件<span class="token punctuation">:</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span>off_t <span class="token function">lseek</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> off_t offset<span class="token punctuation">,</span> intt whence<span class="token punctuation">)</span><span class="token punctuation">;</span>Ø 成功时返回当前的文件读写位置； 出错时返回<span class="token constant">EOF</span>Ø 参数offset和参数whence同fseek完全一样<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、文件目录"><a href="#三、文件目录" class="headerlink" title="三、文件目录"></a>三、文件目录</h2><h3 id="1-访问目录-–-opendir"><a href="#1-访问目录-–-opendir" class="headerlink" title="1.访问目录 – opendir"></a>1.访问目录 – opendir</h3><pre><code>opendir函数用来打开一个目录文件:#include &lt;dirent.h&gt;DIR *opendir(const char *name);Ø DIR是用来描述一个打开的目录文件的结构体类型Ø 成功时返回目录流指针； 出错时返回NULL</code></pre><h3 id="2-访问目录-–-readdir"><a href="#2-访问目录-–-readdir" class="headerlink" title="2.访问目录 – readdir"></a>2.访问目录 – readdir</h3><pre class="line-numbers language-c"><code class="language-c">readdir函数用来读取目录流中的内容<span class="token punctuation">:</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;dirent.h></span></span><span class="token keyword">struct</span> dirent <span class="token operator">*</span><span class="token function">readdir</span><span class="token punctuation">(</span>DIR <span class="token operator">*</span>dirp<span class="token punctuation">)</span><span class="token punctuation">;</span>Ø <span class="token keyword">struct</span> dirent是用来描述目录流中一个目录项的结构体类型Ø 包含成员<span class="token keyword">char</span> d_name<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span> 参考帮助文档Ø 成功时返回目录流dirp中下一个目录项；Ø 出错或到末尾时时返回<span class="token constant">NULL</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-访问目录-–-closedir"><a href="#3-访问目录-–-closedir" class="headerlink" title="3.访问目录 – closedir"></a>3.访问目录 – closedir</h3><pre class="line-numbers language-c"><code class="language-c">closedir函数用来关闭一个目录文件<span class="token punctuation">:</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;dirent.h></span></span><span class="token keyword">int</span> <span class="token function">closedir</span><span class="token punctuation">(</span>DIR <span class="token operator">*</span>dirp<span class="token punctuation">)</span><span class="token punctuation">;</span>Ø 成功时返回<span class="token number">0</span>； 出错时返回<span class="token constant">EOF</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>访问目录 – 示例代码<pre class="line-numbers language-c"><code class="language-c">打印指定的目录下所有文件名称<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>DIR <span class="token operator">*</span>dirp<span class="token punctuation">;</span><span class="token keyword">struct</span> dirent <span class="token operator">*</span>dp<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span>“Usage <span class="token punctuation">:</span> <span class="token operator">%</span>s <span class="token operator">&lt;</span>directory<span class="token operator">></span>\n”<span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>dirp <span class="token operator">=</span> <span class="token function">opendir</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">perror</span><span class="token punctuation">(</span>“opendir”<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>w<span class="token function">hile</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>dp <span class="token operator">=</span> <span class="token function">readdir</span><span class="token punctuation">(</span>dirp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span>“<span class="token operator">%</span>s\n”<span class="token punctuation">,</span> dp<span class="token operator">-></span>d_name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>c<span class="token function">losedir</span><span class="token punctuation">(</span>dirp<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-修改文件访问权限-–-chmod-fchmod"><a href="#4-修改文件访问权限-–-chmod-fchmod" class="headerlink" title="4.修改文件访问权限 – chmod/fchmod"></a>4.修改文件访问权限 – chmod/fchmod</h3><pre><code>chmod/fchmod函数用来修改文件的访问权限:#include &lt;sys/stat.h&gt;int chmod(const char *path, mode_t mode);int fchmod(int fd, mode_t mode);</code></pre></li></ul><p>Ø 成功时返回0； 出错时返回EOF<br>Ø root和文件所有者能修改文件的访问权限</p><p>示例： chmod(“test.txt”, 0666);</p><pre><code>### 5.获取文件属性 – stat/lstat/fstat```cstat/lstat/fstat函数用来获取文件属性:#include &lt;sys/stat.h&gt;int stat(const char *path, struct stat *buf);int lstat(const char *path, struct stat *buf);int fstat(int fd, struct stat *buf);Ø 成功时返回0； 出错时返回EOFØ 如果path是符号链接stat获取的是目标文件的属性； 而lstat获取的是链接文件的属性</code></pre><h3 id="6-文件属性-–-struct-stat"><a href="#6-文件属性-–-struct-stat" class="headerlink" title="6.文件属性 – struct stat"></a>6.文件属性 – struct stat</h3><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> stat是存放文件属性的结构体类型<span class="token punctuation">:</span>Ø mode_t st_mode<span class="token punctuation">;</span>       类型和访问权限Ø uid_t st_uid<span class="token punctuation">;</span>         所有者idØ uid_t st_gid<span class="token punctuation">;</span>         用户组idØ off_t st_size<span class="token punctuation">;</span>        文件大小Ø time_t st_mtime<span class="token punctuation">;</span>      最后修改时间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-文件类型-–-st-mode"><a href="#7-文件类型-–-st-mode" class="headerlink" title="7.文件类型 – st_mode"></a>7.文件类型 – st_mode</h3><pre class="line-numbers language-c"><code class="language-c">通过系统提供的宏来判断文件类型<span class="token punctuation">:</span>st_mode <span class="token operator">&amp;</span> <span class="token number">0170000</span>Ø <span class="token function">S_ISREG</span><span class="token punctuation">(</span>st_mode<span class="token punctuation">)</span> <span class="token number">0100000</span>Ø <span class="token function">S_ISDIR</span><span class="token punctuation">(</span>st_mode<span class="token punctuation">)</span> <span class="token number">0040000</span>Ø <span class="token function">S_ISCHR</span><span class="token punctuation">(</span>st_mode<span class="token punctuation">)</span> <span class="token number">0020000</span>Ø <span class="token function">S_ISBLK</span><span class="token punctuation">(</span>st_mode<span class="token punctuation">)</span> <span class="token number">0060000</span>Ø <span class="token function">S_ISFIFO</span><span class="token punctuation">(</span>st_mode<span class="token punctuation">)</span> <span class="token number">0010000</span>Ø <span class="token function">S_ISLNK</span><span class="token punctuation">(</span>st_mode<span class="token punctuation">)</span> <span class="token number">0120000</span>Ø <span class="token function">S_ISSOCK</span><span class="token punctuation">(</span>st_mode<span class="token punctuation">)</span> <span class="token number">0140000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-文件访问权限-–-st-mode"><a href="#8-文件访问权限-–-st-mode" class="headerlink" title="8.文件访问权限 – st_mode"></a>8.文件访问权限 – st_mode</h3><pre class="line-numbers language-c"><code class="language-c">通过系统提供的宏来获取文件访问权限<span class="token punctuation">:</span>Ø S_IRUSR <span class="token number">00400</span> bit<span class="token punctuation">:</span><span class="token number">8</span>Ø S_IWUSR <span class="token number">00200</span> <span class="token number">7</span>Ø S_IXUSR <span class="token number">00100</span> <span class="token number">6</span>Ø S_IRGRP <span class="token number">00040</span> <span class="token number">5</span>Ø S_IWGRP <span class="token number">00020</span> <span class="token number">4</span>Ø S_IXGRP <span class="token number">00010</span> <span class="token number">3</span>Ø S_IROTH <span class="token number">00004</span> <span class="token number">2</span>Ø S_IWOTH <span class="token number">00002</span> <span class="token number">1</span>Ø S_IXOTH <span class="token number">00001</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、库"><a href="#四、库" class="headerlink" title="四、库"></a>四、库</h2><h3 id="1-库的概念"><a href="#1-库的概念" class="headerlink" title="1.库的概念"></a>1.库的概念</h3><ul><li>库是一个二进制文件， 包含的代码可被程序调用</li><li>标准C库、 数学库、 线程库……</li><li>库有源码， 可下载后编译； 也可以直接安装二进制包</li><li>/lib /usr/lib</li></ul><h3 id="2-库的知识"><a href="#2-库的知识" class="headerlink" title="2.库的知识"></a>2.库的知识</h3><ul><li>库是事先编译好的， 可以复用的代码。</li><li>在OS上运行的程序基本上都要使用库。 使用库可以提高开发效率。</li><li>Windows和Linux下库文件的格式不兼容</li><li>Linux下包含静态库和共享库</li></ul><h3 id="3-静态库特点"><a href="#3-静态库特点" class="headerlink" title="3.静态库特点"></a>3.静态库特点</h3><ul><li>编译(链接)时把静态库中相关代码复制到可执行文件中<ul><li>程序中已包含代码， 运行时不再需要静态库</li><li>程序运行时无需加载库， 运行速度更快</li><li>占用更多磁盘和内存空间</li><li>静态库升级后， 程序需要重新编译链接</li></ul></li></ul><h3 id="4-静态库创建-1"><a href="#4-静态库创建-1" class="headerlink" title="4.静态库创建(1)"></a>4.静态库创建(1)</h3><pre class="line-numbers language-c"><code class="language-c">Ø 确定库中函数的功能、 接口Ø 编写库源码hello<span class="token punctuation">.</span>c<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span>“hello world\n”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Ø 编译生成目标文件$ gcc <span class="token operator">-</span>c hello<span class="token punctuation">.</span>c <span class="token operator">-</span>Wall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-静态库创建-2"><a href="#5-静态库创建-2" class="headerlink" title="5.静态库创建(2)"></a>5.静态库创建(2)</h3><pre class="line-numbers language-c"><code class="language-c">Ø 创建静态库 hello$ ar crs libhello<span class="token punctuation">.</span>a hello<span class="token punctuation">.</span>oØ 查看库中符号信息$nm libhello<span class="token punctuation">.</span>ahello<span class="token punctuation">.</span>o<span class="token punctuation">:</span><span class="token number">0000000</span> T helloU puts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-链接静态库"><a href="#6-链接静态库" class="headerlink" title="6.链接静态库"></a>6.链接静态库</h3><pre class="line-numbers language-c"><code class="language-c">Ø 编写应用程序test<span class="token punctuation">.</span>c<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Ø 编译test<span class="token punctuation">.</span>c 并链接静态库libhello<span class="token punctuation">.</span>a$ gcc <span class="token operator">-</span>o test test<span class="token punctuation">.</span>c <span class="token operator">-</span>L<span class="token punctuation">.</span> <span class="token operator">-</span>lhello$ <span class="token punctuation">.</span><span class="token operator">/</span>testhello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-共享库的特点"><a href="#7-共享库的特点" class="headerlink" title="7.共享库的特点"></a>7.共享库的特点</h3><ul><li>编译(链接)时仅记录用到哪个共享库中的哪个符号，不复制共享库中相关代码<ul><li>程序不包含库中代码， 尺寸小</li><li>多个程序可共享同一个库</li><li>程序运行时需要加载库</li><li>库升级方便， 无需重新编译程序</li><li>使用更加广泛</li></ul></li></ul><h3 id="8-共享库创建-1"><a href="#8-共享库创建-1" class="headerlink" title="8.共享库创建(1)"></a>8.共享库创建(1)</h3><pre class="line-numbers language-c"><code class="language-c">Ø 确定库中函数的功能、 接口Ø 编写库源码hello<span class="token punctuation">.</span>c bye<span class="token punctuation">.</span>c<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">void</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span>“hello world\n”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Ø 编译生成目标文件$ gcc <span class="token operator">-</span>c <span class="token operator">-</span>fPIC hello<span class="token punctuation">.</span>c bye<span class="token punctuation">.</span>c <span class="token operator">-</span>Wall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9-共享库创建-2"><a href="#9-共享库创建-2" class="headerlink" title="9.共享库创建(2)"></a>9.共享库创建(2)</h3><pre class="line-numbers language-c"><code class="language-c">Ø 创建共享库 common$ gcc <span class="token operator">-</span>shared <span class="token operator">-</span>o libcommon<span class="token punctuation">.</span>so<span class="token number">.1</span> hello<span class="token punctuation">.</span>o bye<span class="token punctuation">.</span>oØ 为共享库文件创建链接文件$ ln <span class="token operator">-</span>s libcommon<span class="token punctuation">.</span>so<span class="token number">.1</span> libcommon<span class="token punctuation">.</span>soØ 符号链接文件命名规则lib<span class="token operator">&lt;</span>库名<span class="token operator">></span><span class="token punctuation">.</span>so<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-链接共享库"><a href="#10-链接共享库" class="headerlink" title="10.链接共享库"></a>10.链接共享库</h3><pre class="line-numbers language-c"><code class="language-c">Ø 编写应用程序test<span class="token punctuation">.</span>c<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> “common.h”</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">bye</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span>Ø 编译test<span class="token punctuation">.</span>c 并链接共享库libcommon<span class="token punctuation">.</span>so$ gcc <span class="token operator">-</span>o test test<span class="token punctuation">.</span>c <span class="token operator">-</span>L<span class="token punctuation">.</span> <span class="token operator">-</span>lcommon<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-加载共享库"><a href="#11-加载共享库" class="headerlink" title="11.加载共享库"></a>11.加载共享库</h3><pre class="line-numbers language-c"><code class="language-c">Ø 执行程序$ <span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">.</span><span class="token operator">/</span>test<span class="token punctuation">:</span> error <span class="token keyword">while</span> loading shared libraries<span class="token punctuation">:</span> libcommon<span class="token punctuation">.</span>socannot open shared object file <span class="token punctuation">:</span> No such file or directoryØ 添加共享库的加载路径$ export LD_LIBRARY_PATH<span class="token operator">=</span>$LD_LIBRARY_PATH<span class="token punctuation">:</span><span class="token punctuation">.</span>$ <span class="token punctuation">.</span><span class="token operator">/</span>testhello worldbye<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="12-如何找到共享库"><a href="#12-如何找到共享库" class="headerlink" title="12.如何找到共享库"></a>12.如何找到共享库</h3><ul><li>为了让系统能找到要加载的共享库， 有三种方法 ：<ul><li>把库拷贝到/usr/lib和/lib目录下</li><li>在LD_LIBRARY_PATH环境变量中添加库所在路径</li><li>添加/etc/ld.so.conf.d/*.conf文件， 执行ldconfig刷新</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树与二叉树</title>
      <link href="/2020/072040544.html"/>
      <url>/2020/072040544.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、树的定义："><a href="#一、树的定义：" class="headerlink" title="一、树的定义："></a>一、树的定义：</h2><h3 id="1、定义："><a href="#1、定义：" class="headerlink" title="1、定义："></a>1、定义：</h3><ul><li>树（Tree）是n（n&gt;=0）个节点的有限集，n=0时称为“空树”。在任意一棵非空树中：<ul><li>⒈有且仅有一个特定的称为根（root）的节点。</li><li>⒉当n&gt;1时，其余节点可分为m（m&gt;0）个互不相交的有限集T1、T2……Tm，其中每一个集合本身又是一棵树，并且称之为根的子树（SubTree）。</li></ul></li><li>注意：<ul><li>⒈n&gt;0时根节点是唯一的，不可能存在多个根节点。</li><li>⒉m&gt;0时，子树个数没有限制，但一定互不相交。<h3 id="2、树的节点的分类："><a href="#2、树的节点的分类：" class="headerlink" title="2、树的节点的分类："></a>2、树的节点的分类：</h3></li></ul></li><li>树的节点包含一个数据元素以及若干个指向其子树的分支。节点拥有的子树个数称为节点的度（Degree）。度为0的节点称为叶节点（Leaf）；度不为0且不为根节点的节点称为“内部节点”。<h3 id="3、节点间关系："><a href="#3、节点间关系：" class="headerlink" title="3、节点间关系："></a>3、节点间关系：</h3></li><li>节点的子树的根称为该节点的孩子（Child），相应地，该节点称为孩子的父（Parent，或翻译成“双亲”）。同一个父节点的孩子之间互称兄弟（Sibling）。<h3 id="4、层次："><a href="#4、层次：" class="headerlink" title="4、层次："></a>4、层次：</h3></li><li>节点的层次（Level）从根开始定义起，根为第一层，根的孩子为第二层，依次类推。树中节点的最大层次称为树的深度（Depth）或高度。</li><li>如果该树中节点的子树看成是从左到右有次序的，不能互换的，则称该树为有序树，否则称为无序树。</li></ul><h2 id="二、二叉树"><a href="#二、二叉树" class="headerlink" title="二、二叉树"></a>二、二叉树</h2><h3 id="1、定义：-1"><a href="#1、定义：-1" class="headerlink" title="1、定义："></a>1、定义：</h3><ul><li>二叉树（Binary Tree）是n（n&gt;=0）个节点的有限集合，该集合或者为空集（称为“空二叉树”），或者由一个根节点和两棵互不相交的、分别称为根节点的左子树和右子树的二叉树组成。</li><li>定理：任意一棵树都可以完全等价于一棵二叉树。<h3 id="2、二叉树的特点："><a href="#2、二叉树的特点：" class="headerlink" title="2、二叉树的特点："></a>2、二叉树的特点：</h3></li><li>⒈每个节点最多有两棵子树，所以二叉树中不存在度大于2的节点。注意不是“只有”，而是“最多有”，即可以没有子树或只有一棵子树。</li><li>⒉左子树和右子树有序，不能随意颠倒。</li><li>⒊即使树中某节点只有一棵子树，也要区分它是左子树还是右子树，不能混淆。<h3 id="3、二叉树的基本形态："><a href="#3、二叉树的基本形态：" class="headerlink" title="3、二叉树的基本形态："></a>3、二叉树的基本形态：</h3></li><li>二叉树具有五种基本形态<ul><li>⒈空二叉树</li><li>⒉只有一个根节点</li><li>⒊根节点只有左子树</li><li>⒋根节点只有右子树</li><li>⒌根节点既有左子树又有右子树<h3 id="4、满二叉树："><a href="#4、满二叉树：" class="headerlink" title="4、满二叉树："></a>4、满二叉树：</h3></li></ul></li><li>在一棵二叉树中，如果所有分支节点都存在左子树和右子树，并且所有叶子节点都在同一层上，这样的二叉树称为满二叉树。</li><li>满二叉树的特点有：<ul><li>⒈叶子节点只能出现在最下面一层。出现在其他层就不可能达到平衡。</li><li>⒉非叶子节点的度一定是2。</li><li>⒊在同样深度的二叉树中，满二叉树的节点个数最多，叶子节点个数最多。<h3 id="5、完全二叉树："><a href="#5、完全二叉树：" class="headerlink" title="5、完全二叉树："></a>5、完全二叉树：</h3></li></ul></li><li>对一棵具有n个节点的二叉树按层序编号，如果编号为i（1&lt;=i&lt;=n）的节点与同样深度的满二叉树中编号为i的节点在二叉树中的位置完全相同，则这棵二叉树称为完全二叉树。</li><li>需要注意区分满二叉树与完全二叉树，满二叉树一定是一棵完全二叉树，而完全二叉树不一定是满的。</li><li>判定一棵二叉树是否是完全二叉树需要对该二叉树进行层序编号。</li><li>层序编号：以根节点作为起点，从左至右对每一层的节点进行编号。对该层的所有节点编号完毕后再对下一层的节点进行编号。</li><li>从这里我们也可以得到一些完全二叉树的特点：<ul><li>⒈叶子节点只能出现在最下两层</li><li>⒉最下层的叶子节点一定集中在左部的连续位置</li><li>⒊倒数二层，若有叶子节点，一定都在右部连续位置</li><li>⒋如果节点度为1，则该节点只有左孩子，不存在只有右子树的情况</li><li>⒌同样节点数的二叉树，完全二叉树的深度最小</li></ul></li><li>注意：同样节点数的二叉树，深度最小的二叉树不一定是完全二叉树</li></ul><h2 id="三、二叉树的性质"><a href="#三、二叉树的性质" class="headerlink" title="三、二叉树的性质"></a>三、二叉树的性质</h2><ul><li>关于二叉树，有一些需要理解并记忆的特性，以便我们更好使用它<h3 id="1、性质1："><a href="#1、性质1：" class="headerlink" title="1、性质1："></a>1、性质1：</h3></li><li>在二叉树的第i层上至多有2^(i-1)个节点（i&gt;=1）。<h3 id="2、性质2："><a href="#2、性质2：" class="headerlink" title="2、性质2："></a>2、性质2：</h3></li><li>深度为k的二叉树至多有2^k-1个节点（k&gt;=1）。注意不是2^(k-1)。<h3 id="3、性质3："><a href="#3、性质3：" class="headerlink" title="3、性质3："></a>3、性质3：</h3></li><li>对于任何一棵二叉树T，如果其叶子节点数为n0，度为2的节点数为n2，则n0=n2+1。</li><li>性质3的推导：<pre class="line-numbers language-c"><code class="language-c">二叉树的节点的度只有<span class="token number">3</span>种：<span class="token number">0</span>、<span class="token number">1</span>、<span class="token number">2</span>。我们设其对应的节点数分别为n0、n1、n2，则二叉树的节点总数为：Tn<span class="token operator">=</span>n0<span class="token operator">+</span>n1<span class="token operator">+</span>n2二叉树的连线数应等于节点个数减<span class="token number">1</span>，即Sn<span class="token operator">=</span>Tn<span class="token number">-1</span>另一方面，二叉树的连线数应等于<span class="token number">2</span><span class="token operator">*</span>n2<span class="token operator">+</span>n1，即Sn<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>n2<span class="token operator">+</span>n1我们可得到：n0<span class="token operator">+</span>n1<span class="token operator">+</span>n2<span class="token number">-1</span><span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>n2<span class="token operator">+</span>n1整理可得n0<span class="token operator">=</span>n2<span class="token operator">+</span><span class="token number">1</span>若事先已知叶子节点个数，使用性质<span class="token number">3</span>可以快速计算出一个二叉树的度为<span class="token number">2</span>的节点个数，进而推出度为<span class="token number">1</span>的节点个数。例：假设一个完全二叉树的总节点个数为<span class="token number">699</span>个，则叶子节点有几个？答：<span class="token number">350</span>个。（没有n1）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、二叉树的存储"><a href="#四、二叉树的存储" class="headerlink" title="四、二叉树的存储"></a>四、二叉树的存储</h2></li><li>二叉树在内存中是无法形象存储的，通常情况下我们可以使用顺序存储和链式存储两种结构来模拟双亲与孩子的逻辑关系从而存储二叉树。<h3 id="1、顺序存储结构"><a href="#1、顺序存储结构" class="headerlink" title="1、顺序存储结构"></a>1、顺序存储结构</h3></li><li>顺序存储结构就是利用一维数组存储二叉树中的节点。将一个完全二叉树按层序编号的方式，可以得到节点编号与该节点的数据的一一对应关系，这样我们就可以使用数组来存储该完全二叉树了。</li><li>对于非完全二叉树，我们需要先将其补全为完全二叉树，再进行存储。后补的节点存储时数据为空（NULL）。考虑到一种极端情况，若有一棵深度为k的右斜树，只有k个节点，但根据存储方式我们需要建立一个2^k-1个存储单元。因此顺序存储一般不常用，仅用于存储完全二叉树。<h3 id="2、链式存储结构"><a href="#2、链式存储结构" class="headerlink" title="2、链式存储结构"></a>2、链式存储结构</h3></li><li>既然顺序存储适用性不强，我们就要考虑链式存储结构。二叉树每个节点最多有两个孩子，所以为它涉及一个数据域和两个指针域。<pre class="line-numbers language-c"><code class="language-c">lchild︱data︱rchild其中data是数据域，lchild和rchild都是指针域，分别存放指向左孩子和右孩子的指针。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>typedef struct BiTNode<br>{<br>    data_t data;<br>    struct BiTNode <em>lchild,</em>rchild;<br>}BiTNode,*BiTree;</p><pre><code>- 如果需要，我们还可以再增加一个指向其父节点的指针域，这里不再赘述。## 五、二叉树的遍历- 二叉树的遍历（traversing）是指从根节点出发，按照某种次序依次访问二叉树中所有节点，使得每个节点被且仅被访问一次。- 二叉树的遍历方式有很多，常用的有前序遍历、中序遍历、后序遍历3种。### 1、前序遍历（PreOrderTraverse）- 规则：    - ⒈若二叉树为空，则不进行操作，返回    - ⒉访问根节点    - ⒊前序遍历左子树    - ⒋前序遍历右子树### 2、中序遍历（InOrderTraverse）- 规则：- ⒈若二叉树为空，则不进行操作，返回    - ⒉中序遍历左子树    - ⒊访问根节点    - ⒋中序遍历右子树### 3、后序遍历（PostOrderTraverse）- 规则：    - ⒈若二叉树为空，则不进行操作，返回    - ⒉后序遍历左子树    - ⒊后序遍历右子树    - ⒋访问根节点- 无论是前序遍历、中序遍历还是后序遍历，都使用到了递归的定义方法。![数据结构_二叉树的递归遍历](https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P数据结构_二叉树的递归遍历.png)- 思考：我们为什么要研究这么多种不同的遍历方法呢？    - 答：我们用图形来表现树的结构十分直观和容易理解，但是对于计算机来说，它只能处理循环、分支等问题，也就是说，它只能处理线性问题。以上3种遍历方法都是人为地将二叉树变成某个有意义的线性序列，方便计算机处理。```c练习1：有一棵二叉树，其前序遍历结果为ABDC，中序遍历结果为BDAC，画出该二叉树。练习2：有一棵二叉树，其中序遍历结果为ABCDEFG，后序遍历结果为BDCAFGE，画出该二叉树并求其前序遍历的结果。练习3：已知一棵二叉树的前序遍历结果为ABC，后序遍历的结果为CBA，画出该二叉树。- 由以上三个练习我们可以得出：    - ⒈已知前序遍历和中序遍历，可以唯一确定一棵二叉树。    - ⒉已知中序遍历和后序遍历，可以唯一确定一棵二叉树。    - ⒊但已知前序遍历和后序遍历，无法唯一确定一棵二叉树。</code></pre><h2 id="六、二叉树的建立"><a href="#六、二叉树的建立" class="headerlink" title="六、二叉树的建立"></a>六、二叉树的建立</h2><ul><li>有了遍历方法，我们就可以在遍历过程中来创建一棵二叉树。</li><li>若我们要创建一棵二叉树，首先我们要对这棵二叉树进行扩展，将每个节点都补上一个虚拟的孩子节点，数据为空。这样我们通过遍历这个扩展二叉树得到遍历序列就可以创建这棵二叉树了。<pre class="line-numbers language-c"><code class="language-c">示例：创建练习<span class="token number">1</span>中的二叉树⒈首先对这棵二叉树进行扩展，补全其所有节点的孩子节点，数据为空（以#代替）⒉得到该扩展二叉树的前序遍历为AB#D##C##⒊通过前序遍历的方法，边遍历边创建这棵二叉树其实创建二叉树，也是利用了递归的原理，只不过在原来应该打印节点的操作替换为生成节点的操作而已。当然我们也可以使用中序遍历和后序遍历来创建二叉树。若这棵二叉树使用中序遍历来创建，则需要的序列为#B#D#A#C#；若使用后序遍历来创建，则需要的序列为###DB##CA。<span class="token comment" spellcheck="true">//代码见附录</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="七、二叉树的应用——赫夫曼树与赫夫曼编码"><a href="#七、二叉树的应用——赫夫曼树与赫夫曼编码" class="headerlink" title="七、二叉树的应用——赫夫曼树与赫夫曼编码"></a>七、二叉树的应用——赫夫曼树与赫夫曼编码</h2><h3 id="1、赫夫曼树"><a href="#1、赫夫曼树" class="headerlink" title="1、赫夫曼树"></a>1、赫夫曼树</h3></li><li>赫夫曼（David Huffman，也译为“哈夫曼”），美国数学家，他在1952年发明了赫夫曼树与赫夫曼编码。赫夫曼编码是当代压缩和解压缩技术的基础。</li><li>我们通过一个具体的示例来体会一下什么叫赫夫曼树（Huffman Tree）。<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//给定一个成绩（0~100），输出所对应的分数段。我们可以通过以下代码来实现：</span><span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">&lt;</span><span class="token number">60</span><span class="token punctuation">)</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"不及格\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">&lt;</span><span class="token number">70</span><span class="token punctuation">)</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"及格\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">&lt;</span><span class="token number">80</span><span class="token punctuation">)</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"中等\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">&lt;</span><span class="token number">90</span><span class="token punctuation">)</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"良\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"优\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>粗略来看没什么问题，但在通常情况下，学生成绩大致都分布在“良”和“中等”的分数段，处于两端的“优”和“不及格”反而很少：不及格：<span class="token number">5</span><span class="token operator">%</span>及格：<span class="token number">15</span><span class="token operator">%</span>中等：<span class="token number">40</span><span class="token operator">%</span>良：<span class="token number">30</span><span class="token operator">%</span>优：<span class="token number">10</span><span class="token operator">%</span>在这种情况下，若采用上面的程序，则判断数量最大的“中等”和“良”分数段时，都需要至少<span class="token number">3</span>次的比较才能得出结果，大大影响了程序的执行效率。如果我们改进算法，将比利最高的“中等”或“良”作为首个判断条件，则可大大加快程序的执行效率。<span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">&lt;</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">&lt;</span><span class="token number">70</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">&lt;</span><span class="token number">60</span><span class="token punctuation">)</span>          <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"不及格\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">else</span>          <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"及格\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">else</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"中等\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">&lt;</span><span class="token number">90</span><span class="token punctuation">)</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"良\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"优\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、赫夫曼树的定义"><a href="#2、赫夫曼树的定义" class="headerlink" title="2、赫夫曼树的定义"></a>2、赫夫曼树的定义</h3></li><li>我们可以将上文中的程序画成二叉树的形式，每个if分支都作为二叉树的两个子树，将概率标记到父节点到子节点的路径上。这样的树叫做带权（Weight）树。</li><li>从树中一个节点到另一个节点之间的边构成了两点之间的路径，路径上的权值之和叫做路径长度。树的路径长度就是从根节点出发到每一个节点的路径长度之和。如果考虑带权的二叉树，节点的带权路径长度等于从该点到根节点的路径长度乘以该点的权值的乘积。带权二叉树的路径长度为所有叶子节点的带权路径长度之和。</li><li>针对同一问题，不同的二叉树画法路径长度也不同，其中最小路径长度的树就叫做赫夫曼树。<br>###3、构造一棵赫夫曼树</li><li>构造一棵赫夫曼树的流程如下：<pre class="line-numbers language-c"><code class="language-c">⒈将所有叶子节点按权值大小有序排列。例如上文的成绩占比，我们可以排列成：A5  E10  B15  D30  C40⒉取前面两个最小的叶子节点作为兄弟节点，权值小的做左孩子，权值大的做右孩子，它们两个共用一个父节点N1，其父节点的权值为两个叶子节点的权值的和。得到：N115  B15  D30  C40⒊重复步骤<span class="token number">2</span>，将N1与B作为新的两个子节点，其父节点为N2，权值为<span class="token number">30</span>N230  D30  C40⒋重复步骤<span class="token number">2</span>，将N2与D作为新的两个子节点，其父节点为N3，权值为<span class="token number">60</span>C40  N360⒌重复步骤<span class="token number">2</span>，将C与N3作为新的两个子节点，由于这时所有节点都已构造完毕，因此其父节点就是该二叉树的根节点。最后得到构造完成的赫夫曼树如图：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>此时该二叉树的带权路径长度为WPL=40<em>1+30</em>2+15<em>3+10</em>4+5*4=205。</p><pre><code>### 4、赫夫曼编码- 其实构造赫夫曼树可不是为了解决程序效率低的问题，赫夫曼树的主要作用是用来构造赫夫曼编码，而赫夫曼编码则是为了解决当年远距离通信（主要是电报）的数据传输最优化问题。```c//例如：若有一个编码规则：A 000B 001C 010D 011E 100F 101可以看出是简单的以二进制的方式进行编码。若有以下报文：BADCADFEED则按照以上编码规则编码后，获得编码为：001000011010000011101100100011对方接收到报文编码后，按编码规则3位一分来解码即可。事实上，英语中字母的使用频率是不同的，常用字母（如a e i o u等）使用频率特别高，而不常用字母（如j v z等）使用频率就低得多。如果我们能人为减少常见字母的编码长度，则整个报文长度都会缩短，这样既方便传输又节省了存储空间。假设上文的编码规则中，各字母出现的额频率如下：可以看到，如果我们能缩短字母A和E的编码长度，则我们就可以大大缩短报文长度。这种压缩效果在文本长度很长时效果会更加明显。但是我们看到，所有编码都是以二进制（0/1）进行编码的，贸然缩短字母A和E的编码长度很容易引起混淆，若要设计这种长短不等的编码，必须使得任意字符的编码不能是其他字符编码的前缀。我们可以使用上文构造赫夫曼树的方法来构造一个赫夫曼树：假设在一个报文中，6个字母的出现频率如下：A 27%B 8%C 15%D 15%E 30%F 5%则我们可以构造出如下的赫夫曼树：构造完毕后，若从根节点出发，规定走向左子树的边编码为0，走向右子树的边编码为1，则我们就可以得到每个字母新的编码：A 01B 1001C 101D 00E 11F 1000则使用新的编码规则后，对报文BADCADFEED获得新的报文编码如下：1001010010101001000111100（新）001000011010000011101100100011（旧）大概缩短了17%。而且我们发现，通过赫夫曼树构造出的赫夫曼编码，不会存在因编码长短不一而混淆的情况。现代计算机程序中大部分的压缩文件算法都是基于赫夫曼编码改进而来的。1977年，Lempel-Ziv在对赫夫曼编码进行深度研究后，发表了“顺序数据压缩的一个通用算法（A Universal Algorithm for Sequential Data Compression ）”的论文，论文中描述的算法被后人称为LZ77算法。LZ77算法以及后续的衍生算法是现在一些通行的压缩包模式（ARJ，PKZip，WinZip，LHArc，RAR，GZip，ACE，ZOO，TurboZip，Compress，JAR，7z等）的编码基础算法。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell编程</title>
      <link href="/2020/072011349.html"/>
      <url>/2020/072011349.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、Shell编程简介"><a href="#一、Shell编程简介" class="headerlink" title="一、Shell编程简介"></a>一、Shell编程简介</h2><ul><li>之前课程中已经介绍过，在操作系统的内核kernel外部有一个Shell层，Shell的作用是保护内核kernel不受损害。同时，Shell接收用户对Linux系统的操作指令并传递给内核，之后由内核执行。</li><li>之前学习过的Shell命令都是运行在Shell层上的，每次我们通过terminal输入一条命令，再通过Shell交给内核执行。有时，我们的需求过于复杂，需要执行多条命令，此时一条一条的在terminal内输入命令会十分的繁琐。Shell层提供给我们一个脚本工具，我们可以将想要依次执行的命令写成脚本文件，再将脚本文件发送给Shell。这样Shell就会按照脚本文件内记载的命令依次执行，从而实现了自动化。<br>//Shell脚本在Windows系统内称为“批处理文件”（.bat文件），本质相同<br>也就是说，Shell脚本的实质就是Shell命令的有序集合。<h3 id="1、编译型语言与解释性语言"><a href="#1、编译型语言与解释性语言" class="headerlink" title="1、编译型语言与解释性语言"></a>1、编译型语言与解释性语言</h3></li><li>本质上来说，编程并让计算机执行实际上是一个将其中一种语言（编程语言）翻译成另外一种语言（机器语言）的过程。那么翻译语言肯定需要一定的翻译策略。编程语言从源代码变成计算机识别的可执行程序有“编译”和“解释”两种方式。<h4 id="1）编译"><a href="#1）编译" class="headerlink" title="1）编译"></a>1）编译</h4><pre class="line-numbers language-c"><code class="language-c">  <span class="token operator">-</span>需要编译器  <span class="token operator">-</span>对代码进行整体检查  <span class="token operator">-</span>主要进行词法检查、语法分析、语义检查和中间代码生成、代码优化、目标代码生成<span class="token number">5</span>部分  <span class="token operator">-</span>若代码有错误，则停止编译并报错；若无错误，则会生成目标代码  <span class="token operator">-</span>执行效率较高  <span class="token operator">-</span>代表语言：C<span class="token operator">/</span>C<span class="token operator">++</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2）解释"><a href="#2）解释" class="headerlink" title="2）解释"></a>2）解释</h4><pre class="line-numbers language-c"><code class="language-c">  <span class="token operator">-</span>需要解释器  <span class="token operator">-</span>依次执行代码内每条命令，每句执行一次  <span class="token operator">-</span>只会运行到当前语句时才会翻译该命令  <span class="token operator">-</span>若代码有错误，则在出错语句处停止，而该语句上面的语句已经被执行  <span class="token operator">-</span>执行效率较低  <span class="token operator">-</span>代表语言：Python、JavaScript、Shell脚本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>我们在进行Shell编程的时候，本质上是将多条Shell命令写在一个文件内（脚本），然后terminal按照该文件内每条命令开始执行命令。因此Shell脚本是一种典型的解释性编程语言。<h3 id="2、Shell编程的基本步骤"><a href="#2、Shell编程的基本步骤" class="headerlink" title="2、Shell编程的基本步骤"></a>2、Shell编程的基本步骤</h3></li><li>我们进行Shell编程有以下几个步骤：<ul><li>1.建立Shell脚本文件</li><li>2.给Shell脚本文件可执行的权限</li><li>3.执行Shell脚本<pre class="line-numbers language-bash"><code class="language-bash">示例：使用Shell编程第一步：建立Shell脚本文件，文件名为myshell.sh。文件内容：<span class="token comment" spellcheck="true">#!/bin/bash</span><span class="token function">date</span><span class="token function">cat</span> myshell.sh<span class="token function">ping</span> -c 3 114.114.114.114<span class="token keyword">echo</span> <span class="token string">"hello world"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><p>脚本内的命令分别代表：<br>1.#!/bin/bash是Shell脚本文件的固定开头，该命令说明了这个Shell脚本在哪个程序上执行。在这里表示使用/bin/bash来执行这个脚本。<br>注：在Shell脚本中，#开头的行表示注释。<br>2.打印当前系统时间<br>3.查看myshell.sh文件内容<br>4.ping3次114.114.114.114检查网络通断<br>5.在终端打印hello world</p><p>第二步：给Shell脚本文件可执行的权限<br>我们刚刚写的Shell脚本文件只是一个普通的文本文件，没有可执行的权限，因此我们需要给该文件添加可执行权限。<br>chmod 0775 myshell.sh<br>这样myshell.sh就具有可执行权限了。我们可以使用ls -l命令查看该文件的权限</p><p>第三步：执行该Shell脚本<br>./myshell.sh<br>执行该Shell脚本即可查看效果</p><pre><code>## 二、Shell编程的变量- 和C语言一样，Shell编程也有变量。在Shell脚本内，所有的变量都是字符串类型但是不支持数据类型（整型、字符型、浮点型等），并且无需对变量进行声明。- 在sh/bash中有4种变量：    - -用户自定义变量    - -位置参数（命令行参数）    - -预定义变量    - -环境变量### 1、用户自定义变量- Shell编程允许用户自定义变量来存储数据，但不支持数据类型（整型、字符型、浮点型等），任何变量的值都被解释成一个字符串。变量名命名规则如下：    - 1.首字符必须是字母或者下划线    - 2.中间不能有空格，可以使用下划线_表示空格    - 3.不能使用除下划线外其他的标点符号- 我们可以使用=给变量赋值，格式为：    - 变量名=变量值- 注意等号两边没有空格。在Shell编程中变量名一般使用全大写字母，为了与Shell命令区分。    - COUNT=1- 若想调用一个变量的值，则需要在该变量名前面加上$。例如：```bash#!/bin/bashCOUNT=1VAR=&quot;hello world&quot;echo $COUNTecho COUNTecho $VAR</code></pre><ul><li>注意第一个echo命令与第二个echo命令输出的区别。第一个echo命令会输出COUNT变量的值1，而第二个echo命令会将COUNT当做待输出的字符串处理，会输出COUNT。<pre class="line-numbers language-bash"><code class="language-bash">Shell编程支持变量互相赋值，赋值方向为从右向左。例如：Y<span class="token operator">=</span>2X<span class="token operator">=</span><span class="token variable">$Y</span>则变量X内就得到了变量Y的值2。某些情况下，我们定义的变量会与其他文字混淆。例如：num<span class="token operator">=</span>2<span class="token keyword">echo</span> <span class="token string">"this is the <span class="token variable">$numnd</span>"</span>此时执行该Shell脚本不会输出<span class="token string">"this is the 2nd"</span>而会输出<span class="token string">"this is the"</span>，因为echo命令无法找到一个名为<span class="token string">"numnd"</span>的变量。我们可以使用花括号来包裹变量名，被花括号包裹的字符串会被Shell当做是一个变量来处理。num<span class="token operator">=</span>2<span class="token keyword">echo</span> <span class="token string">"this is the <span class="token variable">${num}</span>nd"</span>这样就可以输出<span class="token string">"this is the 2nd"</span>。我们可以使用unset命令删除已定义过的变量。例如：Z<span class="token operator">=</span>hello<span class="token keyword">echo</span> <span class="token variable">$Z</span>unset Z<span class="token keyword">echo</span> <span class="token variable">$Z</span>则第二次执行的时候就不会输出变量Z的值。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、位置变量（命令行参数）"><a href="#2、位置变量（命令行参数）" class="headerlink" title="2、位置变量（命令行参数）"></a>2、位置变量（命令行参数）</h3></li><li>由系统提供的参数称为位置参数，其作用等价于C语言中main函数传参的“命令行参数”。位置参数可以使用$+数字的形式获得。<ul><li>$0 与键入命令一样</li><li>$1~$9 第一个到第九个命令行参数</li></ul></li><li>例如：<pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">echo</span> <span class="token string">"this is 0"</span> <span class="token variable">$0</span><span class="token keyword">echo</span> <span class="token string">"this is 1"</span> <span class="token variable">$1</span>在执行该Shell脚本的时候我们携带一个命令行参数：./myshell 123则会输出：this is 0 ./myshell.shthis is 1 123<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3、预定义变量"><a href="#3、预定义变量" class="headerlink" title="3、预定义变量"></a>3、预定义变量</h3></li><li>Shell编程内事先定义了一些变量，用户只能使用这些变量而不能重新定义它们。所有的预定义变量都由$符号和另一个符号构成，常用的预定义变量如下：<ul><li>$# 命令行参数的个数</li><li>$@ 所有命令行参数（不计$0，同$*）</li><li>$? 前一个命令的退出状态</li><li>$* 所有命令行参数（不计$0，同$@）</li><li>$$ 正在执行的进程ID号</li></ul></li><li>示例：演示各个位置变量的值<pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">echo</span> <span class="token string">"this is 0"</span> <span class="token variable">$0</span><span class="token keyword">echo</span> <span class="token string">"this is 1"</span> <span class="token variable">$1</span><span class="token keyword">echo</span> <span class="token string">"this is #"</span> <span class="token variable">$#</span><span class="token keyword">echo</span> <span class="token string">"this is @"</span> <span class="token variable">$@</span><span class="token keyword">echo</span> <span class="token string">"this is ?"</span> <span class="token variable">$?</span><span class="token keyword">echo</span> <span class="token string">"this is *"</span> <span class="token variable">$*</span><span class="token keyword">echo</span> <span class="token string">"this is $"</span> $$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>执行：./myshell.sh 123 456 789<br>输出：<br>this is 0 ./myshell.sh<br>this is 1 123<br>this is # 3<br>this is @ 123 456 789<br>this is ? 0<br>this is * 123 456 789<br>this is $ 2710</p><pre><code>### 4、环境变量- 环境变量适用于所有用户进程，环境变量均为大写。常用的环境变量如下：```bash    HOME        用户工作目录所在地址，在文件/etc/passwd文件内存储    IFS（Internal Field Separator） 内部字段分隔符，默认是空格、tab以及换行符    PATH        Shell搜索路径    PS1            命令提示符格式（$及$前的字符）（PS是Prompt Sign的缩写）    PS2            换行提示符&gt;    TERM        终端类型，常见的值有vt100、vt200、ansi、xterm等    HISTSIZE    保存历史记录的条目数    LOGNAME        当前登录用户名    HOSTNAME    主机名称    SHELL        当前使用的Shell类型    LANG/LANGUAGE与语言相关的环境变量    MAIL        用户的邮件存放目录    TMOUT        设置的脚本过期时间。例如TMOUT=3则表示该脚本3秒后过期    UID            登录用户的ID    USER        显示当前用户名    SECONDS        记录脚本从开始运行到结束耗费的时间</code></pre><ul><li>示例：演示各个环境变量的值<pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">echo</span> <span class="token string">"HOME IS "</span> <span class="token variable">$HOME</span><span class="token keyword">echo</span> <span class="token string">"IFS IS "</span> <span class="token variable">$IFS</span><span class="token keyword">echo</span> <span class="token string">"PATH IS "</span> <span class="token variable">$PATH</span><span class="token keyword">echo</span> <span class="token string">"TERM IS "</span> <span class="token variable">$TERM</span><span class="token keyword">echo</span> <span class="token string">"LANGUAGE IS "</span> <span class="token variable">$LANG</span><span class="token keyword">echo</span> <span class="token string">"LOGNAME IS "</span> <span class="token variable">$LOGNAME</span><span class="token keyword">echo</span> <span class="token string">"HOSTNAME IS "</span> <span class="token variable">$HOSTNAME</span><span class="token keyword">echo</span> <span class="token string">"SHELL IS "</span> <span class="token variable">$SHELL</span><span class="token keyword">echo</span> <span class="token string">"MAIL IS "</span> <span class="token variable">$MAIL</span><span class="token keyword">echo</span> <span class="token string">"UID IS "</span> <span class="token variable">$UID</span><span class="token keyword">echo</span> <span class="token string">"USER IS "</span> <span class="token variable">$USER</span> 我们可以使用env命令查看更多的环境变量信息。我们可以使用export命令来自定义环境变量，使用unset命令清除环境变量。例如：<span class="token function">export</span> HELLO<span class="token operator">=</span><span class="token string">"Hello"</span><span class="token keyword">echo</span> <span class="token variable">$HELLO</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、Shell编程语句"><a href="#三、Shell编程语句" class="headerlink" title="三、Shell编程语句"></a>三、Shell编程语句</h2></li><li>Shell脚本由0条或多条Shell语句构成，Shell语句可以分为三类：<ul><li>1.说明性语句：以#开始到该行结束，对Shell语句说明，不会被执行。类似C语言的注释</li><li>2.功能性语句：任意的Shell命令、用户程序或其他</li><li>3.结构性语句：条件语句、分支语句、循环语句、循环控制语句等<h3 id="1、说明性语句（注释行语句）"><a href="#1、说明性语句（注释行语句）" class="headerlink" title="1、说明性语句（注释行语句）"></a>1、说明性语句（注释行语句）</h3></li></ul></li><li>说明性语句可以出现在程序的任意位置，既可以独立一行，也可以接在其他语句后面。说明性语句都是以#开头的语句，在Shell脚本执行的时候不会被解释执行。<h3 id="2、功能性语句"><a href="#2、功能性语句" class="headerlink" title="2、功能性语句"></a>2、功能性语句</h3><h4 id="1）读入键盘的值read"><a href="#1）读入键盘的值read" class="headerlink" title="1）读入键盘的值read"></a>1）读入键盘的值read</h4></li><li>read从标准输入内读数据，并赋值给后面的变量。语法格式为：<ul><li>read 待赋值的变量</li></ul></li><li>一个read命令会读取一行。例如：<pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">read</span> WORD<span class="token comment" spellcheck="true">#从输入读取一个字符串值赋值给变量WORD</span><span class="token function">read</span> VAR1 VAR2 VAR3<span class="token comment" spellcheck="true">#从输入内读取三个字符串值，分别赋值给变量VAR1、VAR2和VAR3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>思考：以下两种写法的操作一样吗？<pre class="line-numbers language-bash"><code class="language-bash">写法1:  <span class="token function">read</span> VAR1 VAR2 VAR3写法2：  <span class="token function">read</span> VAR1  <span class="token function">read</span> VAR2  <span class="token function">read</span> VAR3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>示例1：用户输入一个目录，然后显示输入的目录内的文件<pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">echo</span> <span class="token string">"please input a directory"</span><span class="token function">read</span> VAR1<span class="token function">ls</span> -l <span class="token variable">$VAR1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>示例2：用户输入年、月、日，然后按指定格式输出。注意输入的数据要以空格或tab分隔，不要用回车<pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">echo</span> <span class="token string">"please input time with format: yyyy mm dd:"</span><span class="token function">read</span> VAR1 VAR2 VAR3<span class="token keyword">echo</span> <span class="token string">"today is <span class="token variable">${VAR1}</span>/<span class="token variable">${VAR2}</span>/<span class="token variable">${VAR3}</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2）算数运算命令expr"><a href="#2）算数运算命令expr" class="headerlink" title="2）算数运算命令expr"></a>2）算数运算命令expr</h4></li><li>命令expr用于变量间简单的整数四则运算，包括加、减、乘、除、取余。注意如果使用乘法需要使用*的写法来取消*（通配符）的元字符含义。</li><li>例如，在终端输入：<pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">expr</span> 12 + 5 \* 3 <span class="token comment" spellcheck="true">#注意乘号的写法</span>结果为27<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>示例：从键盘读入两个数字，分别计算这两个数字的加、减、乘、除、取余的结果并输出<pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">echo</span> <span class="token string">"please input 2 numbers:"</span><span class="token function">read</span> VAR1<span class="token function">read</span> VAR2ADD<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $VAR1 + $VAR2<span class="token variable">`</span></span> <span class="token comment" spellcheck="true">#反引号`的意思是使用后面命令的结果</span>SUB<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $VAR1 - $VAR2<span class="token variable">`</span></span>MUL<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $VAR1 \* $VAR2<span class="token variable">`</span></span>DIV<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $VAR1 / $VAR2<span class="token variable">`</span></span>MOD<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $VAR1 % $VAR2<span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>echo $VAR1 + $VAR2 = $ADD<br>echo $VAR1 - $VAR2 = $SUB<br>echo $VAR1 * $VAR2 = $MUL #注意乘号写法，表示该符号是字符而不是通配符*<br>echo $VAR1 / $VAR2 = $DIV<br>echo $VAR1 % $VAR2 = $MOD</p><pre><code>- 在示例脚本中，反引号`（位于键盘左上角）的作用是引用该命令的结果。ADD=`expr $VAR1 + $VAR2`的意思是首先执行expr命令得到计算结果，然后将该结果作为值赋值给变量ADD。#### 3）测试命令test- test命令可以测试三种对象：字符串、整数、文件属性，每种测试对象都有若干测试操作符。- 注意：在Shell编程中，0代表真，1代表假。这点和C语言相反。##### 1.测试字符串- 用法：```bash    test 字符串1 = 字符串2    若两字符串相等则结果为0，若不相等则结果为1。注意两个字符串中间的等号左右分别有空格。若没有空格则会将输入作为一个字符串。    test 字符串1 != 字符串2    若两字符串不相等则结果为0，若相等则结果为1。注意两个字符串中间的不等号左右分别有空格。若没有空格则会将输入作为一个字符串。    test -z 字符串    测试该字符串长度是否为0，若为0则结果为0，若不为0则结果为1。    test -n 字符串    测试该字符串长度是否不为0，若不为0则结果为0，若为0则结果为1。</code></pre><ul><li>例如：<pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">test</span> <span class="token string">"answer"</span> <span class="token operator">=</span> <span class="token string">"yes"</span><span class="token keyword">echo</span> <span class="token variable">$?</span> <span class="token comment" spellcheck="true">#$?表示上一个命令的退出状态</span>test命令还有一种写法：使用方括号。例如：<span class="token function">test</span> <span class="token string">"answer"</span> <span class="token operator">=</span> <span class="token string">"yes"</span> 等价于 <span class="token punctuation">[</span> <span class="token string">"answer"</span> <span class="token operator">=</span> <span class="token string">"yes"</span> <span class="token punctuation">]</span>。<span class="token function">test</span> -z <span class="token string">"hello"</span> 等价于 <span class="token punctuation">[</span> -z <span class="token string">"hello"</span> <span class="token punctuation">]</span>。注意左右方括号的两边都有空格。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>示例：从键盘读入两个字符串，判断这两个字符串是否相同。并测试字符串1是否是空<pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#写法1</span><span class="token comment" spellcheck="true">#!/bin/bash</span><span class="token keyword">echo</span> <span class="token string">"please input 2 strings:"</span><span class="token function">read</span> VAR1<span class="token function">read</span> VAR2<span class="token function">test</span> <span class="token variable">$VAR1</span> <span class="token operator">=</span> <span class="token variable">$VAR2</span><span class="token keyword">echo</span> <span class="token variable">$?</span><span class="token function">test</span> -z <span class="token variable">$VAR1</span><span class="token keyword">echo</span> <span class="token variable">$?</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>#写法2<br>#!/bin/bash<br>echo “please input 2 strings:”<br>read VAR1<br>read VAR2<br>[ $VAR1 = $VAR2 ]<br>echo $?<br>[ -z $VAR1 ]<br>echo $?</p><pre><code>##### 2.测试整数关系```bash    a -eq b    测试a与b是否相等    a -ne b    测试a与b是否不相等    a -gt b    测试a是否大于b    a -ge b    测试a是否大于等于b    a -lt b    测试a是否小于b    a -le b    测试a是否小于等于b</code></pre><ul><li>示例：从键盘读入两个数，并判断两个数字是否相等<pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token function">read</span> X Y<span class="token keyword">if</span> <span class="token function">test</span> <span class="token variable">$X</span> -eq <span class="token variable">$Y</span><span class="token keyword">then</span>  <span class="token keyword">echo</span> <span class="token string">"X equal Y"</span><span class="token keyword">else</span>  <span class="token keyword">echo</span> <span class="token string">"X not equal Y"</span><span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-测试文件属性"><a href="#3-测试文件属性" class="headerlink" title="3.测试文件属性"></a>3.测试文件属性</h5></li><li>文件测试操作表达式通常是为了测试文件信息，一般由脚本来决定是否应该备份、复制、删除。test关于文件测试的操作符很多，这里只做简单的介绍。<pre class="line-numbers language-bash"><code class="language-bash">  -e name        测试一个文件是否存在  -d name        测试name是否为一个目录  -f name        测试name是否为普通文件  -L/h name    测试name是否为符号链接  -r name        测试name文件是否存在且可读  -w name        测试name文件是否存在且可写  -x name        测试name文件是否存在且可执行  -s name        测试文件是否存在且文件长度不为0  f1 -nt f2    测试文件f1是否比文件f2更新  f1 -ot f2    测试文件f1是否比文件f2更旧<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>例如：<pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">test</span> -e /home/linux/myshell.sh<span class="token keyword">echo</span> <span class="token variable">$?</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3、结构性语句"><a href="#3、结构性语句" class="headerlink" title="3、结构性语句"></a>3、结构性语句</h3></li><li>结构性语句主要根据程序的运行状态、输入数据、变量取值、控制信号、运行时间等因素来控制程序的流程。主要包括：条件测试语句（二路分支）、多路分支语句、循环语句、控制循环语句和后台执行语句。<h4 id="1）条件测试语句"><a href="#1）条件测试语句" class="headerlink" title="1）条件测试语句"></a>1）条件测试语句</h4><h5 id="1-if……then……fi语句"><a href="#1-if……then……fi语句" class="headerlink" title="1.if……then……fi语句"></a>1.if……then……fi语句</h5></li><li>类似C语言的if语句，格式为：<pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">if</span> 表达式  <span class="token keyword">then</span> 命令<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>如果表达式为真，则执行命令表中的命令，否则退出if语句。fi表示if语句的结束，类似C语言的右括号}。fi和if必须成对出现。<h5 id="2-if……then……else……fi语句"><a href="#2-if……then……else……fi语句" class="headerlink" title="2.if……then……else……fi语句"></a>2.if……then……else……fi语句</h5></li><li>类似C语言的if-else语句，格式为：<pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">if</span> 表达式  <span class="token keyword">then</span> 命令1<span class="token keyword">else</span>  命令2<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>如果表达式为真，则执行命令表中的命令，否则执行else下命令。<h5 id="3-if……then……elif……fi语句"><a href="#3-if……then……elif……fi语句" class="headerlink" title="3.if……then……elif……fi语句"></a>3.if……then……elif……fi语句</h5></li><li>类似C语言的if-else语句多重并列使用，格式为：<pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">if</span> 表达式1  <span class="token keyword">then</span> 命令1<span class="token keyword">elif</span> 表达式2  <span class="token keyword">then</span> 命令2……<span class="token keyword">else</span>  命令n<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>如果表达式1为真，则执行命令表中的命令1，否则判断表达式2；若表达式2为真则执行命令2……若所有表达式都不为真，则执行else下命令。</li><li>示例：从键盘读入一个文件判断该文件是否存在，并判断该文件类型（普通文件/目录/未知文件）<pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">echo</span> <span class="token string">"please input a filename"</span><span class="token function">read</span> FILE<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> -e <span class="token variable">$FILE</span> <span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 对test的结果取“非”</span><span class="token keyword">then</span>  <span class="token keyword">echo</span> <span class="token string">"file not exist"</span><span class="token keyword">elif</span> <span class="token punctuation">[</span> -L <span class="token variable">$FILE</span> <span class="token punctuation">]</span><span class="token keyword">then</span>  <span class="token keyword">echo</span> <span class="token string">"file is a symbollink"</span><span class="token keyword">elif</span> <span class="token punctuation">[</span> -d <span class="token variable">$FILE</span> <span class="token punctuation">]</span><span class="token keyword">then</span>  <span class="token keyword">echo</span> <span class="token string">"file is a directory"</span><span class="token keyword">elif</span> <span class="token punctuation">[</span> -f <span class="token variable">$FILE</span> <span class="token punctuation">]</span><span class="token keyword">then</span>  <span class="token keyword">echo</span> <span class="token string">"file is a regular file"</span><span class="token keyword">else</span>  <span class="token keyword">echo</span> <span class="token string">"Unknown"</span><span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>练习：将示例程序改成使用命令行传参的形式。注意考虑命令行参数未传参的情况。<pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">if</span> <span class="token punctuation">[</span> $<span class="token comment" spellcheck="true"># -eq 0 ]</span><span class="token keyword">then</span>  <span class="token keyword">echo</span> <span class="token string">"No arguments"</span>  <span class="token keyword">exit</span> <span class="token comment" spellcheck="true">#直接退出脚本</span><span class="token keyword">fi</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> -e <span class="token variable">$1</span> <span class="token punctuation">]</span><span class="token keyword">then</span>  <span class="token keyword">echo</span> <span class="token string">"file not exist"</span><span class="token keyword">elif</span> <span class="token punctuation">[</span> -L <span class="token variable">$1</span> <span class="token punctuation">]</span><span class="token keyword">then</span>  <span class="token keyword">echo</span> <span class="token string">"file is a symbollink"</span><span class="token keyword">elif</span> <span class="token punctuation">[</span> -d <span class="token variable">$1</span> <span class="token punctuation">]</span><span class="token keyword">then</span>  <span class="token keyword">echo</span> <span class="token string">"file is a directory"</span><span class="token keyword">elif</span> <span class="token punctuation">[</span> -f <span class="token variable">$1</span> <span class="token punctuation">]</span><span class="token keyword">then</span>  <span class="token keyword">echo</span> <span class="token string">"file is a regular file"</span><span class="token keyword">else</span>  <span class="token keyword">echo</span> <span class="token string">"Unknown"</span><span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2）多路分支语句"><a href="#2）多路分支语句" class="headerlink" title="2）多路分支语句"></a>2）多路分支语句</h4></li><li>多路分支语句case可以用于实现多路分支，类似C语言内switch()语句下的case语句。格式为：<pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">case</span> 字符串变量 <span class="token keyword">in</span> <span class="token comment" spellcheck="true">#case语句只能检测字符串变量</span>  模式1<span class="token punctuation">)</span>      命令表1      <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">#退出case语句用双分号</span>  模式2<span class="token operator">|</span>模式3<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#若多个模式共用则使用|分隔</span>      命令表2      <span class="token punctuation">;</span><span class="token punctuation">;</span>  模式4<span class="token punctuation">)</span>      命令表3      <span class="token punctuation">;</span><span class="token punctuation">;</span>  ……  模式n<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#模式n常用通配符*表示所有其他模式</span>      命令表n      <span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">#最后一个模式的双分号可以省略</span>esac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>示例：从命令行传参file1或file2或file3，并输出传参结果<pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">if</span> <span class="token punctuation">[</span> $<span class="token comment" spellcheck="true"># -eq 0 ]</span><span class="token keyword">then</span>  <span class="token keyword">echo</span> <span class="token string">"No arguments"</span>  <span class="token keyword">exit</span><span class="token keyword">fi</span><span class="token keyword">case</span> <span class="token variable">$1</span> <span class="token keyword">in</span>  file1<span class="token punctuation">)</span>      <span class="token keyword">echo</span> <span class="token string">"You choose file1"</span>      <span class="token punctuation">;</span><span class="token punctuation">;</span>  file2<span class="token punctuation">)</span>      <span class="token keyword">echo</span> <span class="token string">"You choose file2"</span>      <span class="token punctuation">;</span><span class="token punctuation">;</span>  file3<span class="token operator">|</span>4<span class="token punctuation">)</span>      <span class="token keyword">echo</span> <span class="token string">"You choose file3/4"</span>      <span class="token punctuation">;</span><span class="token punctuation">;</span>  *<span class="token punctuation">)</span>      <span class="token keyword">echo</span> <span class="token string">"You MUST choose a file"</span>      <span class="token punctuation">;</span><span class="token punctuation">;</span>esac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3）循环语句"><a href="#3）循环语句" class="headerlink" title="3）循环语句"></a>3）循环语句</h4></li><li>循环语句有两类：当循环次数已经确定时，则使用for循环语句；当循环次数未定的时候，则使用while循环语句。循环语句的语句括号用do和done来确定。<h5 id="1-for循环语句"><a href="#1-for循环语句" class="headerlink" title="1.for循环语句"></a>1.for循环语句</h5></li><li>for循环语句一般用于循环次数确定的时候。格式为：<pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">for</span> 变量名 <span class="token keyword">in</span> 单词表<span class="token keyword">do</span>  命令表<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>变量依次取出单词表内的所有数值，每取出一个数值，就执行一次循环，因此for循环语句的循环次数由单词表内数值个数决定</li><li>示例：从命令行传参一个目录名，然后将该目录内所有文件复制到~/backup目录下<pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">if</span> <span class="token punctuation">[</span> $<span class="token comment" spellcheck="true"># -eq 0 ]</span><span class="token keyword">then</span>  <span class="token keyword">echo</span> <span class="token string">"No arguments"</span>  <span class="token keyword">exit</span><span class="token keyword">fi</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> -d <span class="token variable">$1</span> <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#如果传参命令行不是目录</span><span class="token keyword">then</span>  <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$1</span> not a directory"</span>  <span class="token keyword">exit</span><span class="token keyword">fi</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> -d <span class="token variable">$HOME</span>/backup <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#如果backup目录不存在则需要创建</span><span class="token keyword">then</span>  <span class="token function">mkdir</span> <span class="token variable">$HOME</span>/backup<span class="token keyword">fi</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable"><span class="token variable">`</span><span class="token function">ls</span> $HOME/backup <span class="token operator">|</span> <span class="token function">wc</span> -l<span class="token variable">`</span></span> -ne 0 <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#如果backup目录非空则需要清空</span><span class="token keyword">then</span>  <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$HOME</span>/backup is not empty, need clean……"</span>  <span class="token function">rm</span> -rf <span class="token variable">$HOME</span>/backup  <span class="token function">mkdir</span> <span class="token variable">$HOME</span>/backup  <span class="token keyword">echo</span> <span class="token string">"clean all files in <span class="token variable">$HOME</span>/backup"</span><span class="token keyword">fi</span>FLIST<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">ls</span> $1<span class="token variable">`</span></span> <span class="token comment" spellcheck="true">#获取参数</span><span class="token keyword">for</span> FILE <span class="token keyword">in</span> <span class="token variable">$FLIST</span> <span class="token comment" spellcheck="true">#让FILE变量从单词表中取数据</span><span class="token keyword">do</span>  <span class="token function">cp</span> <span class="token variable">$1</span>/<span class="token variable">$FILE</span> <span class="token variable">$HOME</span>/backup  <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$FILE</span> copied"</span><span class="token keyword">done</span><span class="token keyword">echo</span> <span class="token string">"Backup Completed"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-while循环语句"><a href="#2-while循环语句" class="headerlink" title="2.while循环语句"></a>2.while循环语句</h5></li><li>若无法事先确定循环次数，则我们不推荐使用for循环语句因为无法事先设置好单词表。此时我们可以使用while循环语句。while循环语句适用于无法事先预估循环次数的情况。while语句的格式为：<pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">while</span> 命令或表达式<span class="token keyword">do</span>  命令表<span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>while语句首先会执行后面的命令或者判断表达式的值，如果为真则执行循环，然后再次判断；若为假则退出循环。</li><li>示例：批量生成名字为”文件名+数字”的空白文件，其中文件名和数字都从命令行传参。例如输入<pre class="line-numbers language-bash"><code class="language-bash">./proj.sh nihao 5则会生成nihao1、nihao2、nihao3、nihao4、nihao5<span class="token comment" spellcheck="true">#!/bin/bash</span><span class="token keyword">if</span> <span class="token punctuation">[</span> $<span class="token comment" spellcheck="true"># -eq 0 ]</span><span class="token keyword">then</span>  <span class="token keyword">echo</span> <span class="token string">"No arguments"</span>  <span class="token keyword">exit</span><span class="token keyword">elif</span> <span class="token punctuation">[</span> $<span class="token comment" spellcheck="true"># -lt 2 ]</span><span class="token keyword">then</span>  <span class="token keyword">echo</span> <span class="token string">"Arguments are too few"</span>  <span class="token keyword">exit</span><span class="token keyword">fi</span><span class="token keyword">echo</span> <span class="token string">"files will store in directory: <span class="token variable">$HOME</span>/blankfile"</span> <span class="token comment" spellcheck="true">#提示用户生成的文件在~/blankfile内</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> -d <span class="token variable">$HOME</span>/blankfile <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#如果blankfile目录不存在则需要创建</span><span class="token keyword">then</span>  <span class="token function">mkdir</span> <span class="token variable">$HOME</span>/blankfile<span class="token keyword">fi</span><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> <span class="token variable"><span class="token variable">`</span><span class="token function">ls</span> $HOME/blankfile <span class="token operator">|</span> <span class="token function">wc</span> -l<span class="token variable">`</span></span> -eq 0 <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#如果blankfile目录非空则需要清空</span><span class="token keyword">then</span>  <span class="token function">rm</span> -rf <span class="token variable">$HOME</span>/blankfile  <span class="token function">mkdir</span> <span class="token variable">$HOME</span>/blankfile<span class="token keyword">fi</span>LOOP<span class="token operator">=</span><span class="token variable">$2</span> <span class="token comment" spellcheck="true">#循环次数</span>i<span class="token operator">=</span>1 <span class="token comment" spellcheck="true">#控制循环状态变量</span><span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> -le <span class="token variable">$LOOP</span> <span class="token punctuation">]</span><span class="token keyword">do</span>  <span class="token function">touch</span> <span class="token variable">$HOME</span>/blankfile/<span class="token variable">$1</span><span class="token variable">$i</span>  i<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $i + 1<span class="token variable">`</span></span> <span class="token comment" spellcheck="true">#等价于i++</span><span class="token keyword">done</span><span class="token keyword">echo</span> <span class="token string">"CreateBlankFiles Completed"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4）循环控制语句"><a href="#4）循环控制语句" class="headerlink" title="4）循环控制语句"></a>4）循环控制语句</h4></li><li>Shell脚本中可以使用break语句和continue语句来控制循环停止。continue语句的作用是结束本次循环进入下次循环。而break语句的作用则是跳出循环。</li><li>示例1：终端会输出10个数，在数字5处使用continue，则不会输出数字5<pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">for</span> i <span class="token keyword">in</span> 1 2 3 4 5 6 7 8 9 10<span class="token keyword">do</span>  <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> -eq 5 <span class="token punctuation">]</span>  <span class="token keyword">then</span>      <span class="token keyword">continue</span>  <span class="token keyword">fi</span>  <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$i</span>"</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>示例2：将示例1的脚本修改，将continue修改为break，则输出到数字4之后循环结束<pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">for</span> i <span class="token keyword">in</span> 1 2 3 4 5 6 7 8 9 10<span class="token keyword">do</span>  <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> -eq 5 <span class="token punctuation">]</span>  <span class="token keyword">then</span>      <span class="token keyword">break</span>  <span class="token keyword">fi</span>  <span class="token keyword">echo</span> <span class="token string">"<span class="token variable">$i</span>"</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>练习1：编写一个脚本，输出9*9乘法表<pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">for</span> i <span class="token keyword">in</span> 1 2 3 4 5 6 7 8 9<span class="token keyword">do</span>  <span class="token keyword">for</span> j <span class="token keyword">in</span> 1 2 3 4 5 6 7 8 9  <span class="token keyword">do</span>      MUL<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $i \* $j<span class="token variable">`</span></span> <span class="token comment" spellcheck="true">#注意乘号写法</span>      <span class="token keyword">echo</span> -e <span class="token string">"<span class="token variable">$j*</span><span class="token variable">$i</span>=<span class="token variable">$MUL</span>\t\c"</span>      <span class="token comment" spellcheck="true">#echo -e：开启转义字符</span>      <span class="token comment" spellcheck="true">#t：制表符  c：不换行</span>      <span class="token comment" spellcheck="true">#"echo -e"和'\c'连用可以关闭换行</span>      <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> -eq <span class="token variable">$j</span> <span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#j>i的部分无需计算</span>      <span class="token keyword">then</span>          <span class="token keyword">break</span>      <span class="token keyword">fi</span>  <span class="token keyword">done</span>  <span class="token keyword">echo</span> <span class="token string">""</span> <span class="token comment" spellcheck="true">#换行</span><span class="token keyword">done</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>练习2（选做）：编写一个脚本，测试当前子网内有多少主机可以连通（使用ping命令）<br>提示：IP地址范围为192.168.0.1<del>192.168.0.254 或 192.168.1.1</del>192.168.1.254（根据当前子网确定范围）</li><li>答案：<pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>i<span class="token operator">=</span>1COUNT<span class="token operator">=</span>0<span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token variable">$i</span> -le 254 <span class="token punctuation">]</span><span class="token keyword">do</span>  <span class="token keyword">echo</span> <span class="token string">"---------------------------"</span>  <span class="token keyword">echo</span> <span class="token string">"will ping host:<span class="token variable">$i</span>"</span>  <span class="token function">ping</span> -c 1 192.168.0.<span class="token variable">$i</span>  <span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$?</span> -eq 0 <span class="token punctuation">]</span>  <span class="token keyword">then</span>      <span class="token keyword">echo</span> <span class="token string">"host<span class="token variable">$i</span> can be connected"</span>      COUNT<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $COUNT + 1<span class="token variable">`</span></span>  <span class="token keyword">else</span>      <span class="token keyword">echo</span> <span class="token string">"host<span class="token variable">$i</span> cannot be connected"</span>  <span class="token keyword">fi</span>  i<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $i + 1<span class="token variable">`</span></span><span class="token keyword">done</span><span class="token keyword">echo</span> <span class="token string">"---------------------------"</span><span class="token keyword">echo</span> <span class="token string">"There are <span class="token variable">$COUNT</span> host can be connected"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、Shell编程函数"><a href="#四、Shell编程函数" class="headerlink" title="四、Shell编程函数"></a>四、Shell编程函数</h2></li><li>Shell脚本支持自定义函数功能。我们可以将固定功能、需要多次调用的一组命令封装在一个函数内，这样我们需要使用该功能的时候只需调用该函数即可。</li><li>函数在调用前必须先定义，且在顺序上必须放在调用函数前面。</li><li>调用函数时可以使用参数传递，函数内使用return命令将运行结果返回给调用程序。<h3 id="1、函数定义"><a href="#1、函数定义" class="headerlink" title="1、函数定义"></a>1、函数定义</h3></li><li>函数定义的格式为：<pre class="line-numbers language-bash"><code class="language-bash">格式1：function_name<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  命令  ……<span class="token punctuation">}</span>格式2：<span class="token keyword">function</span> function_name<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  命令  ……<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2、函数调用"><a href="#2、函数调用" class="headerlink" title="2、函数调用"></a>2、函数调用</h3></li><li>//实际上，在Shell编程中，函数被看成“许多Shell命令整合成一个大的Shell命令”，因此调用函数与执行一个Shell命令无本质区别<h4 id="1）无参数无返回值"><a href="#1）无参数无返回值" class="headerlink" title="1）无参数无返回值"></a>1）无参数无返回值</h4></li><li>若调用的函数无需返回值也无需传参，则像普通命令一样即可</li><li>示例：写一个打印hello world的子函数并调用<pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>hello<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">echo</span> <span class="token string">"hello world"</span><span class="token punctuation">}</span>hello <span class="token comment" spellcheck="true">#调用函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2）有参数有返回值"><a href="#2）有参数有返回值" class="headerlink" title="2）有参数有返回值"></a>2）有参数有返回值</h4></li><li>若函数需要传递参数，也需要得到返回值，则有两种调用方式：<pre class="line-numbers language-bash"><code class="language-bash">方式1：value<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span>function_name $arg1 $arg2……<span class="token variable">`</span></span>方式2：function_name <span class="token variable">$arg1</span> <span class="token variable">$arg2</span>……<span class="token keyword">echo</span> <span class="token variable">$?</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>示例：编写一个函数add，计算两个数的和，两个数使用传参的形式获得<pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span>add<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  a<span class="token operator">=</span><span class="token variable">$1</span>  b<span class="token operator">=</span><span class="token variable">$2</span>  z<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">expr</span> $a + $b<span class="token variable">`</span></span>  <span class="token keyword">echo</span> <span class="token string">"the num is <span class="token variable">$z</span>"</span><span class="token punctuation">}</span>add <span class="token variable">$1</span> <span class="token variable">$2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell简介与Shell命令</title>
      <link href="/2020/071963292.html"/>
      <url>/2020/071963292.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、Shell简介"><a href="#一、Shell简介" class="headerlink" title="一、Shell简介"></a>一、Shell简介</h2><h3 id="1、Shell简介"><a href="#1、Shell简介" class="headerlink" title="1、Shell简介"></a>1、Shell简介</h3><ul><li>在过去没有图形化界面的年代，如果我们需要与操作系统进行交互，是无法使用鼠标进行操作的，而是在终端的界面内输入相关的指令让计算机完成相应的操作。诸如早期的Unix系统、微软的DOS系统、早期Linux系统（例如较早版本的RedHat）等都是采取这种方式来和用于进行交互的。</li><li>随着时间的发展，计算机图形化程度不断提高，各式各样的图形化界面系统（代表：Windows系列）开始安装在用户的电脑上，用户在图形化界面（即桌面的环境）下，通过鼠标的移动、点击、双击、拖拽等操作就可以实现文件的移动、复制、粘贴、剪切、删除等一系列操作。这样做不仅方便用户使用系统，而且还大大增加了操作系统与用户的亲和性。</li><li>但是，使用鼠标进行系统操作的效率是十分低下的。而且在某些特殊情况下（例如图形化界面全面崩溃），使用指令似乎是唯一一种与操作系统打交道的方式。因此，Linux系统仍然保留用户通过指令与操作系统交互的方式，这种方式就是通过Shell。使用Shell指令与系统进行交互要比图形化界面更加的高效直接。<br>//Windows系统内现在仍然保留输入指令进行交互的模式，有两个软件可以实现：cmd.exe与powershell.exe</li><li>Shell，中文翻译为“壳”（相对于kernel“核”），是用于保护操作系统内核的工具。操作系统的核心kernel管理整个计算机硬件相关部分，因此这部分是需要被保护的！为了保护内核，隔离用户与内核，我们引入了Shell的概念，用户若想与操作系统的内核打交道必须通过Shell进行沟通。<h3 id="2、Shell工作流程"><a href="#2、Shell工作流程" class="headerlink" title="2、Shell工作流程"></a>2、Shell工作流程</h3></li><li>下面通过一个简单的示例来说明Shell的工作。例如，当我们需要让计算机播放音乐，我们必须需要以下几样东西：<ul><li>1.硬件：如果需要电脑播放音乐，必须有“声卡”这个设备，否则无法发声</li><li>2.管理程序：操作系统需要支持这个设备并且具有这个设备的驱动程序</li><li>3.应用程序：用户使用软件（或某些指令）让电脑发出声音</li></ul></li><li>Shell工作的流程是：<ul><li>1.用户在命令行提示符下键入命令（播放音乐），开始与Shell交互</li><li>2.Shell将用户的指令转化为内核能够理解的指令并传递给内核</li><li>3.内核做出相应的操作（调用声卡驱动程序等），直至控制相关的硬件设备（声卡发声）</li><li>4.Shell将运行结果反馈给用户（成功/失败）</li></ul></li><li>简单来说，Shell接收用户发出的指令并且传递给内核Kernel，内核再进行后续的工作。这样，用户无需也不能直接访问内核，不仅大大方便了用户使用操作系统，也隔离了用户与内核，内核被Shell保护。<br>//见附图3</li><li>Shell为用户提供了操作系统的接口，我们之前学习过的在Terminal上运行的指令/程序都是独立的程序，运行于Shell层上。因此这些指令又被称为Shell命令。若想同时自动执行多条指令，还可以将Shell命令写成Shell脚本文件，交给Shell批量执行。<h3 id="3、Shell分类"><a href="#3、Shell分类" class="headerlink" title="3、Shell分类"></a>3、Shell分类</h3></li><li>Unix系统下的Unix Shell发展至今，由不同机构、不同人员、不同目的开发出了各种不同类型的Shell程序。目前比较流行的有：<h4 id="1-Bourne-Shell（简称sh）："><a href="#1-Bourne-Shell（简称sh）：" class="headerlink" title="1.Bourne Shell（简称sh）："></a>1.Bourne Shell（简称sh）：</h4></li><li>由AT&amp;T贝尔实验室的Bourne开发，是Unix系统上的第一个Shell程序，一经问世就成为了工业标准。现在几乎所有的Unix/Linux系统都支持它。不过sh的功能较薄弱，且没有历史记录等重要功能，因此目前大多数操作系统将其作为应急Shell使用。<br>//注意：在Ubuntu中，出于执行效率的考虑，sh已经更改为dash（即sh是dash的软链接）<h4 id="2-C-Shell（简称csh）："><a href="#2-C-Shell（简称csh）：" class="headerlink" title="2.C Shell（简称csh）："></a>2.C Shell（简称csh）：</h4></li><li>由加利福尼亚大学伯克利分校研发，最初的研发目的是为了改进sh的缺点。由于其Shell脚本的风格接近C语言因此最初受到广大C语言用户喜爱。不过由于其健壮性较弱，目前的应用并不十分广泛<h4 id="3-Korn-Shell（简称ksh）："><a href="#3-Korn-Shell（简称ksh）：" class="headerlink" title="3.Korn Shell（简称ksh）："></a>3.Korn Shell（简称ksh）：</h4></li><li>由David Korn开发，最初是为了解决sh的用户交互问题以及改进csh的“怪异的”脚本编程风格。使用ksh需要许可证，因此应用并不广泛。<h4 id="4-Bourne-Again-Shell（简称bash）："><a href="#4-Bourne-Again-Shell（简称bash）：" class="headerlink" title="4.Bourne Again Shell（简称bash）："></a>4.Bourne Again Shell（简称bash）：</h4></li><li>由AT&amp;T贝尔实验室的Bourne开发，sh的增强版。随着bash的不断完善，它已经成为了最流行的shell。<h4 id="5-Debian-Almquist-Shell（简称dash）："><a href="#5-Debian-Almquist-Shell（简称dash）：" class="headerlink" title="5.Debian Almquist Shell（简称dash）："></a>5.Debian Almquist Shell（简称dash）：</h4></li><li>比bash小，只需占用较小的磁盘空间，而且需要的库更少。不过相对于bash功能也更少。</li><li>查看自己的终端的Shell类型：指令 echo $SHELL</li></ul><h2 id="二、Shell命令的格式与符号"><a href="#二、Shell命令的格式与符号" class="headerlink" title="二、Shell命令的格式与符号"></a>二、Shell命令的格式与符号</h2><h3 id="1、命令提示符"><a href="#1、命令提示符" class="headerlink" title="1、命令提示符"></a>1、命令提示符</h3><ul><li>Shell提供命令提示符表示该命令行的开始，用户在命令提示符后面输入命令，按下ENTER键表示提交命令。</li><li>命令提示符的格式为：<pre class="line-numbers language-bash"><code class="language-bash">username@hostname:direction $/<span class="token comment" spellcheck="true">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>其中：<ul><li>username：表示用户名，显示当前登陆用户的账号名</li><li>hostname：表示主机名，显示当前登陆的主机名</li><li>direction：表示路径名，显示当前所处的路径。其中根目录用/表示，用户工作目录用~表示</li><li>$或#：表示命令开始位置，普通用户为$，而超级用户为#</li></ul></li><li>练习：说出以下命令提示符所蕴含的信息：<ul><li>1.linux@Ubuntu:~/Examples $</li><li>2.root@Ubuntu:/root #</li></ul></li></ul><h3 id="2、命令格式"><a href="#2、命令格式" class="headerlink" title="2、命令格式"></a>2、命令格式</h3><ul><li>一条Shell命令包含三个要素：命令名称、可选项、参数。命令名称是必须的，而可选项和参数是可以省略的。命令格式为：<pre class="line-numbers language-bash"><code class="language-bash">Command <span class="token punctuation">[</span>Options<span class="token punctuation">]</span> Argument1……<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>其中：<ul><li>Command：表示命令名称。在Linux系统内Shell命令严格区分大小写</li><li>Options：表示可选项。用于改变命令执行的动作类型，使用”-“引导，可以同时带有几个选项</li><li>Argument：表示参数列表。指出命令所作用的目标，有些命令允许携带不止一个参数</li></ul></li><li>一条命令的三个要素需要使用空格分隔。若多个命令在一行内，则使用;将各个命令分隔。可以在输入命令名或文件名的时候按Tab键进行自动补齐，若按两下Tab键则会查看所有带有该前缀的命令或文件。</li><li>若想查看之前执行过的命令，可以按上/下箭头键查看曾执行过的命令。除此之外，还可以输入history命令查看之前输入过的命令的历史记录。history命令默认为500条（即最近执行过的500条命令）（某些Linux系统为1000条）。</li><li>练习：说出以下命令的信息：<ul><li>1.ifconfig</li><li>2.ping 192.168.1.1</li><li>3.gcc -v</li><li>4.ls -l /bin</li></ul></li></ul><h3 id="3、通配符"><a href="#3、通配符" class="headerlink" title="3、通配符"></a>3、通配符</h3><ul><li><p>当我们需要使用Shell命令处理一组文件（例如file1.txt、file2.txt、file3.txt……），按个输入文件名会十分的麻烦。这时我们可以使用通配符。</p></li><li><p>Shell命令的通配符有以下几种：</p><ul><li>*（星号）：匹配多个字符</li><li>?（问号）：匹配一个字符</li><li>[]（方括号）：匹配指定的字符</li><li>[-]（方括号内有-）：匹配指定范围的字符</li><li>[^]（方括号内有^）：匹配除了指定字符外的字符</li></ul></li><li><p>例如，现在有以下几个文件：</p><pre class="line-numbers language-bash"><code class="language-bash">  file1.txt  file2.txt  file3.txt  file123.txt  file124.txt  file134.txt  file125.txt  file5.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>则以下通配符表示：</p><pre class="line-numbers language-bash"><code class="language-bash">  file?.txt：选中了文件file1.txt、file2.txt、file3.txt、file5.txt  file1?4.txt：选中了文件file124.txt和file134.txt  file*.txt：选中了所有文件  file1*.txt：选中了文件file1.txt、file123.txt、file124.txt、file134.txt、file125.txt  file<span class="token punctuation">[</span>1-3<span class="token punctuation">]</span>.txt：选中了文件file1.txt、file2.txt、file3.txt  file<span class="token punctuation">[</span>135<span class="token punctuation">]</span>.txt：选中了文件file1.txt、file3.txt、file5.txt  file<span class="token punctuation">[</span>^135<span class="token punctuation">]</span>.txt：选中了文件file2.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、管道"><a href="#4、管道" class="headerlink" title="4、管道"></a>4、管道</h3></li><li><p>管道符号”|”可以将一系列的Shell命令连接起来，将第一个命令的输出作为第二个命令的输入，而第二个命令的输出又将作为第三个命令的输入……以此类推。管道经常与cut命令、grep命令等命令一起出现。</p></li><li><p>注意：“使用管道符号连接的两个命令”与上文的“使用;分隔多个命令”是有区别的。使用管道符号连接的命令有上下文关系（即上一个命令的输出作为下一个命令的输入），而使用;分隔多个命令并同时执行没有上下文关系。</p></li><li><p>例如，使用管道连接两个指令：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">ls</span> ~ <span class="token operator">|</span> <span class="token function">wc</span> -w<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>wc 指令可以统计当前文档的相关信息，-w表示统计有多少词，-l表示有多少行，-m表示有多少字符。在这个用管道连接的命令中，ls ~的输出结果将作为wc -w的输入，wc命令统计ls ~命令输出的结果内有多少个单词。</p></li><li><p>通过管道符号”|”可以将多个Shell命令联合使用，可以实现单个指令中无法得到的效果。</p><pre class="line-numbers language-bash"><code class="language-bash">示例1：命令 last <span class="token operator">|</span> <span class="token function">grep</span> linux<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>last命令的意思是输出最近登录系统的用户信息；grep命令的意思是输出含有某关键字的行。该命令首先使用last命令获得登录用户信息，再通过grep命令查找有“linux”字样的记录。</p></li><li><p>grep指令可以解析输出文字并输出所有含有关键字的行。若想反向选择输出，则可以使用-v来指定不输出含有该关键字的行。例如：</p><pre class="line-numbers language-bash"><code class="language-bash">last <span class="token operator">|</span> <span class="token function">grep</span> -v wtmp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>则不会输出带有关键字wtmp的行</p><pre class="line-numbers language-bash"><code class="language-bash">示例2：命令 <span class="token function">cat</span> hello.c <span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">printf</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>cat命令的意思是在终端打印指定文档。该命令首先将hello.c的内容输出，然后使用grep命令查找所有带有“printf”字样的行。</p><pre class="line-numbers language-bash"><code class="language-bash">示例3：命令 <span class="token keyword">echo</span> <span class="token variable">$PATH</span> <span class="token operator">|</span> <span class="token function">cut</span> -d <span class="token string">':'</span> -f 5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>echo命令的意思是在终端输出指定字符串，$PATH表示Shell的PATH变量（指示Shell寻找命令的路径）；cut命令可以以某个字符为分隔符剪切一个字符串成为若干个片段，其中-d后面指定了分隔符，-f后面指定了输出分隔后的第几个片段。该命令首先将$PATH变量输出，然后使用cut命令将这个变量值分隔为若干个小片段，然后输出第5段。</p></li><li><p>可以在-f后面跟若干个不同的数值用来输出指定的几个片段，数值间用逗号分隔；也可使用m-n来指定输出从m到n的片段，若未指定n的值则表示输出从m开始到结尾的所有片段。</p></li><li><p>练习：使用管道符号”|”连接合适的Shell命令，完成以下练习：</p><ul><li>1.以’/‘作为分隔符，分隔echo $HOME命令，并输出第2个及以后的片段</li><li>2.统计/etc/bash.bashrc这个文件内有多少个单词</li><li>3.输出某个.c文件内所有带有”printf”单词的行</li><li>4.使用ifconfig命令与grep命令，找出该计算机的ip地址（ip地址总会以192开头）</li><li>5.使用last命令、grep命令和wc命令，统计最近有几个用户曾登陆该计算机</li></ul></li><li><p>答案：</p><ul><li>1.echo $HOME | cut -d ‘/‘ -f 2-</li><li>2.cat /etc/bash.bashrc | wc -w</li><li>3.cat hello.c | grep printf</li><li>4.ifconfig | grep 192</li><li>5.last | grep [a-zA-Z] | grep -v wtmp | wc -l</li></ul></li></ul><h3 id="5、输入输出重定向"><a href="#5、输入输出重定向" class="headerlink" title="5、输入输出重定向"></a>5、输入输出重定向</h3><ul><li><p>在Linux中默认的输入是键盘，默认的输出是终端。若想改变输入/输出的目标，则需要使用输入输出重定向符号来改变输入输出目标重定向到新的目标。</p></li><li><p>输入输出重定向符号有以下几种：</p><pre class="line-numbers language-bash"><code class="language-bash">  <span class="token operator">></span> 文件名 或 1<span class="token operator">></span> 文件名：将该文件作为重定向的输出源，即将输出结果显示在该文件内。（采用w（新建）模式）  <span class="token operator">>></span> 文件名：将该文件作为重定向的输出源，即将输出结果显示在该文件内。（采用a（追加）模式）  <span class="token operator">&lt;</span> 文件名：将该文件作为重定向的输入源  2<span class="token operator">></span> 文件名 或 <span class="token operator">&amp;</span><span class="token operator">></span> 文件名：将该文件作为重定向的输出错误源，即命令产生的错误信息会重定向到该文件中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>示例1：ls -l &gt; hello.txt 将ls -l的结果输出到文件hello.txt中</p></li><li><p>示例2：wc -l &lt; hello.txt 将hello.txt作为输入内容传输给wc命令</p></li><li><p>练习：不使用cp命令，复制一个.c文件的内容</p><ul><li>答案：cat hello.c &gt; hello.txt 将hello.c的内容输出到文件hello.txt中</li></ul></li></ul><h2 id="三、常用Shell命令"><a href="#三、常用Shell命令" class="headerlink" title="三、常用Shell命令"></a>三、常用Shell命令</h2><ul><li>1、ls：列出当前目录下文件<ul><li>-l：使用长格式显示详细属性</li></ul></li><li>2、cat：将文本文件输出到终端</li><li>3、less/more：分屏显示文件</li><li>4、rm：删除文件<ul><li>-r：删除目录及目录内文件</li></ul></li><li>5、cp：复制文件</li><li>6、mv：移动文件 或 重命名文件</li><li>7、mkdir：创建目录<ul><li>-p：多级创建</li></ul></li><li>8、rmdir：删除空目录</li><li>9、cd：更改目录</li><li>10、grep：显示含有关键字的行<ul><li>-v：反向选择（即不显示含有关键字的行）</li></ul></li><li>11、head：显示文件开头</li><li>12、tail：显示文件结尾</li><li>13、sort：将文件内容排序后输出<ul><li>-r：反序</li><li>-R：随机顺序</li></ul></li><li>14、uniq：省略文件中相邻的重复行<ul><li>-c：统计重复行的出现次数</li><li>-d：报告出现的重复行</li><li>-u：只会输出未重复的行</li></ul></li><li>15、diff：比较两个文件。若两个都为文本文件则会输出两个文件不同的文本，若无差异则不会输出；若两个都为目录则会输出两个目录内文件的差异。diff命令通常用于查看两个补丁文件的异同从而进行软件的版本控制工作。<ul><li>-w：忽略空格与制表符，将所有的空格视为一致。例如if(a == b)和if(a==b)将会视为一致。</li></ul></li><li>16、file：判定文件类型</li><li>17、echo：显示文本<ul><li>-n：输出文字不换行</li><li>-e：开启转义字符（可以使用\t（水平制表符）、\v（垂直制表符）、\n（换行符）等转义字符）</li><li>注意：若想让echo原样输出，则需要加上引号，否则echo会将每个用空格隔开的单词作为一个字符串，各字符串用空格分隔。例如：</li><li>1.echo “Hello      World”    将间距较大的空格原样输出，输出Hello      World</li><li>2.echo Hello      World    认为输入的是两个单词，每个字符串用一个空格分隔，输出Hello World</li></ul></li><li>18、date：显示/设置系统时间与日期<ul><li>-d 字符串：显示指定字符串的时间而不是“现在时间”</li><li>-R：以RFC2822格式输出</li><li>-s 时间：设定指定的时间。通常我们使用”sudo date -s 时间”命令来设置当前系统时间</li><li>-u：输出协调世界时（Coordinated Universal Time，又称世界标准时间，简称UTC。中国大陆地区（上海）、中国香港、中国澳门、中国台湾与UTC时差为8小时，即中国大陆地区（上海）、中国香港、中国澳门、中国台湾记为UTC+8）</li></ul></li><li>19、tar：归档文件/展开归档文件</li><li>20、whereis：查看命令存储位置/源码存储位置/帮助文档存储位置<ul><li>-b：只显示命令存储位置</li><li>-s：只显示源码存储位置</li><li>-m：只显示帮助文档存储位置</li></ul></li><li>21、which：定位某个命令的存储位置</li><li>22、ps：报告当前进程信息<ul><li>-A或-e：报告所有进程</li><li>a：显示现行终端下的所有程序（包括其他用户）</li><li>x：不区分终端，显示所有程序</li><li>u：使用用户为主的格式</li><li>f：用树形结构显示</li><li>常用ps axu来显示所有进程信息，再配合grep和管道去查看特定进程信息。</li><li>使用ps显示进程信息，显示出的信息的表头信息分别为：<ul><li>USER：进程所有者</li><li>PID：进程id号</li><li>PPID：父进程id号</li><li>PGID：进程组id号</li><li>SID：会话id号</li><li>TTY：进程相关的终端</li><li>CPU：占用CPU百分比</li><li>MEM：占用内存百分比</li><li>STAT：进程状态。有以下几种形式：<ul><li>S：休眠</li><li>D：无法中断的休眠（例如某些负责IO的进程）</li><li>R：运行中</li><li>T：停止</li><li>Z：僵死</li><li>&lt;：优先级高</li><li>N：优先级低</li><li>s：进程领导者，在该进程下有子进程</li><li>l：多进程的</li><li>+：后台进程组</li></ul></li><li>TIME：进程消耗CPU的时间</li><li>COMMAND：命令行参数</li></ul></li></ul></li><li>23、top：实时监视当前进程<ul><li>-p PID：监视指定进程号的进程。可以有多个PID<br>与ps命令不同，top命令显示的进程信息会进行实时刷新，通常通过top命令得出当前的CPU和内存负载情况。</li></ul></li><li>24、df：报告文件系统占用空间情况<ul><li>-a：显示全部文件系统</li><li>-h：方便阅读模式（即转换为1G=1024M，1M=1024K的模式）</li><li>-i：显示inode信息</li><li>-t 文件系统类型：只显示选定文件系统</li></ul></li><li>25、du：显示磁盘空间的使用情况<ul><li>-h：方便阅读模式（即转换为1G=1024M，1M=1024K的模式）</li><li>-a：显示目录以及目录下其他子目录和子文件占用磁盘空间大小</li><li>-s：只显示目录，不显示目录下其他子目录和子文件占用磁盘空间大小</li></ul></li><li>26、kill：杀死指定进程（需指定进程ID）<ul><li>-9：强行杀死</li><li>-HUP 进程名：改为指定进程名</li><li>kill命令经常与ps命令一起使用，用于杀死已经死锁或需要终止的进程。</li></ul></li><li>27、chmod：改变文件的文件权限<ul><li>用法：chmod 文件权限码 文件名。例如chmod 0775 hello.c</li></ul></li><li>28、chown：改变文件所有者或文件组<ul><li>用法：chown 用户名:组名 文件名。例如chown root:root hello.c</li></ul></li><li>29、pwd：显示当前的绝对路径</li><li>30、ln：创建文件的链接<ul><li>-s：创建符号链接（软连接）。若此选项缺省则认为创建的是硬链接。</li></ul></li><li>31、who：显示目前登陆系统的用户信息<ul><li>who am i 或 -m：显示当前用户名</li><li>-H：显示表头信息</li></ul></li><li>32、man；获取命令或程序的说明文档<ul><li>对于同一个命令或程序，man命令可能拥有多个章节。这时我们可以在man命令后面添加对应的数字信息来查看更多信息。例如，输入man 1 printf和man 3 printf可以得到printf在不同章节的说明文档。</li><li>1：Shell标准命令说明</li><li>2：系统调用说明</li><li>3：常用库函数说明（一般为C库函数）</li><li>4：特殊文件说明（一般为/dev下的设备）</li><li>5：文件格式说明（例如/etc/passwd）</li><li>6：游戏</li><li>7：杂项</li><li>8：管理员指令</li><li>9：Linux特定的内核文档</li><li>在帮助文档内按q退出</li><li>-k：按关键字搜索说明文档。例如man -k “list directory”。注意list directory有无引号的区别。</li></ul></li><li>33、shutdown：关闭/重启系统。一般需要超级用户权限。shutdown命令的一般用法是：<ul><li>shutdown [可选项] [时间格式] [提示信息]</li><li>-r：重启</li><li>-h：关机</li><li>-k：不会真正关机，只是提示登录用户</li><li>-c：取消一个正在执行的shutdown命令</li><li>时间格式一般是’+’和数字，表示几分钟后。若想“立即”则可以指定为now</li></ul></li><li>34、passwd：修改密码。出于安全性的考虑，Linux系统的密码是“不回显”的（即输入时不会显示位的个数）。root用户可以修改所有用户的密码，而普通用户只能修改自己的密码。<ul><li>用法：passwd 用户名。修改某个用户名的密码</li></ul></li><li>35、su：临时改变当前用户的身份。若未指定用户名则默认将当前用户改变为root用户。当需要退出该身份的时候，可以输入exit退出root用户。</li><li>36、clear：清空终端</li></ul><h2 id="四、Linux用户管理"><a href="#四、Linux用户管理" class="headerlink" title="四、Linux用户管理"></a>四、Linux用户管理</h2><ul><li>Linux是一个多用户的操作系统，因此Linux系统的一个重要的工作就是对每个用户以及用户所有文件进行管理。<h3 id="1、用户信息管理文件"><a href="#1、用户信息管理文件" class="headerlink" title="1、用户信息管理文件"></a>1、用户信息管理文件</h3></li><li>每一个用户都具有以下的属性：<ul><li>-用户名</li><li>-密码</li><li>-用户的ID（UID）</li><li>-用户主目录位置（HOME，即~的绝对路径）</li><li>-用户的Shell</li></ul></li><li>在Linux内，用户信息主要由/etc/passwd和/etc/group两个文件管理。</li><li>/etc/passwd文件用来存储操作系统能够识别用户的信息清单。每一个用户都会在这个文件内有一条注册信息，当用户登陆的时候，系统从该文件中读取用户的UID和密码并进行验证。<br>```bash<br>在/etc/passwd文件内存储的用户信息有：<br>  -登录名<br>  -密码（不过是加密字符，不予显示）<br>  -UID<br>  -默认的组ID（GID）<br>  -个人信息<br>  -主目录所在路径<br>  -登陆的Shell</li><li>每个信息使用冒号:分隔。例如：<br>linux:x:1000:1000:linux,,,:/home/linux:/bin/bash<br>  登录名：linux<br>  密码：x（加密字符，不予显示）<br>  UID：1000<br>  GID：1000<br>  个人信息：linux<br>  主目录所在路径：/home/linux<br>  登陆的Shell：/bin/bash<br>/etc/group文件用来存储系统内用户组的信息，包括组名、GID、组成员列表<br>  -组名<br>  -密码（不过是加密字符，不予显示）<br>  -GID<br>  -成员列表，每个成员用逗号隔开<br>```<h3 id="2、在系统内创建一个新用户"><a href="#2、在系统内创建一个新用户" class="headerlink" title="2、在系统内创建一个新用户"></a>2、在系统内创建一个新用户</h3><h4 id="1）添加新用户"><a href="#1）添加新用户" class="headerlink" title="1）添加新用户"></a>1）添加新用户</h4></li><li>使用命令adduser来添加一个新用户。注意adduser命令只能root用户使用，因此需要切换成root用户来执行以下操作。<ul><li>adduser liyuge</li></ul></li><li>在执行命令后，Linux系统会提示用户输入密码、全名、电话、信息等，除了密码必须输入，其他信息可以按ENTER跳过输入。</li><li>adduser命令会自动为用户执行以下操作：<pre class="line-numbers language-bash"><code class="language-bash">root@ubuntu:~<span class="token comment" spellcheck="true"># adduser liyuge</span>  Adding user `liyuge<span class="token string">' ...  Adding new group `liyuge'</span> <span class="token punctuation">(</span>1001<span class="token punctuation">)</span> <span class="token punctuation">..</span>.  Adding new user `liyuge<span class="token string">' (1001) with group `liyuge'</span> <span class="token punctuation">..</span>.  Creating home directory `/home/liyuge<span class="token string">' ...  Copying files from `/etc/skel'</span> <span class="token punctuation">..</span>.  Enter new UNIX password: <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>分别为：<ul><li>1.添加新用户，用户名liyuge</li><li>2.创建新的用户组liyuge</li><li>3.将liyuge添加到组liyuge内</li><li>4.创建工作目录/home/liyuge</li><li>5.从/etc/skel内复制文件</li><li>6.等待用户输入密码</li></ul></li><li>其中第五步的/etc/skel目录内存放的是一个普通用户的配置文件，常见的有.bashrc、.inputrc、.vimrc等配置文件。</li><li>在执行完adduser命令后，我们可以分别查看/etc/passwd文件和/etc/group文件的存储信息。</li><li>若想修改密码，可以使用passwd命令。</li><li>创建新用户成功后，可以使用su命令切换成新用户。<h4 id="2）修改新用户属性"><a href="#2）修改新用户属性" class="headerlink" title="2）修改新用户属性"></a>2）修改新用户属性</h4></li><li>若想修改新用户的属性，则可以使用usermod命令。<ul><li>usermod [可选项] 用户名</li><li>-d 目录名：更改该用户的工作目录地址。若后面有-m则表示旧目录会迁移至新目录，若新目录不存在则会创建。</li><li>-e 日期：指定该用户的账号有效截止日期，时间格式为MM/DD/YY。</li><li>-G 组名1,组名2……：指定该用户是以下组的成员（即加入这些组内），组名间用逗号分隔</li><li>-l 名称：更改该用户的登录名</li><li>-u 数值：更改该用户的UID，新指定的UID必须是一个唯一的值（即不能与已有UID同名）</li><li>-s shell目录：更改该用户默认shell，若后面的值缺省则会指定为系统默认的shell</li></ul></li><li>注意：usermod命令无法更改正在线上的用户</li><li>例如将新用户添加进linux的组中：<ul><li>usermod liyuge -G linux</li></ul></li><li>这样我们就将用户linux和liyuge都划入linux组中。用户liyuge可以根据用户linux的组权限来访问文件。<h4 id="3）删除用户"><a href="#3）删除用户" class="headerlink" title="3）删除用户"></a>3）删除用户</h4></li><li>使用deluser来删除一个用户</li><li>使用delgroup来删除一个用户组<pre class="line-numbers language-bash"><code class="language-bash">/****************************终端配置文件*************************/Shell在运行时需要一定的配置文件才能正确有效的执行。Shell的配置文件主要有profile文件和bashrc文件。1）/etc/profile：此文件为系统的每个用户设置环境信息，当用户第一次登录时，该文件被执行2）~/.profile：此文件为当前用户设置的自定义环境信息3）/etc/bash.bashrc：此文件为系统的每个用户配置bash Shell的相关信息4）~/.bashrc：此文件为当前用户配置自定义的bash Shell的相关信息/****************************终端配置文件end**********************/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCC、GDB与Make工程管理器</title>
      <link href="/2020/071822717.html"/>
      <url>/2020/071822717.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、GNU与GNU工具简介"><a href="#一、GNU与GNU工具简介" class="headerlink" title="一、GNU与GNU工具简介"></a>一、GNU与GNU工具简介</h2><ul><li>GNU的英文全称是”GNU is Not Unix”，又称革奴计划，是由Richard Stallman在1983年9月27日公开发起的。它的目标是创建一套完全自由的操作系统。由于GNU在英文中原意为非洲牛羚，因此GNU计划的图标就是一个牛羚。</li><li>GNU提供各种程序开发工具给编程人员使用。其中包括（但不限于）：<ul><li>编译工具：将源代码翻译成目标代码的工具。例如GCC、G++等</li><li>调试工具：对执行的程序进行断点、单步、单次等调试。例如GDB等</li><li>软件管理工具：协助开发人员管理大型程序项目内的源码、资源、文档等工具，例如Make、CVS、Subvision等</li><li>其他工具：例如链接生成可执行文件的链接器、文字格式转换的转换工具等。</li></ul></li><li>在GNU提供的众多工具内，常用的有GCC、GDB、Make工程管理器这三种。这三种工具也是我们经常使用的在Linux系统内管理C语言程序的工具。<pre><code>/*************一些GNU资源网站*****************/http://www.gnu.org/http://gcc.gnu.org/http://www.kernel.org/http://www.linux.org/http://www.linuxdevices.com/http://sourceforge.net/index.php/*************一些GNU资源网站end**************/</code></pre><h2 id="二、GCC"><a href="#二、GCC" class="headerlink" title="二、GCC"></a>二、GCC</h2><h3 id="1、GCC简介"><a href="#1、GCC简介" class="headerlink" title="1、GCC简介"></a>1、GCC简介</h3></li><li>GCC全程GNU C Compiler，是GNU提供的一款开源免费的C语言编译器，支持编译C、C++、Objective-C、Fortran、Pascal等多种语言。</li><li>GCC可以在多种平台上编译源代码（不过不同平台需要的GCC版本不同），而且GCC具有强大的代码优化能力，其编译效率比其他编译器快20%以上，因此是嵌入式开发领域最受人喜爱的编译器，有些程序开发者甚至称其为“最好用的C语言编译器”。</li><li>GCC主要由分析器、汇编器、链接器、标准C库等组件构成。<h3 id="2、GCC支持的文件格式"><a href="#2、GCC支持的文件格式" class="headerlink" title="2、GCC支持的文件格式"></a>2、GCC支持的文件格式</h3></li><li>使用GCC编译器需要特殊的文件名后缀，若文件名无后缀或后缀非法则GCC编译器无法识别。GCC支持的文件类型和后缀常见的有：<ul><li>.c：C语言源代码</li><li>.cc：C++语言源代码</li><li>.m：Objective-C语言源代码</li><li>.i：预处理过的C语言程序</li><li>.ii：预处理过的C++语言程序</li><li>.s：汇编语言程序</li><li>.h：预处理文件（头文件）</li><li>.o：目标文件</li><li>.a/.so：编译后的库文件<h3 id="3、GCC编译C语言文件的过程"><a href="#3、GCC编译C语言文件的过程" class="headerlink" title="3、GCC编译C语言文件的过程"></a>3、GCC编译C语言文件的过程</h3></li></ul></li><li>GCC将C语言代码编译成最终的可执行程序需要四个步骤：预处理、编译、汇编、链接。<h4 id="1-预处理（Pre-Processing）："><a href="#1-预处理（Pre-Processing）：" class="headerlink" title="1.预处理（Pre-Processing）："></a>1.预处理（Pre-Processing）：</h4></li><li>主要执行删除程序内注释，加载头文件，替换宏，条件编译等工作</li><li>需要文件：.c文件</li><li>生成产物：预处理文件（以.i结尾）</li><li>使用方法：gcc hello.c -E -o hello.i<h4 id="2-编译（Compiling）："><a href="#2-编译（Compiling）：" class="headerlink" title="2.编译（Compiling）："></a>2.编译（Compiling）：</h4></li><li>使用编译器进行C语言的语法检查，如果有语法错误，报错，并结束编译过程;如果没有语法错误，把C的源程序转变为汇编代码</li><li>需要文件：.i文件</li><li>生成产物：汇编文件（以.s结尾）</li><li>使用方法：gcc hello.i -S -o hello.s<h4 id="3-汇编（Assembling）："><a href="#3-汇编（Assembling）：" class="headerlink" title="3.汇编（Assembling）："></a>3.汇编（Assembling）：</h4></li><li>把汇编源文件通过汇编器生成目标文件（二进制机器语言）</li><li>需要文件：.s文件</li><li>生成产物：机器码（或称为“目标代码”，以.o结尾）</li><li>使用方法：gcc hello.s -c -o hello.o<h4 id="4-链接（Linking）："><a href="#4-链接（Linking）：" class="headerlink" title="4.链接（Linking）："></a>4.链接（Linking）：</h4></li><li>把目标文件执行所依赖的所有二进制的其他目标文件及C的库文件都整合成一个可执行文件的过程</li><li>需要文件：.o文件及各种动态库或静态库</li><li>生成产物：可执行程序</li><li>使用方法：gcc hello.o -o hello    <h3 id="4、代码优化"><a href="#4、代码优化" class="headerlink" title="4、代码优化"></a>4、代码优化</h3></li><li>代码优化指的是编译器通过分析代码找出其中不是最优的部分，然后对代码重新组合从而改善程序的执行性能。GCC的代码优化功能十分强大。GCC提供的代码优化有4个等级，分别是：<ul><li>-O0：无优化（默认）</li><li>-O1：1级优化。使用该选项能减少目标文件大小及执行时间并且不会让编译时间明显增加。在编译较大型的程序时常用。</li><li>-O2：2级优化。包含1级优化功能并进一步优化生成的目标代码（例如使用更优化的指令调度等），不过会让编译时间增加。<br>//2级优化是大多数程序员最常用的代码优化等级，因为它在编译时间与优化长度上取得了一个平衡点。</li><li>-O3：3级优化。包含2级优化功能并进一步优化生成的目标代码（例如使用特殊的处理器等），不过会让编译时间大幅度增加。</li></ul></li><li>虽然代码优化选项可以加快生成的可执行程序的运行速度，不过对于需要调试的代码而言是一个巨大的挑战。因为经过优化的代码与原始代码很可能有诸多不同，使用调试工具时非常有可能跳转到意外的地方从而使调试崩溃。而且，使用越高等级的代码优化，编译时间也会越长。因此代码优化功能要适度使用，也要认清并非所有代码都需要代码优化功能。</li><li>示例：以下程序在循环部分有明显的不合理运算会拖慢程序的执行速度，分别使用无优化和2级优化编译该代码并查看执行时间的不同<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">double</span> counter<span class="token punctuation">;</span>  <span class="token keyword">double</span> result<span class="token punctuation">;</span>  <span class="token keyword">double</span> temp<span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> counter <span class="token operator">&lt;</span> <span class="token number">2000.0</span><span class="token operator">*</span><span class="token number">2000.0</span><span class="token operator">*</span><span class="token number">2000.0</span><span class="token operator">/</span><span class="token number">20.0</span><span class="token operator">+</span><span class="token number">2020</span><span class="token punctuation">;</span> counter <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//注意for()的表达式2和表达式3</span>  <span class="token punctuation">{</span>      temp <span class="token operator">=</span> counter <span class="token operator">/</span> <span class="token number">1979</span><span class="token punctuation">;</span>      result <span class="token operator">=</span> counter<span class="token punctuation">;</span>  <span class="token punctuation">}</span>     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Result is %lf\n"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>关闭优化：gcc test.c -O0 -o test1</li><li>使用2级优化：gcc test.c -O2 -o test2</li><li>在执行可执行程序的时候，使用系统的time命令可以查看该程序的运行时间</li><li>time ./test1</li><li>time ./test2</li><li>可以发现test2的执行时间明显快于test1。</li></ul><h2 id="三、GDB"><a href="#三、GDB" class="headerlink" title="三、GDB"></a>三、GDB</h2><h3 id="1、GDB简介"><a href="#1、GDB简介" class="headerlink" title="1、GDB简介"></a>1、GDB简介</h3><ul><li>GDB（GNU symbolic debugger）是GNU的一款代码调试工具，它可以实现查看代码内部结构、打印变量值、设置断点、单步调试等功能。熟练使用GDB工具能够提高我们编程除错的水平。</li><li>注意：若使用gdb调试代码，则在编译阶段需要添加-g选项。gdb只能调试生成的可执行程序，而不能调试.c源代码文件</li><li>GDB有众多的命令，包含显示代码、设置断点、控制执行、查看栈区、输出变量等功能。<br>//GDB相关命令参数见附表<h3 id="2、GDB使用流程"><a href="#2、GDB使用流程" class="headerlink" title="2、GDB使用流程"></a>2、GDB使用流程</h3></li><li>示例代码：<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> i<span class="token punctuation">;</span>  <span class="token keyword">int</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      sum<span class="token operator">+</span><span class="token operator">=</span>i<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"The sum is %d\n"</span><span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="1）编译"><a href="#1）编译" class="headerlink" title="1）编译"></a>1）编译</h4><ul><li>在编译阶段，一定要加上可选项-g（表示开启调试），否则无法使用GDB调试代码</li><li>gcc test.c -g -o test</li><li>然后就可以启动GDB调试代码了。注意GDB只能调试可执行程序，不能调试C语言源代码文件</li><li>gdb test<h4 id="2）查看GDB调试的文件"><a href="#2）查看GDB调试的文件" class="headerlink" title="2）查看GDB调试的文件"></a>2）查看GDB调试的文件</h4></li><li>我们可以使用list命令查看载入的文件。默认情况下list显示10行，可以使用set listsize来设置显示行数<h4 id="3）设置断点"><a href="#3）设置断点" class="headerlink" title="3）设置断点"></a>3）设置断点</h4></li><li>我们可以使用break命令设置断点。当程序运行至断点处会停下。设置断点的方式有：<ul><li>break function：在指定函数定义处设置断点</li><li>break linenum：在指定行处设置断点<h4 id="4）查看断点"><a href="#4）查看断点" class="headerlink" title="4）查看断点"></a>4）查看断点</h4></li></ul></li><li>设置断点后可以使用info breakpoints命令查看断点信息<h4 id="5）运行"><a href="#5）运行" class="headerlink" title="5）运行"></a>5）运行</h4></li><li>使用run命令让代码从头运行，当代码运行至断点处时会停下</li><li>使用continue命令让代码继续运行至下一个断点处<h4 id="6）查看变量值"><a href="#6）查看变量值" class="headerlink" title="6）查看变量值"></a>6）查看变量值</h4></li><li>我们可以使用p+变量名来打印变量信息<h4 id="7）恢复运行"><a href="#7）恢复运行" class="headerlink" title="7）恢复运行"></a>7）恢复运行</h4></li><li>可以使用finish命令让程序运行完成</li><li>可以使用clear命令清除所有断点，也可以用clear+断点号清除指定断点</li></ul><h2 id="四、Make工程管理器"><a href="#四、Make工程管理器" class="headerlink" title="四、Make工程管理器"></a>四、Make工程管理器</h2><ul><li>Make工程管理器是一个用来管理多文件的文件转化管理工具。它可以通过依赖关系将某种文件转化为目标文件target。大多数情况下，Make工程管理器用于调用GCC编译器将源代码编译成目标代码，再将目标代码整合生成可执行程序。使用Make工程管理器的时候一定要掌握两个概念：目标（target）和依赖关系（dependency）。目标就是要生成的文件，依赖关系就是生成目标文件需要的文件。</li><li>Make工程管理器使用名为”makefile”的脚本文件来确定依赖关系并生成目标文件。因此我们必须熟练掌握makefile的写法才能正确使用Make工程管理器。</li><li>Make工程管理器对参与编译的代码的管理原则是“若未改动则不参与”，若makefile发现这次参与编译的某些文件在上次编译后一直未被修改，则本次编译会自动忽略这些文件，从而减少编译时间。</li><li>也就是说，Make工程管理器是通过文件的时间戳来识别文件是否应该参与编译的。<h3 id="1、makefile基本规则"><a href="#1、makefile基本规则" class="headerlink" title="1、makefile基本规则"></a>1、makefile基本规则</h3></li><li>虽然makefile不是一门专门的编程语言，但是我们也需要使用特定的格式来编写makefile文件。<pre class="line-numbers language-bash"><code class="language-bash">示例1：使用makefile输出helloworld首先使用vim创建一个文本文件，命名为makefile。内容为：all:  <span class="token keyword">echo</span> <span class="token string">"hello world"</span>注意：在makefile内，每个命令行前面必须以<span class="token string">"Tab键"</span>开头，否则会出现使用错误：missing separator<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>在这个简单的makefile中，”all”就是我们的生成目标（target），每个生成目标都需要放在冒号之前。”all:”下面的命令代表生成目标需要的命令，我们也称之为“规则”，在这个示例内我们生成目标只有一个规则，实际上可以有多条规则。在这个简单的makefile中，我们规定了生成的目标为”all”，而生成该目标需要一个echo命令。</li><li>若我们想运行这个makefile查看运行效果，我们无需像Shell脚本一样给该makefile添加执行权限，而是使用make命令调用Make工程管理器，Make工程管理器会自动按照makefile的内容来执行。</li><li>使用该makefile：make 或 make all</li><li>在调用makefile的时候，终端会先输出一遍生成目标的规则，然后输出生成的目标。若我们不想看到输出的规则，则我们可以在规则前面加上‘@’：<pre class="line-numbers language-bash"><code class="language-bash">all:  @echo <span class="token string">"hello world"</span>这样就不会输出规则了。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>当然，一个makefile不仅仅只能生成一个目标，一个makefile是可以支持生成多个目标的，只不过我们需要调用相应的make命令来告诉Make工程管理器需要生成哪个目标。<pre class="line-numbers language-c"><code class="language-c">示例<span class="token number">2</span>：在示例<span class="token number">1</span>的基础上添加一个新的目标all<span class="token punctuation">:</span>  @echo <span class="token string">"hello world"</span>test<span class="token punctuation">:</span>  @echo <span class="token string">"nihao farsight"</span>在示例<span class="token number">1</span>的基础上添加了一个新的目标<span class="token string">"test"</span>，此时我们可以的makefile文件就可以生成两个目标了。生成目标all：make 或 make all生成目标test：make test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>我们在运行示例2的makefile时会发现，若我们执行make，则只会输出目标all。这是由makefile的逻辑决定的，在未指定make目标的情况下（即缺省目标的情况下），makefile默认只生成第一个目标。</li><li>那么能不能在make的时候也生成test目标呢？当然可以，我们可以这样修改makefile：<pre class="line-numbers language-c"><code class="language-c">示例<span class="token number">3</span>：修改示例<span class="token number">2</span>，使得make也可以生成test目标all<span class="token punctuation">:</span>test  @echo <span class="token string">"hello world"</span>test<span class="token punctuation">:</span>  @echo <span class="token string">"nihao farsight"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>在示例3中，我们在”all:”后面添加了一个新的字段”test”，这个字段就是“依赖关系”。”all:test”这个字段的意思就是：生成目标all需要依赖目标test。这样makefile在生成all之前会先去生成目标test，在生成目标test后才会去生成目标all。一个目标可以有多个依赖关系，若一个目标有多个依赖关系，则所有的依赖关系都写在冒号之后，用空格分隔。</li><li>因此编写一个makefile最重要的就是要弄懂需要生成的目标，以及生成这些目标需要的依赖关系。“目标”与“依赖”是使用makefile的重点，我们需要重点关注。</li></ul><h3 id="2、使用makefile编译C语言文件"><a href="#2、使用makefile编译C语言文件" class="headerlink" title="2、使用makefile编译C语言文件"></a>2、使用makefile编译C语言文件</h3><ul><li>有了以上对makefile的基本认识，我们来试图编写一个用于编译C语言文件的makefile。</li><li>首先需要准备代码，注意头文件hello.h的格式：<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//文件hello.h</span><span class="token macro property">#<span class="token directive keyword">ifndef</span> __MY_H_INCLUDE__</span><span class="token macro property">#<span class="token directive keyword">define</span> __MY_H_INCLUDE__</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>#endif</p><p>//文件hello.c<br>#include”hello.h”<br>int main()<br>{<br>    printf(“hello world”);<br>}</p><pre><code>- 然后编写一个makefile：```c示例4：编译hello.c的makefile文件all:hello.h hello.c    gcc hello.c -o hello</code></pre><ul><li>此时我们运行命令make，就可以编译文件hello.c和hello.h生成文件hello。</li><li>但是，几个简单的文件使用makefile实在是太浪费了。现在我们准备多个C语言源文件，然后使用makefile对这几个C语言源文件进行编译：<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//文件my.h</span><span class="token macro property">#<span class="token directive keyword">ifndef</span> __MY_H_INCLUDE__</span><span class="token macro property">#<span class="token directive keyword">define</span> __MY_H_INCLUDE__</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">simple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>#endif<br>//文件foo.c<br>#include”my.h”<br>int foo()<br>{<br>    printf(“this is foo\n”);<br>}<br>//文件simple.c<br>#include”my.h”<br>int simple()<br>{<br>    printf(“this is simple\n”);<br>}<br>//文件hello.c<br>#include”my.h”<br>int hello()<br>{<br>    printf(“this is hello\n”);<br>}<br>//文件main.c，主函数所在文件，程序入口<br>#include”my.h”<br>int main()<br>{<br>    printf(“Hello world”);<br>    foo();<br>    simple();<br>    hello();//分别调用三个文件内的函数<br>    return 0;<br>}</p><pre><code>- 此时我们再编写一个编译多个文件的makefile：```c示例5：将多个.c文件编译生成最终的可执行程序all:main.o foo.o simple.o hello.o    gcc main.o foo.o simple.o hello.o -o hellomain.o:main.c    gcc main.c -c -o main.ofoo.o:foo.c    gcc foo.c -c -o foo.osimple.o:simple.c    gcc simple.c -c -o simple.ohello.o:hello.c    gcc hello.c -c -o hello.oclean:    rm *.o</code></pre><ul><li>示例5的makefile与常规的管理大型程序的makefile已经十分接近了。这里注意makefile的最后，我们添加了一个clean目标，用于清除生成的.o文件。</li><li>通过示例5的makefile我们可以看到，在编写makefile的时候，最重要的是需要将目标以及该目标的依赖关系弄清楚。若没有弄清楚目标和依赖关系，则编写的makfile也会有各种问题。</li><li>若我们已经执行make编译生成了可执行文件hello，此时又修改代码，会有什么现象呢？<ul><li>例如，我们此时修改main.c而其他.c文件不动：<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//文件main.c，修改后的main.c</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">"my.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">simple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//分别调用三个文件内的函数</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//又调用一次hello()函数</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li>修改main.c后再执行make。我们会发现makefile只会针对main.c和main.o重新编译。</li><li>这是因为makefile为了节省编译时间，只会重新编译被修改过的文件。也就是说，若文件未被修改（时间戳没变）则不会重新编译，若文件被修改（时间戳改变）则重新编译。</li></ul><h3 id="3、makefile假目标"><a href="#3、makefile假目标" class="headerlink" title="3、makefile假目标"></a>3、makefile假目标</h3><ul><li>在示例5中我们在makefile最后添加了一个clean目标用于清除生成的.o文件。但是添加了clean目标后会造成一个问题：若我们的C语言源文件内恰好有一个clean.c文件，则我们执行make clean的时候，makefile不会执行清除文件命令，而是会编译clean.c生成clean文件。</li><li>在实际的程序开发中也难免出现所定义的目标与已存在的文件重名的情况。针对于这种情况，makefile提供了“假目标（phony target）”这个用法。</li><li>假目标使用.PHONY关键字定义，注意.PHONY关键字都是大写。<pre class="line-numbers language-c"><code class="language-c">示例<span class="token number">6</span>：给示例<span class="token number">5</span>添加假目标<span class="token punctuation">.</span>PHONY<span class="token punctuation">:</span>cleanall<span class="token punctuation">:</span>main<span class="token punctuation">.</span>o foo<span class="token punctuation">.</span>o simple<span class="token punctuation">.</span>o hello<span class="token punctuation">.</span>o  gcc main<span class="token punctuation">.</span>o foo<span class="token punctuation">.</span>o simple<span class="token punctuation">.</span>o hello<span class="token punctuation">.</span>o <span class="token operator">-</span>o hellomain<span class="token punctuation">.</span>o<span class="token punctuation">:</span>main<span class="token punctuation">.</span>c  gcc main<span class="token punctuation">.</span>c <span class="token operator">-</span>c <span class="token operator">-</span>o main<span class="token punctuation">.</span>ofoo<span class="token punctuation">.</span>o<span class="token punctuation">:</span>foo<span class="token punctuation">.</span>c  gcc foo<span class="token punctuation">.</span>c <span class="token operator">-</span>c <span class="token operator">-</span>o foo<span class="token punctuation">.</span>osimple<span class="token punctuation">.</span>o<span class="token punctuation">:</span>simple<span class="token punctuation">.</span>c  gcc simple<span class="token punctuation">.</span>c <span class="token operator">-</span>c <span class="token operator">-</span>o simple<span class="token punctuation">.</span>ohello<span class="token punctuation">.</span>o<span class="token punctuation">:</span>hello<span class="token punctuation">.</span>c  gcc hello<span class="token punctuation">.</span>c <span class="token operator">-</span>c <span class="token operator">-</span>o hello<span class="token punctuation">.</span>oclean<span class="token punctuation">:</span>  rm <span class="token operator">*</span><span class="token punctuation">.</span>o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>采用.PHONY关键字定义clean了之后，make不会将clean作为一个文件处理而是当做一个目标去处理。</li></ul><h3 id="4、makefile变量"><a href="#4、makefile变量" class="headerlink" title="4、makefile变量"></a>4、makefile变量</h3><h4 id="1）使用makefile变量"><a href="#1）使用makefile变量" class="headerlink" title="1）使用makefile变量"></a>1）使用makefile变量</h4><ul><li>只要是程序开发人员对变量肯定都十分熟悉。为了方便程序开发人员使用，makefile内也有变量，其变量的用法类似于Shell编程的变量用法。使用makefile变量可以让makefile变得更加简洁、方便维护。</li><li>makefile的变量定义十分简单，格式为：<ul><li>变量名 = 变量值</li></ul></li><li>其中变量值可以有多个。类似于Shell编程中的变量定义，不过赋值号左右无需考虑空格的问题。</li><li>若要引用定义过的变量，则可以：<ul><li>$(变量名) 或 ${变量名}<br>即可。<pre class="line-numbers language-c"><code class="language-c">示例<span class="token number">7</span>：将示例<span class="token number">6</span>内部分字段替换为变量形式：<span class="token punctuation">.</span>PHONY<span class="token punctuation">:</span>cleanOBJS <span class="token operator">=</span> main<span class="token punctuation">.</span>o foo<span class="token punctuation">.</span>o simple<span class="token punctuation">.</span>o hello<span class="token punctuation">.</span>oOBJ <span class="token operator">=</span> helloCC <span class="token operator">=</span> gccRM <span class="token operator">=</span> rm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><p>$(OBJ):$(OBJS)<br>    $(CC) $(OBJS) -o $(OBJ)<br>main.o:main.c<br>    $(CC) main.c -c -o main.o<br>foo.o:foo.c<br>    $(CC) foo.c -c -o foo.o<br>simple.o:simple.c<br>    $(CC) simple.c -c -o simple.o<br>hello.o:hello.c<br>    $(CC) hello.c -c -o hello.o<br>clean:<br>    $(RM) $(OBJS) $(OBJ)</p><pre><code>- 在这个makefile中，我们引入了4个变量：    - OBJS：表示生成最终可执行程序所依赖的目标文件    - OBJ：表示最终生成的可执行文件名    - CC：表示编译器使用GCC    - RM：用于指示删除文件命令- 采用变量来书写makefile是十分方便的。若我们需要修改makefile的内容，则只需修改变量定义处即可，而无需修改makefile内的内容。- 需要注意的是，$符号对makefile有特殊含义。若我们想在makefile内使用echo命令打印$符号则需要连续两个$$才可以。- makefile内预定义了一些变量，这些变量为：    - AR：库文件维护程序的名称，默认为ar    - AS：汇编程序的名称，默认为as    - CC：C编译器的名称，默认为gcc    - CPP：C预处理器的名称，默认为gcc -E    - CXX：C++编译器的名称，默认为g++    - FC：Fortran编译器的名称，默认为f77    - RM：文件删除命令的名称，默认为rm -f    - ARFLAGS：库文件选项，无默认值    - ASFLAGS：汇编程序选项，无默认值    - CFLAGS：C编译器选项，无默认值    - CPPFLAGS：C预处理器选项，无默认值    - CXXFLAGS：C++编译器选项，无默认值    - FFLAGS：Fortran编译器选项，无默认值#### 2）makefile的自动推断- 使用变量后确实方便了makefile的编写，但这不是makefile的最终形态。若目标文件OBJS过多，则每次在写规则的时候都会十分麻烦。而且我们发现，使用了变量后，大多数的规则内容都显得重复。若我们可以自动让makefile寻找OBJS内容然后生成目标，则会大大简化makefile的书写工作。- 这时，我们可以使用makefile提供的自动变量。当我们的编译目标有多个的时候，使用自动变量会大大简化makefile的编写工作。自动变量有：    - $@：表示一个规则中的目标    - $^：表示规则的所有依赖的文件名。注意一般情况下$^只会在makefile内出现一次    - $&lt;：表示规则的第一个依赖的文件名。若为自动推导，则为该规则添加第一个依赖文件名```c示例8：将示例7使用自动变量改写.PHONY:cleanOBJS = main.o foo.o simple.o hello.oOBJ = helloCC = gccRM = rm$(OBJ):$(OBJS)     $(CC) $^ -o $@main.o:main.c    $(CC) $&lt; -c -o $@foo.o:foo.c    $(CC) $&lt; -c -o $@simple.o:simple.c    $(CC) $&lt; -c -o $@hello.o:hello.c    $(CC) $&lt; -c -o $@clean:    $(RM) $(OBJS) $(OBJ)</code></pre><ul><li>makefile的功能很强大，它可以自动推导文件以及文件依赖关系以及后面的命令。例如：<pre class="line-numbers language-c"><code class="language-c">main<span class="token punctuation">.</span>o<span class="token punctuation">:</span>main<span class="token punctuation">.</span>c  $<span class="token punctuation">(</span>CC<span class="token punctuation">)</span> $<span class="token operator">&lt;</span> <span class="token operator">-</span>c <span class="token operator">-</span>o $@<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>当makefile执行该命令的时候，它会首先查看$@的内容，makefile会自动推断出此处$@应是main.o。然后查看$&lt;的内容，makefile会根据指定的依赖关系自动推断出生成main.o需要main.c文件。这样我们所有的规则都可以使用自动变量的形式来书写了。</li><li>既然所有的规则都已经使用$(CC) $^ -c -o $@改写了，那所有的目标和依赖关系可不可以也被某些写法替代呢？也就是说，能不能将所有的<pre class="line-numbers language-c"><code class="language-c">which<span class="token punctuation">.</span>c<span class="token punctuation">:</span>which<span class="token punctuation">.</span>o  $<span class="token punctuation">(</span>CC<span class="token punctuation">)</span> $<span class="token operator">&lt;</span> <span class="token operator">-</span>c <span class="token operator">-</span>o $@<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>都合并到一起呢？当然可以！<pre class="line-numbers language-c"><code class="language-c">示例<span class="token number">9</span>：更加简化的makefile，将所有的which<span class="token punctuation">.</span>o<span class="token punctuation">:</span>which<span class="token punctuation">.</span>c都合并<span class="token punctuation">.</span>PHONY<span class="token punctuation">:</span>cleanOBJS <span class="token operator">=</span> main<span class="token punctuation">.</span>o foo<span class="token punctuation">.</span>o simple<span class="token punctuation">.</span>o hello<span class="token punctuation">.</span>oOBJ <span class="token operator">=</span> helloSRC <span class="token operator">=</span> main<span class="token punctuation">.</span>c foo<span class="token punctuation">.</span>c simple<span class="token punctuation">.</span>c hello<span class="token punctuation">.</span>cCC <span class="token operator">=</span> gccRM <span class="token operator">=</span> rm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>$(OBJ):$(OBJS)<br>    $(CC) $^ -o $@<br>%.o:%.c<br>    $(CC) $&lt; -c -o $@</p><p>clean:<br>    $(RM) $(OBJS) $(OBJ)</p><p>```</p><ul><li>在示例9的makefile内，’%’表示的是makefile的通配符（类似于Shell编程内的*）。示例9的makefile的运行流程如下：<ul><li>1.makefile要生成$(OBJ)（即hello），需要依赖$(OBJS)（即所有.o文件）。但是此时目录内没有.o文件</li><li>2.继续向下，发现%.o:%.c字段，使用通配符匹配，发现此时%.o的%应为main，即%.o=main.o</li><li>3.匹配成功，那么后面的%.c自动推断为main.c</li><li>4.执行规则$(CC) $&lt; -c -o $@，将main.c填入$&lt;的位置，将main.o填入$@的位置。</li><li>5.返回$(OBJ):$(OBJS)处，试图生成hello，发现还缺少其他的.o文件</li><li>6.重复步骤2、3、4，直至所有$(OBJS)都被生成</li><li>7.返回$(OBJ):$(OBJS)处，生成hello</li></ul></li><li>我们的makefile功能更强大了！</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-高级c</title>
      <link href="/2020/071616391.html"/>
      <url>/2020/071616391.html</url>
      
        <content type="html"><![CDATA[<h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><ul><li>全称为GNUCC，GNU项目中符合ANSIC标准的编译系统编译如C、C++、Object C、Java、Fortran、Pascal、Modula-3和Ada等多种语言</li><li>GCC是可以在多种硬体平台上编译出可执行程序的超级编译器，其执行效率与一般的编译器相比平均效率要高20%~30%</li><li>一个交叉平台编译器，适合在嵌入式领域的开发编译</li></ul><h3 id="1-GCC简介"><a href="#1-GCC简介" class="headerlink" title="1.GCC简介"></a>1.GCC简介</h3><ul><li>gcc所支持后缀名解释<ul><li>.c                            C原始程序</li><li>-.C/.cc/.cxx                C++原始程序</li><li>.m                           Objective-C原始程序</li><li>.i                                已经过预处理的C原始程序</li><li>.ii                            已经过预处理的C++原始程序</li><li>.s/.S                          汇编语言原始程序</li><li>.h                              预处理文件（头文件）</li><li>.a/.so                        编译后的库文件</li></ul></li></ul><h3 id="2-编译器的主要组件"><a href="#2-编译器的主要组件" class="headerlink" title="2.编译器的主要组件"></a>2.编译器的主要组件</h3><ul><li>分析器：分析器将源语言程序代码转换为汇编语言。因为要从一种格式转换为另一种格式（C到汇编），所以分析器需要知道目标机器的汇编语言。</li><li>汇编器：汇编器将汇编语言代码转换为CPU可以执行字节码。</li><li>链接器：链接器将汇编器生成的单独的目标文件组合成可执行的应用程序。链接器需要知道这种目标格式以便工作。</li><li>标准C库：核心的C函数都有一个主要的C库来提供。如果在应用程序中用到了C库中的函数，这个库就会通过链接器和源代码连接来生成最终的可执行程序。</li></ul><h3 id="3-GCC的基本用法和选项"><a href="#3-GCC的基本用法和选项" class="headerlink" title="3.GCC的基本用法和选项"></a>3.GCC的基本用法和选项</h3><ul><li>Gcc最基本的用法是：gcc[options][filenamesl<ul><li>·c，只编译，不连接成为可执行文件，编译器只是由输入的.c等源代码文件生成.o为后缀的目标文件，通常用于编译不包含主程序的子程序文件。</li><li>·o output filename，确定输出文件的名称为output filename，同时这个名称不能和源文件同名。如果不给出这个选项，gcc就给出预设的可执行文件a.out。</li><li>·-g，产生符号调试工具（GNU的gdb）所必要的符号资讯，要想对源代码进行调试，我们就必须加入这个选项。</li><li>·-0，对程序进行优化编译、连接，采用这个选项，整个源代码会在编译、连接过程中进行优化处理，这样产生的可执行文件的执行效率可以提高，但是，编译、连接的速度就相应地要慢一些。</li><li>·-02，比-0更好的优化编译、连接，当然整个编译、连接过程会更慢。</li><li>·-I dirname，将dirname所指出的目录加入到程序头文件目录列表中，是在预编译过程中使用的参数。</li><li>·-Ldirname，将dirname所指出的目录加入到程序函数档案库文件的目录列表中，是在链接过程中使用的参数。</li></ul></li></ul><h3 id="4-GCC的错误类型及对策"><a href="#4-GCC的错误类型及对策" class="headerlink" title="4.GCC的错误类型及对策"></a>4.GCC的错误类型及对策</h3><ul><li>第一类：C语法错误<ul><li>错误信息：文件source.c中第n行有语法错误（syntex errror）。有些情况下，一个很简单的语法错误，gcc会给出一大堆错误，我们最主要的是要保持清醒的头脑，不要被其吓倒，必要的时候再参考一下C语言的基本教材。</li></ul></li><li>第二类：头文件错误<ul><li>错误信息：找不到头文件head.h（Can not find include file head.h）。<br>这类错误是源代码文件中的包含头文件有问题，可能的原因有头文件名错误、指定的头文件所在目录名错误等，也可能是错误地使用了双引号和尖括号。</li></ul></li><li>第三类：档案库错误<ul><li>错误信息：链接程序找不到所需的函数库（1d:-1m:No such file or directory）。<br>这类错误是与目标文件相连接的函数库有错误，可能的原因是函数库名错误、指定的函数库所在目录名称错误等，检查的方法是使用find命令在可能的目录中寻找相应的函数库名，确定档案库及目录的名称并修改程序中及编译选项中的名称。</li></ul></li><li>第四类：未定义符号<ul><li>错误信息：有未定义的符号（Undefined symbo1）。这类错误是在连接过程中出现的，可能有两种原因：一是使用者自己定义的函数或者全局变量所在源代码文件，没有被编译、连接，或者干脆还没有定义，这需要使用者根据实际情况修改源程序，给出全局变量或者函数的定义体；二是未定义的符号是一个标准的库函数，在源程序中使用了该库函数，而连接过程中还没有给定相应的函数库的名称，或者是该档案库的目录名称有问题，这时需要使用档案库维护命令ar检查我们需要的库函数到底位于哪一个函数库中，确定之后，修改gcc连接选项中的-1和-L项。</li></ul></li></ul><h3 id="5-GCC编译过程"><a href="#5-GCC编译过程" class="headerlink" title="5.GCC编译过程"></a>5.GCC编译过程</h3><ul><li><p>GCC的编译流程分为四个步骤：  </p><p>1.预处理（Pre-Processing）   </p><p>2.编译（Compiling）  </p><p>3.汇编（Assembling）  </p><p>4.链接（Linking）</p></li></ul><h3 id="6-调试器——Gdb调试流程"><a href="#6-调试器——Gdb调试流程" class="headerlink" title="6.调试器——Gdb调试流程"></a>6.调试器——Gdb调试流程</h3><ul><li><p>首先使用gcc对test.c进行编译，注意一定要加上选项‘-g’ </p><p>#gcc-g test.c-o test  </p><p>#gdb test GNU gdb Red Hat Linux（6.3.0.0-1.21rh）  </p><p>Copyright 2004 Free Software Foundation，Inc.<br>GDB is free software，covered by the GNU General Public License，and you are welcome to change it and/or distribute copies of it under certain conditions.  </p><p>Type”show copying”to see the conditions.  </p><p>There is absolutely no warranty for GDB.Type”show warranty”for details.<br>This GDB was configured as”i386-redhat-linux-gnu’…Using host libthread_db library”/lib/libthread db.so.1”.<br>（gdb）</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P1594892943886.png" alt=""></p><h3 id="7-Gdb的使用切记点"><a href="#7-Gdb的使用切记点" class="headerlink" title="7.Gdb的使用切记点"></a>7.Gdb的使用切记点</h3><ul><li>在gcc编译选项中一定要加入‘-g’。</li><li>只有在代码处于“运行”或“暂停”状态时才能查看变量值。</li><li>设置断点后程序在指定行之前停止</li></ul><h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><ul><li><p>编译器根据条件的真假决定是否编译相关的代码，</p></li><li><p>常见的条件编译有两种方法：</p><ul><li><p>一、根据宏是否定义，其语法如下：  </p><p>#ifdef &lt; macro &gt;</p><p>……..</p><p>#else</p><p>……..</p><p>#endif</p></li><li><p>二、根据宏的值，其语法如下：  </p><p>#if&lt; macro &gt;</p><p>…………</p><p>#else</p><p>…………</p><p>#endif</p></li></ul></li></ul><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="1-简述"><a href="#1-简述" class="headerlink" title="1.简述"></a>1.简述</h3><ul><li>在实际的处理对象中，有许多信息是由多个不同类型的数据组合在一起进行描述，而且这些不同类型的数据是互相联系组成了一个有机的整体。此时，就要用到一种新的构造类型数据——结构体（structure），简称结构。</li><li>-结构体的使用为处理复杂的数据结构（如动态数据结构等）提供了有效的手段，而且，它们为函数间传递不同类型的数据提供了方便。</li></ul><h3 id="2-定义"><a href="#2-定义" class="headerlink" title="2.定义"></a>2.定义</h3><ul><li><p>定义一个结构体类型的一般形式为：  </p><p>struct      结构体名</p><p>{</p><p>​    数据类型    成员名1；</p><p>​    数据类型    成员名2；</p><p>​    ：</p><p>​    数据类型    成员名n；<br>}；</p></li><li><p>在大括号中的内容也称为“成员列表”或“域表”。</p></li><li><p>其中，每个成员名的命名规则与变量名相同；</p></li><li><p>数据类型可以是基本变量类型和数组类型，或者是一个结构体类型；</p></li><li><p>用分号“；”作为结束符。整个结构的定义也用分号作为结束符</p></li></ul><h3 id="3-说明"><a href="#3-说明" class="headerlink" title="3.说明"></a>3.说明</h3><ul><li><p>结构体类型中的成员名可以与程序中的变量名相同，二者并不代表同一对象，编译程序可以自动对它们进行区分。  </p><p>最后，总结一下结构体类型的特点：  </p><p>（1）结构体类型是用户自行构造的。  </p><p>（2）它由若干不同的基本数据类型的数据构成。  </p><p>（3）它属于C语言的一种数据类型，与整型、实型相当。因此，定义它时不分配空间，只有用它定义变量时才分配空间。</p></li></ul><h3 id="4-方法"><a href="#4-方法" class="headerlink" title="4.方法"></a>4.方法</h3><ul><li><p>1.结构体类型变量的定义方法</p><ul><li><p>先定义结构体类型再定义变量名</p></li><li><p>这是C语言中定义结构体类型变量最常见的方式</p><p>​    struct    结构体名</p><p>​    {</p><p>​                成员列表；<br>​    }；</p><p>​    struct结构体名变量名；</p></li></ul></li><li><p>2.在定义类型的同时定义变量</p><ul><li><p>这种形式的定义的一般形式为：  </p><p>struct    结构体名</p><p>​    {</p><p>​                成员列表；</p><p>​    }变量名；</p></li></ul></li><li><p>3.直接定义结构类型变量</p><ul><li><p>其一般形式为：  </p><p>struct     //没有结构体名</p><p>​    {</p><p>​            成员列表；</p><p>​    }变量名；</p></li></ul></li></ul><h3 id="5-大小"><a href="#5-大小" class="headerlink" title="5.大小"></a>5.大小</h3><ul><li><p>一个结构体变量占用内存的实际大小，也可以利用sizeof求出。它的运算表达式为：  </p><p>sizeof（运算量）  </p><p>//求出给定的运算量占用内存空间的字节数</p><p>其中运算量可以是变量、数组或结构体变量，可以是数据类型的名称。  </p><p>例如：  </p><p>sizeof（struct worker）  </p><p>sizeof（worker1）</p></li></ul><h3 id="6-结构体变量的使用形式"><a href="#6-结构体变量的使用形式" class="headerlink" title="6.结构体变量的使用形式"></a>6.结构体变量的使用形式</h3><ul><li><p>结构体变量是不同数据类型的若干数据的集合体。在程序中使用结构体变量时，一般情况下不能把它作为一个整体参加数据处理，而参加各种运算和操作的是结构体变量的各个成员项数据。  </p><p>结构体变量的成员用以下一般形式表示：  </p><pre><code>      结构体变量名.成员名    例如，上节给出的结构体变量worker1具有下列七个成员：    </code></pre><pre class="line-numbers language-bash"><code class="language-bash">          worker1.number；workerl.name；workerl.sex；​            workerl.age；workerl.salary；workerl.address；​            worker1.phone<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在定义了结构体变量后，就可以用不同的赋值方法对结构体变量的每个成员赋值。<br>例如：</p><pre class="line-numbers language-c"><code class="language-c">     strcpy（workerl<span class="token punctuation">.</span>name，”zhang San”）；​     workerl<span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token number">26</span>；​     strcpy（workerl<span class="token punctuation">.</span>phone，"<span class="token number">1234567</span>”）；​     workerl<span class="token punctuation">.</span>sex<span class="token operator">=</span><span class="token string">'m'</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除此之外，还可以引用结构体变量成员的地址以及成员中的元素。例如：引用结构体变量成员的首地址&amp;workerl.name；引用结构体变量成员的第二个字符worker1.name[1]；引用结构体变量的首地址&amp;worker1。</p></li></ul><h3 id="7-结构体变量的初始化"><a href="#7-结构体变量的初始化" class="headerlink" title="7.结构体变量的初始化"></a>7.结构体变量的初始化</h3><ul><li><p>与其他类型变量一样，也可以给结构体的每个成员赋初值，这称为结构体的初始化。一种是在定义结构体变量时进行初始化，语法格式如下：<br>struct 结构体名变量名={初始数据表}；</p></li><li><p>另一种是在定义结构体类型时进行结构体变量的初始化。  </p><pre class="line-numbers language-c"><code class="language-c">  <span class="token keyword">struct</span>结构体名​    <span class="token punctuation">{</span>​            成员列表；​    <span class="token punctuation">}</span>变量名<span class="token operator">=</span><span class="token punctuation">{</span>初始数据表<span class="token punctuation">}</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h2></li></ul><h3 id="1-结构体数组的定义"><a href="#1-结构体数组的定义" class="headerlink" title="1.结构体数组的定义"></a>1.结构体数组的定义</h3><ul><li><p>具有相同结构体类型的结构体变量也可以组成数组，称它们为结构体数组。结构体数组的每一个数组元素都是结构体类型的数据，它们都分别包括各个成员（分量）项。</p></li><li><p>定义结构体数组的方法和定义结构体变量的方法相仿，只需说明其为数组即可。<br>可以采用三种方法：</p><ul><li><p>1.先定义结构体类型，再用它定义结构体数组。  </p><p>结构体数组的定义形式如下：</p><pre class="line-numbers language-c"><code class="language-c">    <span class="token keyword">struct</span>     结构体名​    <span class="token punctuation">{</span>    ​                成员表列​    <span class="token punctuation">}</span>；​        <span class="token keyword">struct</span> 结构体名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>2.在定义结构体类型同时定义结构体数组</p><p>结构体数组的定义形式如下：</p><pre class="line-numbers language-c"><code class="language-c">    <span class="token keyword">struct</span> 结构体名​    <span class="token punctuation">{</span>​                    成员表列；​    <span class="token punctuation">}</span>数组名<span class="token punctuation">[</span>元素个数<span class="token punctuation">]</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>3.直接定义结构体数组</p><p>结构体数组的定义形式如下：  </p><pre class="line-numbers language-c"><code class="language-c">    <span class="token keyword">struct</span>    <span class="token comment" spellcheck="true">//没有结构体名</span>​    <span class="token punctuation">{</span>​        成员表列；​    <span class="token punctuation">}</span>数组名<span class="token punctuation">[</span>元素个数<span class="token punctuation">]</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h3 id="2-结构体数组的初始化"><a href="#2-结构体数组的初始化" class="headerlink" title="2.结构体数组的初始化"></a>2.结构体数组的初始化</h3><ul><li><p>结构体数组在定义的同时也可以进行初始化，并且与结构体变量的初始化规定相同，只能对全局的或静态存储类别的结构体数组初始化。<br>结构体数组初始化的一般形式是：  </p><pre class="line-numbers language-c"><code class="language-c">    <span class="token keyword">struct</span>    结构体名​    <span class="token punctuation">{</span>​            成员列表；​    <span class="token punctuation">}</span>；<span class="token keyword">struct</span>    结构体名    数组名<span class="token punctuation">[</span>元素个数<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span>初始数据表<span class="token punctuation">}</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2></li><li><p>可以设定一个指钍变量用来指向一个结构体变量。此时该指针变量的值是结构体变量的起始地址，该指针称为结构体指针。</p></li><li><p>结构体指针与前面介绍的各种指针变量在特性和方法上是相同的。与前述相同，在程序中结构体指针也是通过访问目标运算“ * ”访问它的对象。结构体指针在程序中的一般定义形式为：  </p><pre><code>struct结构体名  *  结构指针名；</code></pre><p>其中的结构体名必须是已经定过的结构体类型。</p></li></ul><h2 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h2><h3 id="1-共用体的概念"><a href="#1-共用体的概念" class="headerlink" title="1.共用体的概念"></a>1.共用体的概念</h3><ul><li><p>在C语言中，不同数据类型的数据可以使用共同的存储区域，这种数据构造类型称为共用体，简称共用，又称联合体。共用体在定义、说明和使用形式上与结构体相似。两者本质上的不同仅在于使用内存的方式上。<br>定义一个共用体类型的一般形式为：  </p><pre><code>    union共用体名​    {​            成员表列；​            }；</code></pre><h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2></li><li><p>在C语言中，允许使用关键字typedef定义新的数据类型</p><p>其语法如下：  </p><p>typedef    〈已有数据类型&gt;    〈新数据类型〉；</p><p>如：</p><p>​        typedef     int     INTEGER；</p><p>这里新定义了数据类型INTEGER，其等价于int </p><p>​        INTEGER i；    &lt;==&gt;    int i；</p></li></ul><h2 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h2><ul><li>malloc/free <ul><li>void * malloc（size_t num）<br>void free（void * p）<ul><li>malloc函数本身并不识别要申请的内存是什么类型，它只关心内存的总字节数。</li><li>malloc申请到的是一块连续的内存，有时可能会比所申请的空间大。其有时会申请不到内存，返回NULL。</li><li>malloc返回值的类型是void<em>，所以在调用malloc时要显式地进行类型转换，将void</em>转换成所需要的指针类型。</li><li>如果free的参数是NULL的话，没有任何效果。</li><li>释放一块内存中的一部分是不被允许的。</li></ul></li><li>野指针：<br>不是NULL指针，是指向“垃圾”内存的指针。“野指针”是很危险的。<br>“野指针”的成因主要有两种：<ul><li>指针变量没有被初始化。</li><li>指针p被free之后，没有置为NULL，让人误以为p是个合法的指针。</li><li>指针操作超越了变量的作用范围。这种情况让人防不胜防。</li></ul></li></ul></li></ul><h2 id="Make"><a href="#Make" class="headerlink" title="Make"></a>Make</h2><ul><li>工程管理器，顾名思义，是指管理较多的文件</li><li>Make工程管理器也就是个“自动编译管理器”，这里的“自动”是指它能够根据文件时间戳自动发现更新过的文件而减少编译的工作量，同时，它通过读入Makefile文件的内容来执行大量的编译工作</li><li>Make将只编译改动的代码文件，而不用完全编译。</li></ul><h3 id="1-结构"><a href="#1-结构" class="headerlink" title="1.结构"></a>1.结构</h3><ul><li><p>Makefile格式  </p><p>target:dependency_files  </p><p>&lt; TAB &gt;command  </p><p>例子：  </p><pre class="line-numbers language-c"><code class="language-c">hello<span class="token punctuation">.</span>o<span class="token punctuation">:</span>hello<span class="token punctuation">.</span>c hello<span class="token punctuation">.</span>h  gcc<span class="token operator">-</span>chello<span class="token punctuation">.</span>c<span class="token operator">-</span>o hello<span class="token punctuation">.</span>o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一个复杂一些的例子</p><pre class="line-numbers language-c"><code class="language-c">sunq<span class="token punctuation">:</span>kang<span class="token punctuation">.</span>o yul<span class="token punctuation">.</span>o ​        gcc kang<span class="token punctuation">.</span>o yul<span class="token punctuation">.</span>o<span class="token operator">-</span>o sunq kang<span class="token punctuation">.</span>o<span class="token punctuation">:</span>kang<span class="token punctuation">.</span>c kang<span class="token punctuation">.</span>h ​        gcc<span class="token operator">-</span>Wall<span class="token operator">-</span>O<span class="token operator">-</span>g<span class="token operator">-</span>c kang<span class="token punctuation">.</span>c<span class="token operator">-</span>o kang<span class="token punctuation">.</span>o yul<span class="token punctuation">.</span>o<span class="token punctuation">:</span>yul<span class="token punctuation">.</span>c ​        gcc<span class="token operator">-</span>Wall<span class="token operator">-</span>O<span class="token operator">-</span>g<span class="token operator">-</span>cyul<span class="token punctuation">.</span>c<span class="token operator">-</span>o yul<span class="token punctuation">.</span>o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>注释：</p><ul><li><p>-Wa11：表示允许发出gcc所有有用的报警信息.  </p></li><li><p>-c：只是编译不链接，生成目标文件”.o”  </p></li><li><p>-ofile：表示把输出文件输出到file里</p></li><li><p>关于更多的用man工具</p></li></ul></li></ul><h3 id="2-创建和使用变量"><a href="#2-创建和使用变量" class="headerlink" title="2.创建和使用变量"></a>2.创建和使用变量</h3><ul><li><p>创建变量的目的：</p></li><li><p>用来代替一个文本字符串：  </p><p>1.系列文件的名字  </p><p>2.传递给编译器的参数  </p><p>3.需要运行的程序  </p><p>4.需要查找源代码的目录5.你需要输出信息的目录  </p><p>6.你想做的其它事情。  </p><ul><li><p>刚才的例子</p><pre class="line-numbers language-c"><code class="language-c">OBJS<span class="token operator">=</span>kang<span class="token punctuation">.</span>o yul<span class="token punctuation">.</span>o  CC<span class="token operator">=</span>gcc  CFLAGS<span class="token operator">=</span><span class="token operator">-</span>Wall<span class="token operator">-</span>O<span class="token operator">-</span>g  sunq：$（OBJS）  S（CC）S（OBJS）<span class="token operator">-</span>o sunq  kang<span class="token punctuation">.</span>o<span class="token punctuation">:</span>kang<span class="token punctuation">.</span>c kang<span class="token punctuation">.</span>h'  S（CC）S（CFLAGS）<span class="token operator">-</span>ckang<span class="token punctuation">.</span>c<span class="token operator">-</span>o kang<span class="token punctuation">.</span>o  yul<span class="token punctuation">.</span>o<span class="token punctuation">:</span>yul<span class="token punctuation">.</span>c yul<span class="token punctuation">.</span>h  $（CC）S（CFLAGS）<span class="token operator">-</span>c yul<span class="token punctuation">.</span>c<span class="token operator">-</span>o yul<span class="token punctuation">.</span>o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P1594901447956.png" alt=""></p></li></ul></li></ul><h3 id="3-Make使用"><a href="#3-Make使用" class="headerlink" title="3.Make使用"></a>3.Make使用</h3><ul><li>直接运行make</li><li>选项<ul><li>-C dir读入指定目录下的Makefile</li><li>-f file读入当前目录下的file文件作为Makefile</li><li>-i 忽略所有的命令执行错误</li><li>-I dir指定被包含的Makefile所在目录</li><li>-n 只打印要执行的命令，但不执行这些命令</li><li>-p 显示make变量数据库和隐含规则</li><li>-s 在执行命令时不显示命令</li><li>-w 如果make在执行过程中改变目录，打印当前目录名    </li></ul></li></ul><h3 id="4-Makefile的VPATH"><a href="#4-Makefile的VPATH" class="headerlink" title="4.Makefile的VPATH"></a>4.Makefile的VPATH</h3><ul><li>VPATH：虚路径<ul><li>在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。</li><li>Makefile文件中的特殊变量“VPATH”就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。</li><li>VPATH=src:../headers</li><li>上面的的定义指定两个目录，“src”和“../headers”，make会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-shell脚本</title>
      <link href="/2020/071647127.html"/>
      <url>/2020/071647127.html</url>
      
        <content type="html"><![CDATA[<h2 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h2><h3 id="1-shell脚本的本质"><a href="#1-shell脚本的本质" class="headerlink" title="1.shell脚本的本质"></a>1.shell脚本的本质</h3><ul><li>编译型语言C</li><li>解释型语言<ul><li>she11脚本语言是解释型语言</li><li>she11脚本的本质<ul><li>she11命令的有序集合</li></ul></li></ul></li></ul><h3 id="2-shell编程的基本过程"><a href="#2-shell编程的基本过程" class="headerlink" title="2.shell编程的基本过程"></a>2.shell编程的基本过程</h3><ul><li>基本过程分为三步：<ul><li>step1.建立she11文件包含任意多行操作系统命令或shel1命令的文本文件；</li><li>step2.赋予she11文件执行权限用chmod命令修改权限；</li><li>step3.执行she11文件直接在命令行上调用she11程序.</li></ul></li></ul><h3 id="3-shell变量"><a href="#3-shell变量" class="headerlink" title="3.shell变量"></a>3.shell变量</h3><ul><li><p>she11允许用户建立变量存储数据，但不支持数据类型（整型、字符、浮点型），将任何赋给变量的值都解释为一串字符                 </p><p>​                                                                                Variable=value</p><ul><li>count=1</li><li>echo $count</li><li>DATE=date</li><li>echo $DATE</li></ul></li><li><p>Bourne She11有如下四种变量：</p><ul><li>用户自定义变量<ul><li>在she11编程中通常使用全大写变量，方便识别<br>-$COUNT=1</li><li>变量的调用：在变量前加$<br>-$ echo $HOME Linux She11/bash从右向左赋值<br>-$Y=y<br>-$X=SY<br>-$ echo $X</li><li>使用unset命令删除变量的赋值<br>-$Z=hello<br>-$ echo $Z<br>-hello<br>-$ unset Z-$ echo $Z</li></ul></li><li>位置变量即命令行参数<ul><li>$0与键入的命令行一样，包含脚本文件名</li><li>$1，$2，……$9分别包含第一个到第九个命令行参数</li><li>$#包含命令行参数的个数</li><li>$@包含所有命令行参数：“$1，$2，……$9”</li><li>$？包含前一个命令的退出状态</li><li>$*包含所有命令行参数：“$1，$2，……$9”</li><li>$$包含正在执行进程的ID号</li></ul></li><li>预定义变量</li><li>环境变量<ul><li>常用she环境变量<ul><li>HOME:/etc/passwd文件中列出的用户主目录</li><li>IFS:Internal Field Separator，默认为空格，tab及换行符</li><li>PATH:she11搜索路径</li><li>PS1，PS2：默认提示符（$）及换行提示符（&gt;）</li><li>TERM：终端类型，常用的有vt100，ansi，vt200，xterm等</li></ul></li></ul></li></ul></li></ul><h3 id="4-shell程序和语句"><a href="#4-shell程序和语句" class="headerlink" title="4.shell程序和语句"></a>4.shell程序和语句</h3><ul><li>she11程序由零或多条she11语句构成。she11语句包括三类：说明性语句、功能性语句和结构性语句。<ul><li>说明性语句：<br>以#号开始到该行结束，不被解释执行</li><li>功能性语句：<br>任意的shell命令、用户程序或其它she11程序。</li><li>结构性语句：<br>条件测试语句、多路分支语句、循环语句、循环控制语句等。</li></ul></li></ul><h3 id="5-常用功能性语句-命令"><a href="#5-常用功能性语句-命令" class="headerlink" title="5.常用功能性语句(命令)"></a>5.常用功能性语句(命令)</h3><ul><li><p>read从标准输入读入一行，并赋值给后面的变量，其语法为：<br>read var</p><p>把读入的数据全部赋给var </p><p>read varl var2 var3</p><p>把读入行中的第一个单词（word）赋给var1，第二个单词赋给var2，……把其余所有的词赋给最后一个变量.</p></li><li><p>如果执行read语句时标准输入无数据，则程序在此停留等侯，直到数据的到来或被终止运行。</p></li></ul><h3 id="6-expr命令"><a href="#6-expr命令" class="headerlink" title="6.expr命令"></a>6.expr命令</h3><ul><li><p>算术运算命令expr主要用于进行简单的整数运算，包括加（+）、减（一）、乘（ \ * ）、整除（/）和求模（%）等操作。例如：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token variable">$expr</span> 12 + 5 \* 327<span class="token variable">$expr</span> 3 - 8 / 2-1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>  $num=9<br>  $sum=expr $num*6<br>  $echo $sum<br>  54</p><pre><code>### 7.test语句- test语句可测试三种对象：  字符串      整数     文件属性- 每种测试对象都有若干测试操作符- 例如：  test &quot;$answer&quot; = &quot;yes&quot;  变量answer的值是否为字符串yes  test  $num - eq 18  变量num的值是否为整数18  test -d tmp  测试tmp是否为一个目录名#### 1.字符串测试- s1=s2测试两个字符串的内容是否完全一样- s1！=s2测试两个字符串的内容是否有差异- -z s1测试s1字符串的长度是否为0- -n s1测试s1字符串的长度是否不为0#### 2.整数测试- a -eq b测试a与b是否相等- a -ne b测试a与b是否不相等- a -gt b测试a是否大于b- a -ge b测试a是否大于等于b- a -It b测试a是否小于b- a -le b测试a是否小于等于b#### 3.文件测试- -d name 测试name 是否为一个目录- -e name测试一个文件是否存在- -f name测试name是否为普通文件- -Lname测试name是否为符号链接- -r name 测试name文件是否存在且为可读- -wname测试name文件是否存在且为可写- -xname测试name文件是否存在且为可执行- -s name 测试name文件是否存在且其长度不为0- f1-nt f2测试文件fl是否比文件f2更新- f1-ot f2测试文件f1是否比文件f2更旧### 8.结构性语句- 结构性语句主要根据程序的运行状态、输入数据、变量的取值、控制信号以及运行时间等因素来控制程序的运行流程。- 主要包括：条件测试语句（两路分支）、多路分支语句、循环语句、循环控制语句和后台执行语句等。#### 1.条件语句- if…then…fi- 语法结构：        if   表达式              then 命令表        fi  - 如果表达式为真，则执行命令表中的命令；否则退出if语句，即执行fi后面的语句。  - if和fi是条件语句的语句括号，必须成对使用；  - 命令表中的命令可以是一条，也可以是若干条。- if...then...else...fi- 语法结构为：   if         表达式  then      命令表1- else      命令表2  fi- 如果表达式为真，则执行命令表1中的命令，再退出if语句；否则执行命令表2中的语句，再退出if语句.  注意：无论表达式是否为真，都有语句要执行.#### 2.多路分支语句- case...esac多路分支语句case用于多重条件测试，语法结构清晰自然.其语法为：```bash  case             字符串变量     in  ​                    模式1）  ​                                        命令表1                                           ；；  ​                    模式2|模式3）  ​                                        命令表2  ​                                        ；；    ​                        ……                         模式n）  ​                                        命令表n                                           ；；  esac</code></pre><h3 id="9-循环语句"><a href="#9-循环语句" class="headerlink" title="9.循环语句"></a>9.循环语句</h3><h4 id="1-循环语句for"><a href="#1-循环语句for" class="headerlink" title="1.循环语句for"></a>1.循环语句for</h4><ul><li><p>当循环次数已知或确定时，使用for循环语句来多次执行一条或一组命令。<br>循环体由语句括号do和done来限定。格式为：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">for</span>   变量名    in   单词表                     <span class="token keyword">do</span>​                        命令表​                done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>变量依次取单词表中的各个单词，每取一次单词，就执行一次循环体中的命令.循环次数由单词表中的单词数确定.命令表中的命令可以是一条，也可以是由分号或换行符分开的多条。</p></li><li><p>如果单词表是命令行上的所有位置参数时，可以在for in单词表”部分。</p></li></ul><h4 id="2-循环语句while"><a href="#2-循环语句while" class="headerlink" title="2.循环语句while"></a>2.循环语句while</h4><ul><li><p>语法结构为：<br>while    命令或表达式</p><pre class="line-numbers language-c"><code class="language-c">    <span class="token keyword">do</span>​            命令表​    done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>while语句首先测试其后的命令或表达式的值，如果为真，就执行一次循环体中的命令，然后再测试该命令或表达式的值，执行循环体，直到该命令或表达式为假时退出循环。</li><li>while语句的退出状态为命令表中被执行的最后一条命令的退出状态</li></ul></li></ul><h3 id="10-循环控制语句"><a href="#10-循环控制语句" class="headerlink" title="10.循环控制语句"></a>10.循环控制语句</h3><ul><li><p>break和 continue </p><ul><li>break n则跳出n层；</li><li>continue语句则马上转到最近一层循环语句的下一轻循环上，</li><li>continue n则转到最近n层循环语句的下一轮循环上.</li></ul></li></ul><p>  实例.程序prog7的用法为：<br>       prog7        整数        整数        整数        …<br>  参数个数不确定，范围为1~10个，每个参数都是正整数。</p><h3 id="11-shell函数调用"><a href="#11-shell函数调用" class="headerlink" title="11.shell函数调用"></a>11.shell函数调用</h3><ul><li><p>函数调用格式：<br>方式1：</p><pre><code>value_name=function_name[argl arg2....]</code></pre><p>方式2：</p><pre><code>function_name[arg1 arg2..]echo $？</code></pre></li></ul><h3 id="12-函数变量作用域"><a href="#12-函数变量作用域" class="headerlink" title="12.函数变量作用域"></a>12.函数变量作用域</h3><ul><li>全局作用域：在脚本的其他任何地方都能够访问该变量。</li><li>局部作用域：只能在声明变量的作用域内访问。</li><li>声明局部变量的格式：<ul><li>Local variable name =value</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-命令</title>
      <link href="/2020/07145118.html"/>
      <url>/2020/07145118.html</url>
      
        <content type="html"><![CDATA[<h2 id="软件包命令"><a href="#软件包命令" class="headerlink" title="软件包命令"></a>软件包命令</h2><ul><li>/etc/apt/sources.list——软件配置文件</li><li>/var/lib/apt/list/*——服务器资源列表存放位置</li><li>/var/cache/apt/archives——本地软件缓存目录</li></ul><ul><li>安装软件</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> xxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>中途安装失败，重新安装</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> xxx --reinstall<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>不完全卸载</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> remove xxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>完全卸载</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> --purge remove xxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>清理软件包缓冲区(var/cache/apt/archives)</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>保留最新版本软件包，多于版本全部清除</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> autoclean<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>获取软件包详细信息</li></ul><pre class="line-numbers language-bash"><code class="language-bash">apt-cache show xxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>获取软件包的安装状态</li></ul><pre class="line-numbers language-bash"><code class="language-bash">apt-cache policy xxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>获取某个软件包依赖于哪些软件包</li></ul><pre class="line-numbers language-bash"><code class="language-bash">apt-cache depends xxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>获取某个软件包被哪些软件包所依赖</li></ul><pre class="line-numbers language-bash"><code class="language-bash">apt-cache rdepends xxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><h3 id="1-shell是一个命令行解释器"><a href="#1-shell是一个命令行解释器" class="headerlink" title="1.shell是一个命令行解释器"></a>1.shell是一个命令行解释器</h3><ul><li>Bourne Shell（简称sh）：它是Unix的第一个shell程序，早已成为工业标准。目前几乎所有的Linux系统都支持它。不过Bourne Shell的作业控制功能薄弱，且不支持别名与历史记录等功能。</li><li>CShell（简称csh）</li><li>Korn Shell（简称ksh）</li><li>Bourne Again Shell：能够提供环境变量以配置用户Shell环境，支持历史记录，内置算术功能，支持通配符表达式，将常用命令内置简化。</li></ul><h3 id="2-补齐命令与文件名"><a href="#2-补齐命令与文件名" class="headerlink" title="2.补齐命令与文件名"></a>2.补齐命令与文件名</h3><ul><li>在使用Shell命令时，很多用户会经常遇到命令或文件名没有记全的情况。Bash Shell的命令和文件名补齐功能会帮助用户。在输入命令或文件名的前几个字符后，按TAB键或ESC键自动补齐剩余没有输入的字符串。</li><li>如果存在多个命令或文件有相同前缀，shell将列出所有相同前缀的命令或文件。shell给出的提示信息，帮助用户回忆和完成输入。之后等待用户输入足够的字符。</li><li>需要说明的是，连续按两下TAB键或ESC键，用于命令补齐；按下一次TAB键，用于文件名补齐。</li></ul><h3 id="3-查询命令历史"><a href="#3-查询命令历史" class="headerlink" title="3.查询命令历史"></a>3.查询命令历史</h3><ul><li><p>用户在Shell下的操作是有很太连续性的，曾经输入的命令可能需要多次使用。当用户在操作中发现问题，需要查看曾经执行过的操作。Bash将用户曾经键入的命令序列保存在一个命令历史表中。按“个”键和“！”键，便可查询命令历史。</p></li><li><p>Bash Shell还提供了history命令。该命令将命令历史表按列表形式，从记录号1开始，一次性全部显示出来。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">history</span> <span class="token punctuation">[</span>numberine<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        </p></li><li><p>显然history只能记录有限条的历史命令，默认保留500条命令。</p></li><li><p>Bash Shell将历史命令容量保存在环境变量HISTSIZE中。</p><ul><li><p>使用“echo_SHISTSIZE”查看当前历史命令容量；</p></li><li><p>通过直接赋值的方法，修改这个环境变量。</p><pre class="line-numbers language-bash"><code class="language-bash">linux@ubuntu:-S <span class="token keyword">echo</span> SHISTSIZE<span class="token comment" spellcheck="true">#显示历史命令容量500</span>linux@ubuntu:-S HISTSIZE<span class="token operator">=</span>1000<span class="token comment" spellcheck="true">#修改历史命令容量</span>linux@ubuntu：～S <span class="token keyword">echo</span> SHISTSIZE1000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h3 id="4-通配符"><a href="#4-通配符" class="headerlink" title="4.通配符"></a>4.通配符</h3><ul><li><p>当需要用命令处理一组文件，例如filel.txt、file2.txt、file3.txt…，用户不必一一输入文件名，可以使用she11通配符。</p><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P1594716534544.png" alt=""></p></li></ul><h3 id="5-管道"><a href="#5-管道" class="headerlink" title="5.管道"></a>5.管道</h3><ul><li><p>管道可以把一系列命令连接起来，意味着第一个命令的输出将作为第二个命令的输入，通过管道传递给第二个命令，第二个命令的输出又将作为第三个命令的输入，以此类推。就像通过使用“|”符连成了一个管道。</p><pre class="line-numbers language-bash"><code class="language-bash">linux@ubuntu：~$ ls/usr/bin <span class="token operator">|</span> <span class="token function">wc</span> -w<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以上操作中，借助管道“|”，将ls的输出直接作为wc命令的输入。使用管道可以巧妙的将一些命令联合使用，得到单个命令所无法实现的效果。例如使用以上的命令组合，得到的是/usr/bin目录下文件的个数。</p></li></ul><h3 id="6-输入-输出重定向"><a href="#6-输入-输出重定向" class="headerlink" title="6.输入/输出重定向"></a>6.输入/输出重定向</h3><ul><li>输入/输出重定向是改变shell命令或程序默认的标准输入/输出目标，重新定向到新的目标。</li><li>Linux中默认的标准输入定义为键盘，标准输出定义为终端窗口。</li><li>用户可以为当前操作改变输入或输出，迫使某个特定命令的输入或输出来源为外部文件。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P1594717254263.png" alt=""></p><h3 id="7-命令置换"><a href="#7-命令置换" class="headerlink" title="7.命令置换"></a>7.命令置换</h3><p>命令替换是将一个命令的输出作为另一个命令的参数。命令格式如下所示。</p><ul><li><p>其中，命令command2的输出将作为命令command1的参数。需要注意，命令置换的单引号为ESC键下方的“ ` ”键</p><pre class="line-numbers language-bash"><code class="language-bash">command1 <span class="token variable"><span class="token variable">`</span>command2<span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><ul><li><p>pwd命令用于显示当前目录的绝对路径。在上面的命令行中，使用命令置换符，将pwd的运行结果作为ls命令的参数。最终，命令执行结果是显示当前目录的文件内容。</p><pre class="line-numbers language-bash"><code class="language-bash">linux@ubuntu：~$ <span class="token function">ls</span> <span class="token variable"><span class="token variable">`</span><span class="token function">pwd</span><span class="token variable">`</span></span>Desktop Examples historycommandlist mywork<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="8-获取联机帮助"><a href="#8-获取联机帮助" class="headerlink" title="8.获取联机帮助"></a>8.获取联机帮助</h3><ul><li><p>man</p><ul><li><p>使用man命令可以找到特定的联机帮助页，并提供简短的命令说明。一般语法格式</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">man</span> commandname<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>联机帮助页提供了指定命令commandname的相关信息，包括：名称、函数、语法以及可选参数描述等。无论帮助有多长，都遵循这个格式显示。在页面很多的情况下使用PageUp和PageDown键翻页。最后，使用“：q”退出帮助页面。</p></li></ul></li></ul><h3 id="9-基本系统维护命令"><a href="#9-基本系统维护命令" class="headerlink" title="9.基本系统维护命令"></a>9.基本系统维护命令</h3><ul><li><p>passwd</p><ul><li>出于系统安全考虑，Linux系统中的每一个帐号都必须同时具备用户名和密码。</li><li>可以使用passwd命令，为已有账户重新修改用户口令。</li><li>需要说明的是，超级用户root可以修改所有其他用户的口令，而普通用户只能修改自己的用户口令，如果确要修改超级用户或其他用户口令的话，需要具有超级用户的权限。</li><li>passwd命令的一般语法格式为：</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">passwd</span> username<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><ul><li><p>su</p><ul><li>su命令用于临时改变用户身份，具有其他用户的权限。普通用户可以使用su命令临时具有超级用户的权限；超级用户也可以使用普通用户身份完成一些操作。当需要放弃当前用户身份，可以使用exit命令切换回来。su命令的一般语法格式为：</li></ul><pre class="line-numbers language-bash"><code class="language-bash">su<span class="token punctuation">[</span>-c<span class="token operator">|</span>-m-<span class="token punctuation">]</span>username<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>选项“-c”表示执行一个命令后就结束；-m表示仍保留环境变量不变；-表示转换用户身份时，同时使用该用户的环境。</li></ul></li><li><p>echo</p><ul><li>echo命令用于在标准输出一—显示器上显示一段文字，一般起到提示作用。echo命令的一般语法格式为：</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token keyword">echo</span> <span class="token punctuation">[</span>-n<span class="token punctuation">]</span> information<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>选项-n表示输出文字后不换行。提示信息字符串可以加引号，也可以不加。</li></ul><pre class="line-numbers language-bash"><code class="language-bash">linux@ubuntu:-Secho<span class="token string">"Hello everyone."</span>#输入信息字符串使用引号Hello everyone.linux@ubuntur-S <span class="token keyword">echo</span> Hello everyone.<span class="token comment" spellcheck="true">#输入信息字符串不使用引号，字符串之间用一个空格隔Hello everyone.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><ul><li><p>date</p><ul><li>date命令用于显示和设置系统日期和时间。date命令的一般语法格式为：</li></ul><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">date</span> <span class="token punctuation">[</span>-d<span class="token operator">|</span>-s-u<span class="token punctuation">]</span> datestr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>选项-s表示按照datestr日期显示格式设置日期；单独使用date命令，用于显示系统时钟中当前日期。时间的格式为：“hh:mm:ss”，日期格式为：“mm/dd/yy”。</li></ul><pre class="line-numbers language-bash"><code class="language-bash">linux@ubuntu:-$ <span class="token function">date</span><span class="token comment" spellcheck="true">#查看当前时间2007年09月16日星期日18：44：45 CST linux@ubuntu:-S sudo date-s 1：19：18#设置新时间，需要系统管理员权限Password：katag</span>2007年09月16日星期日01：19：18CST<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><ul><li><p>clear</p><ul><li>clear命令用于清除屏幕上的信息。清屏后，se11命令提示符移动到屏幕左上角。</li><li>clear命令的一般语法格式为：</li></ul><pre class="line-numbers language-bah"><code class="language-bah">clear                ctrl+l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>由于shell命令是逐行执行，执行结果也将随即显示。因此，用户在使用命令终端窗口时，终端窗口会很快就会被字符占满。clear可以帮助清理一下窗口中杂乱的字符显示。</li></ul></li></ul><ul><li><p>df</p><ul><li>df命令用于查看磁盘空间的使用情况。查看磁盘空间是用户应当经常做的事情，因为谁也不希望看到根或/var分区在不经意间填满，以便及时清理。df命令的一般格式为：</li></ul><pre class="line-numbers language-bash"><code class="language-bash">df<span class="token punctuation">[</span>-al-T<span class="token operator">|</span>-h<span class="token operator">|</span>-k<span class="token punctuation">]</span>Filesystem<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>其中，参数Filesystem表示物理文件系统。各选项的含义如表所示。</p><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P1594728937481.png" alt=""></p></li></ul></li></ul><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="1-etc-passwd文件"><a href="#1-etc-passwd文件" class="headerlink" title="1./etc/passwd文件"></a>1./etc/passwd文件</h3><p>/etc/passwd文件是系统能够识别的用户清单。用户登陆时，系统查询这个文件，确定用户的UID并验证用户口令</p><ul><li>登陆名</li><li>经过加密的口令</li><li>UID</li><li>默认的GID</li><li>个人信息</li><li>主目录</li><li>登陆shell</li></ul><h3 id="2-etc-group文件"><a href="#2-etc-group文件" class="headerlink" title="2./etc/group文件"></a>2./etc/group文件</h3><ul><li>包含了UNIX组的名称和每个组中成员列表</li><li>每一行代表一个组，包括4个字段：<ul><li>组名</li><li>加密的口令</li><li>GID号</li><li>成员列表，彼此用逗号隔开</li></ul></li></ul><h3 id="3-添加用户"><a href="#3-添加用户" class="headerlink" title="3.添加用户"></a>3.添加用户</h3><ul><li><p>adduser<br>语法：adduser  <username><br>实例：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#adduser newuser</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>添加用户名为newuser的新用户</p></li></ul><h3 id="4-添加新用户的过程"><a href="#4-添加新用户的过程" class="headerlink" title="4.添加新用户的过程"></a>4.添加新用户的过程</h3><ul><li>系统<ul><li>编辑passwd和shadow文件，定义用户帐号</li><li>设置一个初始口令</li><li>创建用户主目录，用chown和chmod命令改变主目录的属主和属性</li></ul></li><li>为用户所进行的步骤<ul><li>将默认的启动文件复制到用户主目录中</li><li>设置用户的邮件主目录并建立邮件别名</li></ul></li></ul><h3 id="5-修改用户属性"><a href="#5-修改用户属性" class="headerlink" title="5.修改用户属性"></a>5.修改用户属性</h3><ul><li><p>usermod</p></li><li><p>语法：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">usermod</span> <span class="token punctuation">[</span>-u uid <span class="token punctuation">[</span>-o<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>-g group<span class="token punctuation">]</span><span class="token punctuation">[</span>-G gropup,…<span class="token punctuation">]</span>d home <span class="token punctuation">[</span>-m<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span>-s shel1<span class="token punctuation">]</span><span class="token punctuation">[</span>-c comment<span class="token punctuation">]</span><span class="token punctuation">[</span>-1 new name<span class="token punctuation">]</span><span class="token punctuation">[</span>-f inactive<span class="token punctuation">]</span><span class="token punctuation">[</span>-e expirer<span class="token punctuation">[</span>-p passwd<span class="token punctuation">]</span><span class="token punctuation">[</span>-LI-U<span class="token punctuation">]</span> name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li><p>举例用户oldname改名为newname，注意要同时更改家目录：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">usermod</span> -d/home/newname-m -1 newname oldname<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="6-删除用户"><a href="#6-删除用户" class="headerlink" title="6.删除用户"></a>6.删除用户</h3><ul><li><p>deluser<br>语法：deluser&lt;username〉<br>使用方法：</p><pre class="line-numbers language-bash"><code class="language-bash">deluser--remove-home userl<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>删除用户user1的同时删除用户的工作目录</p></li></ul><h3 id="7-添加用户组"><a href="#7-添加用户组" class="headerlink" title="7.添加用户组"></a>7.添加用户组</h3><ul><li><p>addgroup<br>语法：addgroup groupname.<br>使用方法：</p><pre class="line-numbers language-bash"><code class="language-bash">addgroup groupname<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="1-编译程序上的两个进程"><a href="#1-编译程序上的两个进程" class="headerlink" title="1.编译程序上的两个进程"></a>1.编译程序上的两个进程</h3><p>​        程序的一次执行就是一个进程</p><p>​    <img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P1594730495721.png" alt=""></p><h3 id="2-ps命令"><a href="#2-ps命令" class="headerlink" title="2.ps命令"></a>2.ps命令</h3><ul><li>显示进程（process）的动态</li><li>语法：<pre><code>ps[options]</code></pre></li><li>常见的参数：<ul><li>-A列出所有的进程</li><li>-w显示加宽可以显示较多的资讯</li><li>-au显示较详细的资讯</li><li>-aux显示所有包含其他使用者的进程</li></ul></li></ul><h3 id="3-进程的状态标志"><a href="#3-进程的状态标志" class="headerlink" title="3.进程的状态标志"></a>3.进程的状态标志</h3><ul><li>R：正在执行中</li><li>S：塞状态</li><li>T：暂停我行</li><li>Z：不存在但暂时无法消除</li><li>D：不可中断的静止</li><li>〈：高优先级的进程</li><li>N：低优先级的进程</li><li>L：有内存分页分配并锁在内存中</li></ul><h3 id="4-top命令"><a href="#4-top命令" class="headerlink" title="4.top命令"></a>4.top命令</h3><ul><li>监视进程</li><li>通常会全屏显示，而且会随着进程状态的变化不断更新</li><li>整个系统的信息也会显示，为查找问题提供了便利</li><li>可以显示系统总共有多少CPU和内存资源以及负载平衡等信息。</li></ul><h3 id="5-pstree命令"><a href="#5-pstree命令" class="headerlink" title="5.pstree命令"></a>5.pstree命令</h3><ul><li>将所有行程以树状图显示，树状图将会以pid（如果有指定）或是以init这个基本进程为根，如果有指定使用者id，则树状图会只显示该使用者所拥有的进程。</li></ul><h3 id="6-终止进程"><a href="#6-终止进程" class="headerlink" title="6.终止进程"></a>6.终止进程</h3><ul><li>使用kill命令终止进程<ul><li>kill[-signal]PID </li><li>signal是信号，PID是进程号<br>kill命令向指定的进程发出一个信号signal，在默认的情况下，kill命令向指定进程发出信号15，正常情况下，将杀死那些不捕捉或不忽略这个信号的进程</li></ul></li></ul><h2 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><ul><li>在任何一个操作系统中，文件系统无疑是其最重要的组件，用于组织和管理计算机存储设备上的大量文件，并提供用户交互接口。Linux同样具备完善的文件系统。用户既可以使用界面友好的Nautilus图形文件管理器，也可以使用功能强大的shell文件系统管理工具。</li></ul><h3 id="2-文件系统类型"><a href="#2-文件系统类型" class="headerlink" title="2.文件系统类型"></a>2.文件系统类型</h3><ul><li>linux是一种兼容性很高的操作系统，支持的文件系统格式很多，大体可分以下几类：<ul><li>磁盘文件系统：指本地主机中实际可以访问到的文件系统，包括硬盘、CD-ROM、DVD、USB存储器、磁盘阵列等。常见文件系统格式有：autofs、coda、Ext（Extended File sytem，扩展文件系统）、Ext3、Ext4、VFAT、IS09660（通常是CD-ROM）、UFS（Unix File System，Unix文件系统）、FAT、FAT16、FAT32、NTFS等；</li><li>网络文件系统：是可以远程访问的文件系统，这种文件系统在服务器端仍是本地的磁盘文件系统，客户机通过网络远程访问数据。常见文件系统格式有：NFS、Samba等；</li><li>专有/虚拟文件系统：不驻留在磁盘上的文件系统。常见格式有：TMPFS（临时文件系统）、PROCFS（Process File System，进程文件系统）和LOOPBACKFS（Loopback File System，回送文件系统）。</li></ul></li><li>目前Ext4是Linux系统广泛使用的一种文件格式。在Ext3基础上，对有效性保护、数据完整性、数据访问速度、向下兼容性等方面做了改进。</li><li>最大特点是日志文件系统：可将整个磁盘的写入动作完整地记录在磁盘的某个区域上，以便在必要时回溯追踪。。</li></ul><h3 id="3-SCSI与IDE设备命名"><a href="#3-SCSI与IDE设备命名" class="headerlink" title="3.SCSI与IDE设备命名"></a>3.SCSI与IDE设备命名</h3><ul><li>sata硬盘的设备名称是“/dev/sda”<ul><li>/dev/sdal含义？-/dev/sdb3含义？</li><li>IDE硬盘的设备名称是“/dev/hda”</li><li>/dev/hdc2含义？</li></ul></li><li>如果很在意系统的高性能和稳定性，应该使用SCSI硬盘<ul><li>cat/proc/partitions</li></ul></li></ul><h3 id="4-Linux分区的命名方式"><a href="#4-Linux分区的命名方式" class="headerlink" title="4.Linux分区的命名方式"></a>4.Linux分区的命名方式</h3><ul><li>字母和数字相结合</li><li>前两个字母表示设备类型<ul><li>“hd”代表IDE硬盘</li><li>“sd”表示SCSI或SATA硬盘</li></ul></li><li>第三个字母说明具体的设备<ul><li>“/dev/hda”表示第一个IDE硬盘</li><li>“/dev/hdb”表示第二个IDE硬盘</li></ul></li></ul><h3 id="5-SCSI与IDE设备命名"><a href="#5-SCSI与IDE设备命名" class="headerlink" title="5.SCSI与IDE设备命名"></a>5.SCSI与IDE设备命名</h3><ul><li>sata硬盘的设备名称是“/dev/sda”<ul><li>/dev/sdal含义？.</li><li>/dev/sdb3含义？</li></ul></li><li>IDE硬盘的设备名称是“/dev/hda”<ul><li>/dev/hdc2含义？</li></ul></li><li>如果很在意系统的高性能和稳定性，应该使用SCSI硬盘<ul><li>cat/proc/partitions</li></ul></li></ul><h3 id="6-交换分区"><a href="#6-交换分区" class="headerlink" title="6.交换分区"></a>6.交换分区</h3><ul><li>将内存中的内容写入硬盘或从硬盘中读出，称为内存交换（swapping）</li><li>交换分区最小必须等于计算机的内存</li><li>可以创建多于一个的交换分区</li><li>尽量把交换分区放在硬盘驱动器的起始位置</li></ul><h3 id="7-文件系统逻辑结构"><a href="#7-文件系统逻辑结构" class="headerlink" title="7.文件系统逻辑结构"></a>7.文件系统逻辑结构</h3><ul><li>某所大学的学生可能在一两万人左右，通常将学生分配在以学院-系-班为单位的分层组织机构中。若需要查找一名学生时，最笨的办法是依次问询大学中的每一个学生，直到找到为止。如果按照从学院、到系、再到班的层次查询下去，必然可以找到该学生，且查询效率高。这种树形的分层结构就提供了一种自顶向下的查询方法。</li><li>如果把学生看作文件，院-系-班的组织结构看作是Linux文件目录结构，那么就同样可以有效地管理数量庞大的文件。</li><li>一直使用微软Windows操作系统的用户似乎已经习惯了将硬盘上的几个分区，并用A:、B:、C:、D：等符号标识。存取文件时一定要清楚存放在哪个磁盘的哪个目录下。</li><li>Linux的文件组织模式犹如一颗倒置的树，这与Windows文件系统有很大差别。所有存储设备作为这颗树的一个子目录。存取文件时只需确定目录就可以了，无需考虑物理存储位置。</li></ul><h3 id="8-文件系统结构"><a href="#8-文件系统结构" class="headerlink" title="8.文件系统结构"></a>8.文件系统结构</h3><ul><li>分区与目录的关系：<ul><li>在Windows下，目录结构属于分区；在Linux下，分区属于目录结构。</li></ul></li><li>如何知道文件存储的具体硬件位置呢？<ul><li>在Linux中，将所有硬件都视为文件来处理，包括硬盘分区、CD-ROM、软驱以及其他USB移动设备等。为了能够按照统一的方式和方法访问文件资源，Linux中提供了对每种硬件设备相应的设备文件。一旦Linux系统可以访问到硬件，就将其上的文件系统挂载到目录树中的一个子目录中。</li><li>例如，用户插入USB移动存储器，Ubuntu Linux自动识别后，将其挂载到<br>“/media/disk”目录下。而不象Windows系统将USB存储器作为新驱动器，表示为<br>“F:”盘。</li></ul></li></ul><h3 id="9-file命令"><a href="#9-file命令" class="headerlink" title="9.file命令"></a>9.file命令</h3><ul><li><p>在Linux文件系统中，文件扩展名不总是被使用或被一致地使用。如果一个文件没有扩展名，或者文件与其扩展名不时怎么办呢？file命令功能用于判定一个文件的类型。<br>file命令一般语法格式为：</p><pre class="line-numbers language-bash"><code class="language-bash">file<span class="token punctuation">[</span>filename<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><ul><li><p>其中filename是文件名。命令的输出将显示该文件是二进制文件、文本文件、目录文件、设备文件，还是Linux中其他类型的文件。</p><pre class="line-numbers language-bash"><code class="language-bash">linux@ubuntu:-S file/usr/games/banner banner:ELF 32-bit LSB executable，Intel 80386，version 1（SYSV），for GNU/Linux 2.6.0，dymamically linked（uses shared libs），stripped linux@ubuntu：～S <span class="token function">file</span> Textfile.txt Textfile.txt:UTF-8 Unicode text<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="10-mkdir命令"><a href="#10-mkdir命令" class="headerlink" title="10.mkdir命令"></a>10.mkdir命令</h3><ul><li><p>用于创建一个目录。mkdir命令一般语法格式为：</p><pre class="line-numbers language-bash"><code class="language-bash">mkdir<span class="token punctuation">[</span>-p<span class="token punctuation">]</span>directory_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>其中，directory_name为要创建的目录名，并且不能是已有的目录，通常不允许嵌套创建子目录。</p></li><li><p>使用选项“-p”表示可以嵌套创建子目录，即多层目录。</p></li><li><p>需要说明的是，创建目录的用户在工作目录应具有写入权限。假设要创建下面这样结构的目录。</p><pre class="line-numbers language-bash"><code class="language-bash">dir1dir1/dir2dir1/dir2/dir3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="11-创建链接文件"><a href="#11-创建链接文件" class="headerlink" title="11.创建链接文件"></a>11.创建链接文件</h3><ul><li><p>Linux中有两种类型的链接：</p><ul><li>硬链接是利用Linux中为每个文件分配的物理编号——inode建立链接。因此，硬链接不能跨越文件系统。</li><li>软链接（符号链接）是利用文件的路径名建立链接。通常建立软链接使用绝对路径而不是相对路径，以最大限度增加可移植性。</li></ul></li><li><p>ln命令</p><ul><li><p>命令可以用于创建文件的链接文件。1n命令一般语法格式为：</p><pre class="line-numbers language-bash"><code class="language-bash">ln<span class="token punctuation">[</span>-s<span class="token punctuation">]</span>target link_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li></ul><ul><li><p>其中，选项“-s”表示为创建软链接。在缺省情况下，创建硬链接。参数target为目标文件，1ink name为链接文件名。如果链接文件名已经存在但不是目录，将不做链接。目标文件可以是任何一个文件名，也可以是一个目录。</p><pre class="line-numbers language-bash"><code class="language-bash">linux@ubuntu:-S In-s/proc/cpuinfo mycpuinfo linux@ubuntu:-S Is-1 mycpuinfo wxrwxrwx 1 wdl wdl 13 2007-09-22 00：43mycpuinfo-<span class="token operator">></span>/proc/cpuinfo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="12-文件压缩和归档"><a href="#12-文件压缩和归档" class="headerlink" title="12.文件压缩和归档"></a>12.文件压缩和归档</h3><ul><li><p>用户在进行数据备份时，需要把若干文件整合为一个文件以便保存。尽管整合为一个文件进行管理，但文件大小仍然没变。若需要网络传输文件时，就希望将其压缩成较小的文件，以节省在网络传输的时间。因此本节介绍文件的归档与压缩。</p></li><li><p>归档文件是将一组文件或目录保存在一个文件中。</p></li><li><p>压缩文件也是将一组文件或目录保存一个文件中，并按照某种存储格式保存在磁盘上，所占磁盘空间比其中所有文件总和要少。</p><ul><li>归档文件仍是没有经过压缩的，它所使用的磁盘空间仍等于其所有文件的总和。因而，用户可以将归档文件再进行压缩，使其容量更小。</li><li>gzip是Linux中最流行的压缩工具，具有很好的移植性，可在很多不同架构的系统中使用。bzip2在性能上优于gzip，提供了最大限度的压缩比率。如果用户需要经常在Linux和微软</li></ul></li><li><p>gzip与gunzip命令</p><ul><li><p>与zip明显区别在于只能压缩一个文件，无法将多个文件压缩为一个文件。<br>gzip命令符号模式的一般语法格式为：</p></li><li><p>其中，filename表示要压缩的文件名，gzip会自动在这个文件名后添加扩展名为.gz，作为压缩文件的文件名。</p><pre class="line-numbers language-BASH"><code class="language-BASH">gzip[-l|-d|-num]filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P1594783220660.png" alt=""></p></li><li><p>gunzip命令符号模式的一般语法格式为：</p><pre class="line-numbers language-bash"><code class="language-bash">gunzip <span class="token punctuation">[</span>-f<span class="token punctuation">]</span>file.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-c 函数</title>
      <link href="/2020/071333839.html"/>
      <url>/2020/071333839.html</url>
      
        <content type="html"><![CDATA[<h2 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h2><p>指针函数是指一个函数的返回值为地址量的函数指针函数的定义的一般形式如下</p><pre class="line-numbers language-c"><code class="language-c"><span class="token operator">&lt;</span>数据类型<span class="token operator">></span> <span class="token operator">*</span> <span class="token operator">&lt;</span>函数名称<span class="token operator">></span> （<span class="token operator">&lt;</span>参数说明<span class="token operator">></span>）<span class="token punctuation">{</span>    语句序列；<span class="token punctuation">}</span>返回值：全局变量的地址<span class="token operator">/</span><span class="token keyword">static</span>变量的地址<span class="token operator">/</span>字符串常量的地址<span class="token operator">/</span>堆的地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>下面程序是否有问题，若有问题，如何修改？</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token keyword">char</span><span class="token operator">*</span>mystring（）<span class="token punctuation">{</span>    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//mystring函数执行完，内存释放  </span>    <span class="token comment" spellcheck="true">//static char str[20];</span>    strcpy（str<span class="token punctuation">,</span><span class="token string">"Hello"</span>）<span class="token punctuation">;</span>    <span class="token keyword">return</span> str<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> main（<span class="token keyword">void</span>）<span class="token punctuation">{</span>    printf（<span class="token string">"%s\n"</span><span class="token punctuation">,</span>mystring0）    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//这个程序内存有问题，执行结果是不确定的</span><span class="token comment" spellcheck="true">//解决方法 A：全局变量，静态变量，字符串常量是放在静态工作区</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><ul><li>递归函数是指一个函数的函数体中直接或间接调用了该函数自身</li><li>递归函数调用的执行过程分为两个阶段：<ul><li>递推阶段：从原问题出发，按递归公式递推，从未知到已知，最终达到递归终止条件；</li><li>回归阶段：按递归终止条件求出结果，逆向逐步代入递归公式，回归到门题求解。</li></ul></li></ul><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><ul><li><p>函数指我用来存放函数的地址，这个地址是一个函数的入口地址</p></li><li><p>函数名代表了函数的入口地址</p></li><li><p>函数指针变量说明的一般形式如下</p><pre class="line-numbers language-c"><code class="language-c"><span class="token operator">&lt;</span>数据类型<span class="token operator">></span>（<span class="token operator">*</span><span class="token operator">&lt;</span>函数指针名称<span class="token operator">></span>）（<span class="token operator">&lt;</span>参数说明列表<span class="token operator">></span>）；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>&lt;数据类型&gt;是函数指针所指向的函数的返回值类型</li><li>&lt;参数说明列表&gt;应该与函数指针所指向的函数的形参说明保持一致</li><li>( * &lt;函数指针名称&gt;）中，*说明为指针()不可缺省，表明为函数的指针</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-c  指针</title>
      <link href="/2020/071234787.html"/>
      <url>/2020/071234787.html</url>
      
        <content type="html"><![CDATA[<h2 id="地址和变量"><a href="#地址和变量" class="headerlink" title="地址和变量"></a>地址和变量</h2><ul><li>在计算机内存中，每一个字节单元，都有一个编号，称为地址</li></ul><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><ul><li>在C语言中，内存单元的地址称为指针，专门用来存放地址的变量，称为指针变量在不影响理解的情况中，有时对地址、指针和指针变量不区分，通称指针。</li><li>指针指向的内存区域中的数据称为指针的目标</li><li>如果它指向的区域是程序中的一个变量的内存空间，则这个变量称为指针的目标变量。简称为指针的目标。</li></ul><h3 id="2-指针变量的说明"><a href="#2-指针变量的说明" class="headerlink" title="2.指针变量的说明"></a>2.指针变量的说明</h3><p>  一般形式如下：</p><p>&lt;存储类型&gt;&lt;数据类型&gt;*&lt;指针变量名&gt;；*</p><p>例如，</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span>  pName；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>指针的存储类型是指针变量本身的存储类型。</li><li>指针说明时指定的数据类型不是指针变量本身的数据类型，而是指针目标的数据类型。简称为指针的数据类型。</li></ul><h3 id="3-引入指针"><a href="#3-引入指针" class="headerlink" title="3.引入指针"></a>3.引入指针</h3><p>引入指针要注意程序中的px、*px和&amp;px三种表示方法的不同意义。设px为一个指针，则：</p><ul><li>px-指针变量，它的内容是地址量</li><li>*px一指针所指向的对象，它的内容是数据 int</li><li>&amp;px-指针变量占用的存储区域的地址，是个常量</li></ul><h3 id="4-指针赋值运算"><a href="#4-指针赋值运算" class="headerlink" title="4.指针赋值运算"></a>4.指针赋值运算</h3><ul><li><p>指针的赋值运算指的是通过赋值运算符向指针变量送一个地址值</p></li><li><p>向一个指针变量赋值时，送的值必须是地址常量或指针变量，不能是普通的整数（除了赋零以外）</p><h4 id="指针赋值运算常见的有以下几种形式："><a href="#指针赋值运算常见的有以下几种形式：" class="headerlink" title="指针赋值运算常见的有以下几种形式："></a>指针赋值运算常见的有以下几种形式：</h4></li></ul><p>把一个普通变量的地址赋给一个具有相同数据类型的指针</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">double</span> x<span class="token operator">=</span><span class="token number">15</span>，<span class="token operator">*</span>px；px<span class="token operator">=</span><span class="token operator">&amp;</span>x<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>把一个已有地址值的指针变量赋给具有相同数据类型的另一个指针变量例如：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">float</span> a，<span class="token operator">*</span> px，<span class="token operator">*</span> py；px<span class="token operator">=</span><span class="token operator">&amp;</span>a；py<span class="token operator">=</span>px；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把一个数组的地址赋给具有相同数据类型的指针。例如：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span>，<span class="token operator">*</span>pa；pa<span class="token operator">=</span>a；<span class="token operator">/</span>等价pa<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-指针运算"><a href="#4-指针运算" class="headerlink" title="4.指针运算"></a>4.指针运算</h3><ul><li>指针运算是以指针变量所存放的地址量作为运算量而进行的运算</li><li>指针运算的实质就是地址的计算</li><li>指针运算的种类是有限的，它只能进行赋值运算、算术运算和关系运算</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P0712.png" alt=""></p><h3 id="5-指针与数组"><a href="#5-指针与数组" class="headerlink" title="5.指针与数组"></a>5.指针与数组</h3><ul><li><p>在C语言中，数组的指针是指数组在内存中的起始地址，数组元素的地址是指数组元素在内存中的起始地址</p></li><li><p>一维数组的数组名为一维数组的指针（起始地址）例如</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">double</span> ×<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>  因此，x为x数组的起始地址</p><ul><li><p>设指针变量px的地址值等于数组指针x（即指针变量px指向数组的首元数），则：</p><pre class="line-numbers language-c"><code class="language-c">x<span class="token punctuation">[</span>i<span class="token punctuation">]</span>、 <span class="token operator">*</span> （px<span class="token operator">+</span>i）、<span class="token operator">*</span>（x<span class="token operator">+</span>i）和 px<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>具有完全相同的功能：访问数组第i+1个数组元素。</p></li></ul><h4 id="p-i-lt-gt-p-i"><a href="#p-i-lt-gt-p-i" class="headerlink" title="p[ i ] &lt;=&gt; *(p + i)"></a>p[ i ] &lt;=&gt; *(p + i)</h4><h3 id="6-指针与二维数组"><a href="#6-指针与二维数组" class="headerlink" title="6.指针与二维数组"></a>6.指针与二维数组</h3><ul><li>多维数组就是具有两个或两个以上下标的数组</li><li>在C语言中，二维数组的元素连续存储，按行优先存</li></ul><h4 id="行指针（数组指针）"><a href="#行指针（数组指针）" class="headerlink" title="行指针（数组指针）"></a>行指针（数组指针）</h4><ul><li>存储行地址的指针变量，叫做行指针变量。形式如下：·<ul><li>&lt;存储类型&gt;&lt;数据类型&gt;（ * &lt;指针变量名&gt;）[表达式]；<br>·例如，int a [ 2 ] [ 3 ]；int（*p）[ 3 ]；</li></ul></li><li>方括号中的常量表达式表示指针加1，移动几个数据。</li><li>当用行指针操作二维数组时，表达式一般写成1行的元素个数，即列数。</li></ul><h3 id="7-字符指针与字符串"><a href="#7-字符指针与字符串" class="headerlink" title="7.字符指针与字符串"></a>7.字符指针与字符串</h3><ul><li>C语言通过使用字符数组来处理字符串</li><li>通常，我们把char数据类型的指针变量称为字符指针变量。字符指针变量与字符数组有着密切关系，它也被用来处理拿符串。</li></ul><h3 id="8-指针数组"><a href="#8-指针数组" class="headerlink" title="8.指针数组"></a>8.指针数组</h3><p>所谓指针数组是指由若干个具有相同存储类型和数据类型的指针变量构成的集合</p><p>指针数组的一般说明形式：</p><ul><li>&lt;存储类型&gt;&lt;数据类型&gt;*&lt;指针数组名&gt;[&lt;大小&gt;]；</li><li>指针数组名表示该指针数组的起始地址</li></ul><h3 id="9-多级指针"><a href="#9-多级指针" class="headerlink" title="9.多级指针"></a>9.多级指针</h3><ul><li>多级指针和指针数组</li><li>指针数组也可以用另外一个指针来处理。例如：有一个一维字符指针数组ps[5]，char*ps[5]={“Beijing city”，<br>“London city”}；</li></ul><h3 id="10-void指针"><a href="#10-void指针" class="headerlink" title="10.void指针"></a>10.void指针</h3><ul><li><p>void指针是一种不确定数据类型的指针变量，它可以通过强制类型转换让该变量指向任何数据类型的变量一般形式为：</p><p>void*&lt;指针变量名称&gt;；</p></li><li><p>对于void指针，在没有强制类型转换之前，不能进行任何指针的算术运算</p></li></ul><h3 id="11-const修饰指针"><a href="#11-const修饰指针" class="headerlink" title="11.const修饰指针"></a>11.const修饰指针</h3><ul><li><p>常量化指针目标表达式<br>一般说明形式如下：</p><p>const&lt;数据类型&gt;*&lt;指针变量名称&gt;[=&lt;指针运算表达式&gt;]；</p></li><li><p>常量化指针目标是限制通过指针改变其目标的数值，但&lt;指针变量&gt;存储的地址值可以修改</p></li></ul><ul><li><p>常量化指针变量<br>一般说明形式如下：</p><p>&lt;数据类型&gt;*const&lt;指针变量名称&gt;[=&lt;指针运算表达式&gt;];</p></li></ul><ul><li><p>常量化指针变量及其目标表达式<br>一般说明形式如下：</p></li><li><p>const&lt;数据类型&gt; * const&lt;指针变量名&gt;=&lt;指针运算表达式&gt;；</p><p>常量化指针变量及其目标表达式，使得既不可以修改&lt;指针变量&gt;的地址，也不可以通过*&lt;指针变量名称&gt;修改指针所指向变量的值</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git-实战</title>
      <link href="/2020/070253724.html"/>
      <url>/2020/070253724.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git实战"><a href="#Git实战" class="headerlink" title="Git实战"></a>Git实战</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用普通用户登录到虚拟机</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> <span class="token function">git</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Git在使用之前需要配置用户名和电子邮箱地址，否则不能提交代码。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 配置用户名</span><span class="token function">git</span> config --global user.name <span class="token string">"刘煜"</span><span class="token comment" spellcheck="true"># 配置email</span><span class="token function">git</span> config --global user.email <span class="token string">"liuy_xa@hqyj.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>–global 表示全局配置，对当前用户的所有代码库生效。</p><p>查看配置</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> config --list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>工作目录（working directory）：放代码的目录，在此目录下编辑代码。</p><p>代码库（repository）：保存代码的版本数据库。</p><p>提交（commit）：将工作目录中的代码保存到代码库。</p><p>检出（checkout）：将代码从代码库恢复到工作目录中。</p><p>暂存区（staging area）：相当于购物车，因为一次提交的内容必须是完整的，涉及一个问题或特性修改的所有文件，可以将修改的文件先保存到暂存区，然后统一提交到代码库。</p><h2 id="保存代码"><a href="#保存代码" class="headerlink" title="保存代码"></a>保存代码</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建工作目录</span><span class="token function">mkdir</span> smart_speaker<span class="token comment" spellcheck="true"># 进入工作目录</span><span class="token function">cd</span> smart_speaker<span class="token comment" spellcheck="true"># 创建本地代码库</span><span class="token function">git</span> init<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>工作目录中的<code>.git</code>目录就是本地代码库。</p><p>注意：Linux中以句点开头的目录或文件是隐藏的，需要用<code>ls -a</code>显示。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看工作区状态</span><span class="token function">git</span> status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>未跟踪文件：工作目录中没有保存到代码库的文件。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 将文件修改保存到暂存区</span><span class="token function">git</span> add 文件名/目录名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意：空目录不能添加到暂存区。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 将暂存区的修改提交到代码库</span><span class="token function">git</span> commit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>git commit命令会调用GNU Nano文本编辑器，用户需要在编辑器中填写提交日志，否则不能提交。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 不打开文本编辑器，通过git命令行指定提交日志</span><span class="token function">git</span> commit -m <span class="token string">"提交日志"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提交日志中一般写问题或新特性的编号和名称。</p><h2 id="比较差异"><a href="#比较差异" class="headerlink" title="比较差异"></a>比较差异</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看提交历史记录</span><span class="token function">git</span> log<span class="token comment" spellcheck="true"># 比较版本之间的差异</span><span class="token function">git</span> <span class="token function">diff</span> 提交ID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>提交ID可以使用HEAD别名代替，也可以使用ID的前7字符代替。</p><p>HEAD表示代码库中的最新版本</p><p>HEAD^ 表示最新版本的上一个版本</p><p>HEAD^2 表示最新版本的上2个版本</p><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 将工作目录中的文件恢复为代码库中的最新版本</span><span class="token function">git</span> checkout HEAD <span class="token keyword">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>句点表示要恢复所有文件，如果只恢复一个文件可以把句点换成要恢复的文件名。</p><h2 id="文件重命名和删除"><a href="#文件重命名和删除" class="headerlink" title="文件重命名和删除"></a>文件重命名和删除</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 重命名工作目录中的文件</span><span class="token function">git</span> <span class="token function">mv</span> 原文件名 新文件名<span class="token function">git</span> commit -m <span class="token string">"提交日志"</span><span class="token comment" spellcheck="true"># 删除工作目录中的文件</span><span class="token function">git</span> <span class="token function">rm</span> 文件名<span class="token function">git</span> commit -m <span class="token string">"提交日志"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="远程代码库"><a href="#远程代码库" class="headerlink" title="远程代码库"></a>远程代码库</h2><p>注册码云账号：<a href="https://gitee.com" target="_blank" rel="noopener">https://gitee.com</a></p><h2 id="下载远程代码库"><a href="#下载远程代码库" class="headerlink" title="下载远程代码库"></a>下载远程代码库</h2><p>进入码云的代码库主页，点击<code>克隆/下载</code>按钮，复制远程代码库地址。</p><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/PInkedimage-20200630145414459_LI.jpg" alt=""></p><p>使用<code>git clone</code>命令下载代码库到本地，会在当前目录下创建同名工作目录和本地代码库。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> clone https://gitee.com/hqyjxa/XPU-SmartSpeaker-Lab2020.6.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：PuTTY中选中文本即复制，鼠标右键粘贴。</p><h2 id="同步本地代码库到远程"><a href="#同步本地代码库到远程" class="headerlink" title="同步本地代码库到远程"></a>同步本地代码库到远程</h2><p>在本地工作目录中执行</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> push<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="同步远程代码库到本地"><a href="#同步远程代码库到本地" class="headerlink" title="同步远程代码库到本地"></a>同步远程代码库到本地</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> pull<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="关注和点赞"><a href="#关注和点赞" class="headerlink" title="关注和点赞"></a>关注和点赞</h2><p>用户可以关注某个代码库（点击代码库主页上的watch按钮），对此代码库的所有修改会通知此用户。</p><p>用户可以给代码库点赞（点击代码库主页上的star按钮），此代码库地址会记录到用户的收藏夹中。</p><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/PInkedimage-20200630151130034_LI.jpg" alt=""></p><h2 id="提交PR（Pull-Request）"><a href="#提交PR（Pull-Request）" class="headerlink" title="提交PR（Pull Request）"></a>提交PR（Pull Request）</h2><p>Git代码库一般使用Fork-PR流程实现团队开发。</p><ol><li>点击代码库库主页上的Fork按钮，复制远程代码库到自己的账号。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/Pimage-20200630151712465.png" alt=""></p><ol start="2"><li>用户修改副本代码库中的内容。<ol><li>克隆副本代码库到本地（git clone）</li><li>修改工作目录中的文件</li><li>将工作目录中的修改提交到本地代码库（git add/git commit）</li><li>将本地代码库的修改同步到远程副本代码库中（git push），注意需要输入码云的账号和密码，密码不会回显。</li></ol></li><li>创建PR（Pull Request）</li></ol><p>相当于给主代码库的管理员发送邮件，请求将自己的修改合并到主代码库中。</p><p><img src="F:/%E4%B9%A6%E7%B1%8D/%E4%B8%93%E4%B8%9A/%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0/%E5%8D%8E%E6%B8%85%E8%BF%9C%E8%A7%81%E5%AE%9E%E4%B9%A0%E6%97%A5%E5%BF%97/XPU-SmartSpeaker-Lab2020.6/notes/Git%E5%AE%9E%E6%88%98.assets/image-20200630152843700.png" alt="image-20200630152843700"></p><p>填写PR的标题，描述，然后点击<code>创建</code>按钮。</p><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/Pimage-20200630153329594.png" alt=""></p><p>PR创建后，可以在主代码库的PR列表中看到。</p><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/PInkedimage-20200630153834708_LI.jpg" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/PInkedimage-20200630153926248_LI.jpg" alt=""></p><ol start="4"><li>主代码库管理员，点击<code>合并</code>按钮后，就可以将副本代码库中的修改合并到主代码库中。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/Pimage-20200630154126462.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 仓库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-面试</title>
      <link href="/2020/063047634.html"/>
      <url>/2020/063047634.html</url>
      
        <content type="html"><![CDATA[<hr><h2 id="0625"><a href="#0625" class="headerlink" title="0625"></a>0625</h2><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P0625.jpg" alt=""></h2><h2 id="0626"><a href="#0626" class="headerlink" title="0626"></a>0626</h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P0626.jpg" alt=""></h2><h2 id="0627"><a href="#0627" class="headerlink" title="0627"></a>0627</h2><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P0627.jpg" alt=""></h2><h2 id="0628"><a href="#0628" class="headerlink" title="0628"></a>0628</h2><h2 id="-3"><a href="#-3" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P0628.jpg" alt=""></h2><h2 id="0629"><a href="#0629" class="headerlink" title="0629"></a>0629</h2><h2 id="-4"><a href="#-4" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P0629.jpg" alt=""></h2><h2 id="0701"><a href="#0701" class="headerlink" title="0701"></a>0701</h2><h2 id="-5"><a href="#-5" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P0701.jpg" alt=""></h2><h2 id="0702"><a href="#0702" class="headerlink" title="0702"></a>0702</h2><h2 id="-6"><a href="#-6" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P0702.jpg" alt=""></h2>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-踩雷</title>
      <link href="/2020/062964318.html"/>
      <url>/2020/062964318.html</url>
      
        <content type="html"><![CDATA[<h2 id="下面程序执行的结果是？（-C）"><a href="#下面程序执行的结果是？（-C）" class="headerlink" title="下面程序执行的结果是？（ C）"></a>下面程序执行的结果是？（ C）</h2><pre><code>        boolean b=true;        if(b=false)  //雷区        {            System.out.println(&quot;a&quot;);        }        else if(b)        {            System.out.println(b);            }        else if(!b)        {            System.out.println(&quot;c&quot;);        }        else            System.out.println(&quot;d&quot;); </code></pre><p>A.    a<br>B.true<br>C.    c<br>D.d</p><h3 id="注：’b-false’不是逻辑判断，而是把false赋值给b"><a href="#注：’b-false’不是逻辑判断，而是把false赋值给b" class="headerlink" title="注：’b=false’不是逻辑判断，而是把false赋值给b"></a>注：’b=false’不是逻辑判断，而是把false赋值给b</h3><h2 id="下面程序执行的结果是？（D）"><a href="#下面程序执行的结果是？（D）" class="headerlink" title="下面程序执行的结果是？（D）"></a>下面程序执行的结果是？（D）</h2><pre><code>    int x=2,y=3;    switch(x)    {        default:        y++;        case 3:        y++;        case 4:        y++;    }    System.out.println(&quot;y=&quot;+y);</code></pre><p>A.  3  </p><p>B.  4  </p><p>C.  5  </p><p>D.  6</p><h3 id="注：没有break，顺序执行"><a href="#注：没有break，顺序执行" class="headerlink" title="注：没有break，顺序执行"></a>注：没有break，顺序执行</h3>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day27</title>
      <link href="/2020/062834973.html"/>
      <url>/2020/062834973.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-反射-理解"><a href="#1-反射-理解" class="headerlink" title="1:反射(理解)"></a>1:反射(理解)</h2><h3 id="1-类的加载及类加载器"><a href="#1-类的加载及类加载器" class="headerlink" title="(1)类的加载及类加载器"></a>(1)类的加载及类加载器</h3><h3 id="2-反射："><a href="#2-反射：" class="headerlink" title="(2)反射："></a>(2)反射：</h3><pre><code>    通过字节码文件对象，去使用成员变量，构造方法，成员方法</code></pre><h3 id="3-反射的使用"><a href="#3-反射的使用" class="headerlink" title="(3)反射的使用"></a>(3)反射的使用</h3><pre><code>    A:通过反射获取构造方法并使用    B:通过反射获取成员变量并使用    C:通过反射获取成员方法并使用</code></pre><h3 id="4-反射案例"><a href="#4-反射案例" class="headerlink" title="(4)反射案例"></a>(4)反射案例</h3><pre><code>    A:通过反射运行配置文件的内容    B:通过反射越过泛型检查    C:通过反射给任意的一个对象的任意的属性赋值为指定的值</code></pre><h3 id="5-动态代理"><a href="#5-动态代理" class="headerlink" title="(5)动态代理"></a>(5)动态代理</h3><h2 id="2-设计模式"><a href="#2-设计模式" class="headerlink" title="2:设计模式"></a>2:设计模式</h2><h3 id="1-装饰设计模式"><a href="#1-装饰设计模式" class="headerlink" title="(1)装饰设计模式"></a>(1)装饰设计模式</h3><pre><code>    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));    Scanner sc = new Scanner(System.in);</code></pre><h3 id="2-模版设计模式"><a href="#2-模版设计模式" class="headerlink" title="(2)模版设计模式"></a>(2)模版设计模式</h3><h2 id="3-JDK新特性"><a href="#3-JDK新特性" class="headerlink" title="3:JDK新特性"></a>3:JDK新特性</h2><h3 id="1-JDK5-掌握"><a href="#1-JDK5-掌握" class="headerlink" title="(1)JDK5(掌握)"></a>(1)JDK5(掌握)</h3><pre><code>    装箱和拆箱    泛型    增强for    静态导入    可变参数    枚举</code></pre><h3 id="2-JDK6-了解"><a href="#2-JDK6-了解" class="headerlink" title="(2)JDK6(了解)"></a>(2)JDK6(了解)</h3><h3 id="3-JDK7-理解"><a href="#3-JDK7-理解" class="headerlink" title="(3)JDK7(理解)"></a>(3)JDK7(理解)</h3><pre><code>    二进制的表现形式    用_分隔数据    switch语句可是用字符串    泛型推断(菱形泛型)    多catch的使用    自动释放资源的用法</code></pre><h3 id="4-JDK8-了解"><a href="#4-JDK8-了解" class="headerlink" title="(4)JDK8(了解)"></a>(4)JDK8(了解)</h3><pre><code>    可以去网上了解资料</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-异常处理</title>
      <link href="/2020/062858003.html"/>
      <url>/2020/062858003.html</url>
      
        <content type="html"><![CDATA[<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>很多事件并非总是按照人们自己设计意愿顺利发展<br>的， 而是有能够出现这样那样的异常情况。 例如：<br>你计划周末郊游， 你的计划会安排满满的， 你计划<br>可能是这样的： 从家里出发→到达目的→游泳→烧<br>烤→回家。 但天有不测风云， 当前你准备烧烤时候<br>天降大雨， 你只能终止郊游提前回家。 “天降大<br>雨”是一种异常情况， 你的计划应该考虑到这样情<br>况， 并且应该有处理这种异常的预案。<br>为增强程序的健壮性， 计算机程序的编写也需要考<br>虑处理这些异常情况， Java语言提供了异常处理功<br>能， 本章介绍Java异常处理机制。   </p><h2 id="从一个问题开始"><a href="#从一个问题开始" class="headerlink" title="从一个问题开始"></a>从一个问题开始</h2><p>为了学习Java异常处理机制， 首先看看下面程序。</p><pre><code>//HelloWorld.java文件package com.a51work6;public class HelloWorld {    public static void main(String[] args) {    int a = 0;    System.out.println(5 / a);    }} </code></pre><p>这个程序没有编译错误， 但会发生如下的运行时错误：</p><pre><code>Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zeat com.a51work6.HelloWorld.main(HelloWorld.java:9)</code></pre><p>在数学上除数不能为0， 所以程序运行时表达式（5 / a） 会抛出ArithmeticException异常，ArithmeticException是数学计算异常， 凡是发生数<br>学计算错误都会抛出该异常。程序运行过程中难免会发生异常， 发生异常并不可<br>怕， 程序员应该考虑到有可能发生这些异常， 编程<br>时应该捕获并进行处理异常， 不能让程序发生终<br>止， 这就是健壮的程序。    </p><hr><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P%E5%BC%82%E5%B8%B8%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%B1%82%E6%AC%A1.jpg" alt="异常类继承层次">    </p><p>（Java从小白到大牛 509）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day26</title>
      <link href="/2020/062718524.html"/>
      <url>/2020/062718524.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-网络编程-理解"><a href="#1-网络编程-理解" class="headerlink" title="1:网络编程(理解)"></a>1:网络编程(理解)</h2><h3 id="1-网络编程：用Java语言实现计算机间数据的信息传递和资源共享"><a href="#1-网络编程：用Java语言实现计算机间数据的信息传递和资源共享" class="headerlink" title="(1)网络编程：用Java语言实现计算机间数据的信息传递和资源共享"></a>(1)网络编程：用Java语言实现计算机间数据的信息传递和资源共享</h3><h3 id="2-网络编程模型"><a href="#2-网络编程模型" class="headerlink" title="(2)网络编程模型"></a>(2)网络编程模型</h3><h3 id="3-网络编程的三要素"><a href="#3-网络编程的三要素" class="headerlink" title="(3)网络编程的三要素"></a>(3)网络编程的三要素</h3><h4 id="A-IP地址"><a href="#A-IP地址" class="headerlink" title="A:IP地址"></a>A:IP地址</h4><pre><code>        a:点分十进制        b:IP地址的组成        c:IP地址的分类        d:dos命令        e:InetAddress</code></pre><h4 id="B-端口"><a href="#B-端口" class="headerlink" title="B:端口"></a>B:端口</h4><pre><code>        是应用程序的标识。范围：0-65535。其中0-1024不建议使用。</code></pre><h4 id="C-协议"><a href="#C-协议" class="headerlink" title="C:协议"></a>C:协议</h4><pre><code>        UDP:数据打包,有限制,不连接,效率高,不可靠        TCP:建立数据通道,无限制,效率低,可靠</code></pre><h3 id="3-Socket机制"><a href="#3-Socket机制" class="headerlink" title="(3)Socket机制"></a>(3)Socket机制</h3><h4 id="A-通信两端都应该有Socket对象"><a href="#A-通信两端都应该有Socket对象" class="headerlink" title="A:通信两端都应该有Socket对象"></a>A:通信两端都应该有Socket对象</h4><h4 id="B-所有的通信都是通过Socket间的IO进行操作的"><a href="#B-所有的通信都是通过Socket间的IO进行操作的" class="headerlink" title="B:所有的通信都是通过Socket间的IO进行操作的"></a>B:所有的通信都是通过Socket间的IO进行操作的</h4><h3 id="4-UDP协议发送和接收数据-掌握-自己补齐代码"><a href="#4-UDP协议发送和接收数据-掌握-自己补齐代码" class="headerlink" title="(4)UDP协议发送和接收数据(掌握 自己补齐代码)"></a>(4)UDP协议发送和接收数据(掌握 自己补齐代码)</h3><h4 id="发送："><a href="#发送：" class="headerlink" title="发送："></a>发送：</h4><p>/*</p><ul><li><p>UDP协议发送数据：</p></li><li><p>A:创建发送端Socket对象</p></li><li><p>B:创建数据，并把数据打包</p></li><li><p>C:调用Socket对象的发送方法发送数据包</p></li><li><p>D:释放资源</p></li><li><p>/  </p><pre><code>  // 创建发送端Socket对象  // DatagramSocket()  DatagramSocket ds = new DatagramSocket();  // 创建数据，并把数据打包  // DatagramPacket(byte[] buf, int length, InetAddress address, int port)  // 创建数据  byte[] bys = &quot;hello,udp,我来了&quot;.getBytes();  // 长度  int length = bys.length;  // IP地址对象  InetAddress address = InetAddress.getByName(&quot;192.168.12.92&quot;);  // 端口  int port = 10086;  DatagramPacket dp = new DatagramPacket(bys, length, address, port);  // 调用Socket对象的发送方法发送数据包  // public void send(DatagramPacket p)  ds.send(dp);  // 释放资源  ds.close();</code></pre></li></ul><h4 id="接收："><a href="#接收：" class="headerlink" title="接收："></a>接收：</h4><p>/*</p><ul><li><p>UDP协议接收数据：</p></li><li><p>A:创建接收端Socket对象</p></li><li><p>B:创建一个数据包(接收容器)</p></li><li><p>C:调用Socket对象的接收方法接收数据</p></li><li><p>D:解析数据包，并显示在控制台</p></li><li><p>E:释放资源</p></li><li><p>/  </p><pre><code>  // 创建接收端Socket对象  // DatagramSocket(int port)  DatagramSocket ds = new DatagramSocket(10086);  // 创建一个数据包(接收容器)  // DatagramPacket(byte[] buf, int length)  byte[] bys = new byte[1024];  int length = bys.length;  DatagramPacket dp = new DatagramPacket(bys, length);  // 调用Socket对象的接收方法接收数据  // public void receive(DatagramPacket p)  ds.receive(dp); // 阻塞式  // 解析数据包，并显示在控制台  // 获取对方的ip  // public InetAddress getAddress()  InetAddress address = dp.getAddress();  String ip = address.getHostAddress();  // public byte[] getData():获取数据缓冲区  // public int getLength():获取数据的实际长度  byte[] bys2 = dp.getData();  int len = dp.getLength();  String s = new String(bys2, 0, len);  System.out.println(ip + &quot;传递的数据是:&quot; + s);  // 释放资源  ds.close();</code></pre><h3 id="5-TCP协议发送和接收数据-掌握-自己补齐代码"><a href="#5-TCP协议发送和接收数据-掌握-自己补齐代码" class="headerlink" title="(5)TCP协议发送和接收数据(掌握 自己补齐代码)"></a>(5)TCP协议发送和接收数据(掌握 自己补齐代码)</h3><h4 id="发送：-1"><a href="#发送：-1" class="headerlink" title="发送："></a>发送：</h4><p>/*</p></li><li><p>TCP协议发送数据：</p></li><li><p>A:创建发送端的Socket对象</p></li><li><p>这一步如果成功，就说明连接已经建立成功了。</p></li><li><p>B:获取输出流，写数据</p></li><li><p>C:释放资源</p></li><li></li><li><p>连接被拒绝。TCP协议一定要先看服务器。</p></li><li><p>java.net.ConnectException: Connection refused: connect</p></li><li><p>/  </p><pre><code>  // 创建发送端的Socket对象  // Socket(InetAddress address, int port)  // Socket(String host, int port)  // Socket s = new Socket(InetAddress.getByName(&quot;192.168.12.92&quot;), 8888);  Socket s = new Socket(&quot;192.168.12.92&quot;, 8888);  // 获取输出流，写数据  // public OutputStream getOutputStream()  OutputStream os = s.getOutputStream();  os.write(&quot;hello,tcp,我来了&quot;.getBytes());  // 释放资源  s.close();</code></pre></li></ul><h4 id="接收：-1"><a href="#接收：-1" class="headerlink" title="接收："></a>接收：</h4><p>/*</p><ul><li><p>TCP协议接收数据：</p></li><li><p>A:创建接收端的Socket对象</p></li><li><p>B:监听客户端连接。返回一个对应的Socket对象</p></li><li><p>C:获取输入流，读取数据显示在控制台</p></li><li><p>D:释放资源</p></li><li><p>/  </p><pre><code>  // 创建接收端的Socket对象  // ServerSocket(int port)  ServerSocket ss = new ServerSocket(8888);  // 监听客户端连接。返回一个对应的Socket对象  // public Socket accept()  Socket s = ss.accept(); // 侦听并接受到此套接字的连接。此方法在连接传入之前一直阻塞。  // 获取输入流，读取数据显示在控制台  InputStream is = s.getInputStream();  byte[] bys = new byte[1024];  int len = is.read(bys); // 阻塞式方法  String str = new String(bys, 0, len);  String ip = s.getInetAddress().getHostAddress();  System.out.println(ip + &quot;---&quot; + str);  // 释放资源  s.close();  // ss.close(); //这个不应该关闭 </code></pre><h3 id="6-案例："><a href="#6-案例：" class="headerlink" title="(6)案例："></a>(6)案例：</h3><h4 id="A-UDP"><a href="#A-UDP" class="headerlink" title="A:UDP"></a>A:UDP</h4><pre><code>      a:最基本的UDP协议发送和接收数据      b:把发送数据改进为键盘录入      c:一个简易聊天小程序并用多线程改进</code></pre><h4 id="B-TCP"><a href="#B-TCP" class="headerlink" title="B:TCP"></a>B:TCP</h4><pre><code>      a:最基本的TCP协议发送和接收数据      b:服务器给出反馈      c:客户端键盘录入服务器控制台输出      d:客户端键盘录入服务器写到文本文件      e:客户端读取文本文件服务器控制台输出      f:客户端读取文本文件服务器写到文本文件      g:上传图片      h:多线程改进上传文件</code></pre><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/PUDP%E5%8D%8F%E8%AE%AE%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A7%A3.bmp" alt="UDP协议发送和接收数据图解"></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/PTCP%E5%8D%8F%E8%AE%AE%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A7%A3.bmp" alt="TCP协议发送和接收数据图解"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day25</title>
      <link href="/2020/062618716.html"/>
      <url>/2020/062618716.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-如何让Netbeans的东西Eclipse能访问。"><a href="#1-如何让Netbeans的东西Eclipse能访问。" class="headerlink" title="1:如何让Netbeans的东西Eclipse能访问。"></a>1:如何让Netbeans的东西Eclipse能访问。</h2><pre><code>在Eclipse中创建项目，把Netbeans项目的src下的东西给拿过来即可。注意：修改项目编码为UTF-8</code></pre><h2 id="2-GUI-了解"><a href="#2-GUI-了解" class="headerlink" title="2:GUI(了解)"></a>2:GUI(了解)</h2><h3 id="1-用户图形界面"><a href="#1-用户图形界面" class="headerlink" title="(1)用户图形界面"></a>(1)用户图形界面</h3><pre><code>    GUI:方便直观    CLI:需要记忆一下命令，麻烦</code></pre><h3 id="2-两个包："><a href="#2-两个包：" class="headerlink" title="(2)两个包："></a>(2)两个包：</h3><pre><code>    java.awt:和系统关联较强    javax.swing:纯Java编写</code></pre><h3 id="3-GUI的继承体系"><a href="#3-GUI的继承体系" class="headerlink" title="(3)GUI的继承体系"></a>(3)GUI的继承体系</h3><pre><code>    组件：组件就是对象        容器组件：是可以存储基本组件和容器组件的组件。        基本组件：是可以使用的组件，但是必须依赖容器。</code></pre><h3 id="4-事件监听机制-理解"><a href="#4-事件监听机制-理解" class="headerlink" title="(4)事件监听机制(理解)"></a>(4)事件监听机制(理解)</h3><h4 id="A-事件源"><a href="#A-事件源" class="headerlink" title="A:事件源"></a>A:事件源</h4><h4 id="B-事件"><a href="#B-事件" class="headerlink" title="B:事件"></a>B:事件</h4><h4 id="C-事件处理"><a href="#C-事件处理" class="headerlink" title="C:事件处理"></a>C:事件处理</h4><h4 id="D-事件监听"><a href="#D-事件监听" class="headerlink" title="D:事件监听"></a>D:事件监听</h4><h3 id="5-适配器模式-理解"><a href="#5-适配器模式-理解" class="headerlink" title="(5)适配器模式(理解)"></a>(5)适配器模式(理解)</h3><h4 id="A-接口"><a href="#A-接口" class="headerlink" title="A:接口"></a>A:接口</h4><h4 id="B-抽象适配器类"><a href="#B-抽象适配器类" class="headerlink" title="B:抽象适配器类"></a>B:抽象适配器类</h4><h4 id="C-实现类"><a href="#C-实现类" class="headerlink" title="C:实现类"></a>C:实现类</h4><h3 id="6-案例："><a href="#6-案例：" class="headerlink" title="(6)案例："></a>(6)案例：</h3><h4 id="A-创建窗体案例"><a href="#A-创建窗体案例" class="headerlink" title="A:创建窗体案例"></a>A:创建窗体案例</h4><h4 id="B-窗体关闭案例"><a href="#B-窗体关闭案例" class="headerlink" title="B:窗体关闭案例"></a>B:窗体关闭案例</h4><h4 id="C-窗体添加按钮并对按钮添加事件案例。"><a href="#C-窗体添加按钮并对按钮添加事件案例。" class="headerlink" title="C:窗体添加按钮并对按钮添加事件案例。"></a>C:窗体添加按钮并对按钮添加事件案例。</h4><pre><code>        界面中的组件布局。</code></pre><h4 id="D-把文本框里面的数据转移到文本域"><a href="#D-把文本框里面的数据转移到文本域" class="headerlink" title="D:把文本框里面的数据转移到文本域"></a>D:把文本框里面的数据转移到文本域</h4><h4 id="E-更改背景色"><a href="#E-更改背景色" class="headerlink" title="E:更改背景色"></a>E:更改背景色</h4><h4 id="F-设置文本框里面不能输入非数字字符"><a href="#F-设置文本框里面不能输入非数字字符" class="headerlink" title="F:设置文本框里面不能输入非数字字符"></a>F:设置文本框里面不能输入非数字字符</h4><h4 id="G-一级菜单"><a href="#G-一级菜单" class="headerlink" title="G:一级菜单"></a>G:一级菜单</h4><h4 id="H-多级菜单"><a href="#H-多级菜单" class="headerlink" title="H:多级菜单"></a>H:多级菜单</h4><h3 id="7-Netbeans的概述和使用"><a href="#7-Netbeans的概述和使用" class="headerlink" title="(7)Netbeans的概述和使用"></a>(7)Netbeans的概述和使用</h3><h4 id="A-是可以做Java开发的另一个IDE工具。"><a href="#A-是可以做Java开发的另一个IDE工具。" class="headerlink" title="A:是可以做Java开发的另一个IDE工具。"></a>A:是可以做Java开发的另一个IDE工具。</h4><h4 id="B-使用"><a href="#B-使用" class="headerlink" title="B:使用"></a>B:使用</h4><pre><code>        A:四则运算            a:修改图标            b:设置皮肤            c:设置居中            d:数据校验</code></pre><h4 id="B-登录注册"><a href="#B-登录注册" class="headerlink" title="B:登录注册"></a>B:登录注册</h4>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day24</title>
      <link href="/2020/062535293.html"/>
      <url>/2020/062535293.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-多线程-理解"><a href="#1-多线程-理解" class="headerlink" title="1:多线程(理解)"></a>1:多线程(理解)</h2><h3 id="1-JDK5以后的针对线程的锁定操作和释放操作"><a href="#1-JDK5以后的针对线程的锁定操作和释放操作" class="headerlink" title="(1)JDK5以后的针对线程的锁定操作和释放操作"></a>(1)JDK5以后的针对线程的锁定操作和释放操作</h3><pre><code>    Lock锁</code></pre><h3 id="2-死锁问题的描述和代码体现"><a href="#2-死锁问题的描述和代码体现" class="headerlink" title="(2)死锁问题的描述和代码体现"></a>(2)死锁问题的描述和代码体现</h3><h3 id="3-生产者和消费者多线程体现-线程间通信问题"><a href="#3-生产者和消费者多线程体现-线程间通信问题" class="headerlink" title="(3)生产者和消费者多线程体现(线程间通信问题)"></a>(3)生产者和消费者多线程体现(线程间通信问题)</h3><pre><code>    以学生作为资源来实现的    资源类：Student    设置数据类：SetThread(生产者)    获取数据类：GetThread(消费者)    测试类：StudentDemo    代码：        A:最基本的版本，只有一个数据。        B:改进版本，给出了不同的数据，并加入了同步机制        C:等待唤醒机制改进该程序，让数据能够实现依次的出现            wait()            notify()            notifyAll() (多生产多消费)        D:等待唤醒机制的代码优化。把数据及操作都写在了资源类中</code></pre><h3 id="4-线程组"><a href="#4-线程组" class="headerlink" title="(4)线程组"></a>(4)线程组</h3><h3 id="5-线程池"><a href="#5-线程池" class="headerlink" title="(5)线程池"></a>(5)线程池</h3><h3 id="6-多线程实现的第三种方案"><a href="#6-多线程实现的第三种方案" class="headerlink" title="(6)多线程实现的第三种方案"></a>(6)多线程实现的第三种方案</h3><h3 id="7-多线程的面试题"><a href="#7-多线程的面试题" class="headerlink" title="(7)多线程的面试题"></a>(7)多线程的面试题</h3><h2 id="2-设计模式-理解"><a href="#2-设计模式-理解" class="headerlink" title="2:设计模式(理解)"></a>2:设计模式(理解)</h2><h3 id="1-面试对象的常见设计原则"><a href="#1-面试对象的常见设计原则" class="headerlink" title="(1)面试对象的常见设计原则"></a>(1)面试对象的常见设计原则</h3><pre><code>    单一    开闭    里氏    依赖注入    接口    迪米特</code></pre><h3 id="2-设计模式概述和分类"><a href="#2-设计模式概述和分类" class="headerlink" title="(2)设计模式概述和分类"></a>(2)设计模式概述和分类</h3><h4 id="A-经验的总结"><a href="#A-经验的总结" class="headerlink" title="A:经验的总结"></a>A:经验的总结</h4><h4 id="B-三类"><a href="#B-三类" class="headerlink" title="B:三类"></a>B:三类</h4><pre><code>        创建型        结构型        行为型</code></pre><h3 id="3-改进的设计模式"><a href="#3-改进的设计模式" class="headerlink" title="(3)改进的设计模式"></a>(3)改进的设计模式</h3><h4 id="A-简单工厂模式"><a href="#A-简单工厂模式" class="headerlink" title="A:简单工厂模式"></a>A:简单工厂模式</h4><h4 id="B-工厂方法模式"><a href="#B-工厂方法模式" class="headerlink" title="B:工厂方法模式"></a>B:工厂方法模式</h4><h4 id="C-单例模式-掌握"><a href="#C-单例模式-掌握" class="headerlink" title="C:单例模式(掌握)"></a>C:单例模式(掌握)</h4><pre><code>        a:饿汉式        b:懒汉式</code></pre><h3 id="4-Runtime"><a href="#4-Runtime" class="headerlink" title="(4)Runtime"></a>(4)Runtime</h3><pre><code>    JDK提供的一个单例模式应用的类。    还可以调用dos命令。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day23</title>
      <link href="/2020/062419356.html"/>
      <url>/2020/062419356.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-多线程-理解"><a href="#1-多线程-理解" class="headerlink" title="1:多线程(理解)"></a>1:多线程(理解)</h2><h3 id="1-多线程：一个应用程序有多条执行路径"><a href="#1-多线程：一个应用程序有多条执行路径" class="headerlink" title="(1)多线程：一个应用程序有多条执行路径"></a>(1)多线程：一个应用程序有多条执行路径</h3><pre><code>    进程：正在执行的应用程序    线程：进程的执行单元，执行路径    单线程：一个应用程序只有一条执行路径    多线程：一个应用程序有多条执行路径    多进程的意义?        提高CPU的使用率    多线程的意义?        提高应用程序的使用率</code></pre><h3 id="2-Java程序的运行原理及JVM的启动是多线程的吗"><a href="#2-Java程序的运行原理及JVM的启动是多线程的吗" class="headerlink" title="(2)Java程序的运行原理及JVM的启动是多线程的吗?"></a>(2)Java程序的运行原理及JVM的启动是多线程的吗?</h3><pre><code>    A:Java命令去启动JVM，JVM会启动一个进程，该进程会启动一个主线程。    B:JVM的启动是多线程的，因为它最低有两个线程启动了，主线程和垃圾回收线程。</code></pre><h3 id="3-多线程的实现方案-自己补齐步骤及代码-掌握"><a href="#3-多线程的实现方案-自己补齐步骤及代码-掌握" class="headerlink" title="(3)多线程的实现方案(自己补齐步骤及代码    掌握)"></a>(3)多线程的实现方案(自己补齐步骤及代码    掌握)</h3><h4 id="A-继承Thread类"><a href="#A-继承Thread类" class="headerlink" title="A:继承Thread类"></a>A:继承Thread类</h4><h4 id="B-实现Runnable接口"><a href="#B-实现Runnable接口" class="headerlink" title="B:实现Runnable接口"></a>B:实现Runnable接口</h4><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E5%9B%BE%E8%A7%A3%E6%AF%94%E8%BE%83%E5%8F%8A%E5%8C%BA%E5%88%AB.bmp" alt=""></p><h3 id="4-线程的调度和优先级问题"><a href="#4-线程的调度和优先级问题" class="headerlink" title="(4)线程的调度和优先级问题"></a>(4)线程的调度和优先级问题</h3><h4 id="A-线程的调度"><a href="#A-线程的调度" class="headerlink" title="A:线程的调度"></a>A:线程的调度</h4><pre><code>        a:分时调度        b:抢占式调度 (Java采用的是该调度方式)</code></pre><h4 id="B-获取和设置线程优先级"><a href="#B-获取和设置线程优先级" class="headerlink" title="B:获取和设置线程优先级"></a>B:获取和设置线程优先级</h4><pre><code>        a:默认是5        b:范围是1-10</code></pre><h3 id="5-线程的控制-常见方法"><a href="#5-线程的控制-常见方法" class="headerlink" title="(5)线程的控制(常见方法)"></a>(5)线程的控制(常见方法)</h3><h4 id="A-休眠线程"><a href="#A-休眠线程" class="headerlink" title="A:休眠线程"></a>A:休眠线程</h4><h4 id="B-加入线程"><a href="#B-加入线程" class="headerlink" title="B:加入线程"></a>B:加入线程</h4><h4 id="C-礼让线程"><a href="#C-礼让线程" class="headerlink" title="C:礼让线程"></a>C:礼让线程</h4><h4 id="D-后台线程"><a href="#D-后台线程" class="headerlink" title="D:后台线程"></a>D:后台线程</h4><h4 id="E-终止线程-掌握"><a href="#E-终止线程-掌握" class="headerlink" title="E:终止线程(掌握)"></a>E:终止线程(掌握)</h4><h3 id="6-线程的生命周期-参照-线程生命周期图解-bmp"><a href="#6-线程的生命周期-参照-线程生命周期图解-bmp" class="headerlink" title="(6)线程的生命周期(参照    线程生命周期图解.bmp)"></a>(6)线程的生命周期(参照    线程生命周期图解.bmp)</h3><h4 id="A-新建"><a href="#A-新建" class="headerlink" title="A:新建"></a>A:新建</h4><h4 id="B-就绪"><a href="#B-就绪" class="headerlink" title="B:就绪"></a>B:就绪</h4><h4 id="C-运行"><a href="#C-运行" class="headerlink" title="C:运行"></a>C:运行</h4><h4 id="D-阻塞"><a href="#D-阻塞" class="headerlink" title="D:阻塞"></a>D:阻塞</h4><h4 id="E-死亡"><a href="#E-死亡" class="headerlink" title="E:死亡"></a>E:死亡</h4><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E8%A7%A3.bmp" alt=""></p><h3 id="7-电影院卖票程序的实现"><a href="#7-电影院卖票程序的实现" class="headerlink" title="(7)电影院卖票程序的实现"></a>(7)电影院卖票程序的实现</h3><h4 id="A-继承Thread类-1"><a href="#A-继承Thread类-1" class="headerlink" title="A:继承Thread类"></a>A:继承Thread类</h4><h4 id="B-实现Runnable接口-1"><a href="#B-实现Runnable接口-1" class="headerlink" title="B:实现Runnable接口"></a>B:实现Runnable接口</h4><h3 id="8-电影院卖票程序出问题"><a href="#8-电影院卖票程序出问题" class="headerlink" title="(8)电影院卖票程序出问题"></a>(8)电影院卖票程序出问题</h3><pre><code>    A:为了更符合真实的场景，加入了休眠100毫秒。    B:卖票问题        a:同票多次        b:负数票</code></pre><h3 id="9-多线程安全问题的原因-也是我们以后判断一个程序是否有线程安全问题的依据"><a href="#9-多线程安全问题的原因-也是我们以后判断一个程序是否有线程安全问题的依据" class="headerlink" title="(9)多线程安全问题的原因(也是我们以后判断一个程序是否有线程安全问题的依据)"></a>(9)多线程安全问题的原因(也是我们以后判断一个程序是否有线程安全问题的依据)</h3><h4 id="A-是否有多线程环境"><a href="#A-是否有多线程环境" class="headerlink" title="A:是否有多线程环境"></a>A:是否有多线程环境</h4><h4 id="B-是否有共享数据"><a href="#B-是否有共享数据" class="headerlink" title="B:是否有共享数据"></a>B:是否有共享数据</h4><h4 id="C-是否有多条语句操作共享数据"><a href="#C-是否有多条语句操作共享数据" class="headerlink" title="C:是否有多条语句操作共享数据"></a>C:是否有多条语句操作共享数据</h4><h3 id="10-同步解决线程安全问题"><a href="#10-同步解决线程安全问题" class="headerlink" title="(10)同步解决线程安全问题"></a>(10)同步解决线程安全问题</h3><h4 id="A-同步代码块"><a href="#A-同步代码块" class="headerlink" title="A:同步代码块"></a>A:同步代码块</h4><pre><code>        synchronized(对象) {            需要被同步的代码;        }        这里的锁对象可以是任意对象。</code></pre><h4 id="B-同步方法"><a href="#B-同步方法" class="headerlink" title="B:同步方法"></a>B:同步方法</h4><pre><code>        把同步加在方法上。        这里的锁对象是this</code></pre><h4 id="C-静态同步方法"><a href="#C-静态同步方法" class="headerlink" title="C:静态同步方法"></a>C:静态同步方法</h4><pre><code>        把同步加在方法上。        这里的锁对象是当前类的字节码文件对象(反射再讲字节码文件对象)</code></pre><h3 id="11-回顾以前的线程安全的类"><a href="#11-回顾以前的线程安全的类" class="headerlink" title="(11)回顾以前的线程安全的类"></a>(11)回顾以前的线程安全的类</h3><h4 id="A-StringBuffer"><a href="#A-StringBuffer" class="headerlink" title="A:StringBuffer"></a>A:StringBuffer</h4><h4 id="B-Vector"><a href="#B-Vector" class="headerlink" title="B:Vector"></a>B:Vector</h4><h4 id="C-Hashtable"><a href="#C-Hashtable" class="headerlink" title="C:Hashtable"></a>C:Hashtable</h4><h4 id="D-如何把一个线程不安全的集合类变成一个线程安全的集合类"><a href="#D-如何把一个线程不安全的集合类变成一个线程安全的集合类" class="headerlink" title="D:如何把一个线程不安全的集合类变成一个线程安全的集合类"></a>D:如何把一个线程不安全的集合类变成一个线程安全的集合类</h4><pre><code>        用Collections工具类的方法即可。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day22</title>
      <link href="/2020/062335677.html"/>
      <url>/2020/062335677.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-登录注册IO版本案例-掌握"><a href="#1-登录注册IO版本案例-掌握" class="headerlink" title="1:登录注册IO版本案例(掌握)"></a>1:登录注册IO版本案例(掌握)</h2><pre><code>要求，对着写一遍。cn.itcast.pojo Usercn.itcast.dao UserDaocn.itcast.dao.impl UserDaoImpl(实现我不管)cn.itcast.game GuessNumbercn.itcast.test    UserTest</code></pre><h2 id="2-数据操作流-操作基本类型数据的流-理解"><a href="#2-数据操作流-操作基本类型数据的流-理解" class="headerlink" title="2:数据操作流(操作基本类型数据的流)(理解)"></a>2:数据操作流(操作基本类型数据的流)(理解)</h2><h3 id="1-可以操作基本类型的数据"><a href="#1-可以操作基本类型的数据" class="headerlink" title="(1)可以操作基本类型的数据"></a>(1)可以操作基本类型的数据</h3><p>333    (2)流对象名称<br>        DataInputStream<br>        DataOutputStream</p><h2 id="3-内存操作流-理解"><a href="#3-内存操作流-理解" class="headerlink" title="3:内存操作流(理解)"></a>3:内存操作流(理解)</h2><h3 id="1-有些时候我们操作完毕后，未必需要产生一个文件，就可以使用内存操作流。"><a href="#1-有些时候我们操作完毕后，未必需要产生一个文件，就可以使用内存操作流。" class="headerlink" title="(1)有些时候我们操作完毕后，未必需要产生一个文件，就可以使用内存操作流。"></a>(1)有些时候我们操作完毕后，未必需要产生一个文件，就可以使用内存操作流。</h3><h3 id="2-三种"><a href="#2-三种" class="headerlink" title="(2)三种"></a>(2)三种</h3><pre><code>    A:ByteArrayInputStream,ByteArrayOutputStream    B:CharArrayReader,CharArrayWriter    C:StringReader,StringWriter</code></pre><h2 id="4-打印流-掌握"><a href="#4-打印流-掌握" class="headerlink" title="4:打印流(掌握)"></a>4:打印流(掌握)</h2><h3 id="1-字节打印流，字符打印流"><a href="#1-字节打印流，字符打印流" class="headerlink" title="(1)字节打印流，字符打印流"></a>(1)字节打印流，字符打印流</h3><h3 id="2-特点："><a href="#2-特点：" class="headerlink" title="(2)特点："></a>(2)特点：</h3><h4 id="A-只操作目的地-不操作数据源"><a href="#A-只操作目的地-不操作数据源" class="headerlink" title="A:只操作目的地,不操作数据源"></a>A:只操作目的地,不操作数据源</h4><h4 id="B-可以操作任意类型的数据"><a href="#B-可以操作任意类型的数据" class="headerlink" title="B:可以操作任意类型的数据"></a>B:可以操作任意类型的数据</h4><h4 id="C-如果启用了自动刷新，在调用println-方法的时候，能够换行并刷新"><a href="#C-如果启用了自动刷新，在调用println-方法的时候，能够换行并刷新" class="headerlink" title="C:如果启用了自动刷新，在调用println()方法的时候，能够换行并刷新"></a>C:如果启用了自动刷新，在调用println()方法的时候，能够换行并刷新</h4><h4 id="D-可以直接操作文件"><a href="#D-可以直接操作文件" class="headerlink" title="D:可以直接操作文件"></a>D:可以直接操作文件</h4><pre><code>        问题：哪些流可以直接操作文件呢?        看API，如果其构造方法能够同时接收File和String类型的参数，一般都是可以直接操作文件的</code></pre><h3 id="3-复制文本文件"><a href="#3-复制文本文件" class="headerlink" title="(3)复制文本文件"></a>(3)复制文本文件</h3><pre><code>    BufferedReader br = new BufferedReader(new FileReader(&quot;a.txt&quot;));    PrintWriter pw = new PrintWriter(new FileWriter(&quot;b.txt&quot;),true);    String line = null;    while((line=br.readLine())!=null) {        pw.println(line);    }    pw.close();    br.close();</code></pre><h2 id="5-标准输入输出流-理解"><a href="#5-标准输入输出流-理解" class="headerlink" title="5:标准输入输出流(理解)"></a>5:标准输入输出流(理解)</h2><h3 id="1-System类下面有这样的两个字段"><a href="#1-System类下面有这样的两个字段" class="headerlink" title="(1)System类下面有这样的两个字段"></a>(1)System类下面有这样的两个字段</h3><pre><code>    in 标准输入流    out 标准输出流</code></pre><h3 id="2-三种键盘录入方式"><a href="#2-三种键盘录入方式" class="headerlink" title="(2)三种键盘录入方式"></a>(2)三种键盘录入方式</h3><h4 id="A-main方法的args接收参数"><a href="#A-main方法的args接收参数" class="headerlink" title="A:main方法的args接收参数"></a>A:main方法的args接收参数</h4><h4 id="B-System-in通过BufferedReader进行包装"><a href="#B-System-in通过BufferedReader进行包装" class="headerlink" title="B:System.in通过BufferedReader进行包装"></a>B:System.in通过BufferedReader进行包装</h4><pre><code>        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));</code></pre><h4 id="C-Scanner"><a href="#C-Scanner" class="headerlink" title="C:Scanner"></a>C:Scanner</h4><pre><code>        Scanner sc = new Scanner(System.in);</code></pre><h3 id="3-输出语句的原理和如何使用字符流输出数据"><a href="#3-输出语句的原理和如何使用字符流输出数据" class="headerlink" title="(3)输出语句的原理和如何使用字符流输出数据"></a>(3)输出语句的原理和如何使用字符流输出数据</h3><h4 id="A-原理"><a href="#A-原理" class="headerlink" title="A:原理"></a>A:原理</h4><pre><code>        System.out.println(&quot;helloworld&quot;);        PrintStream ps = System.out;        ps.println(&quot;helloworld&quot;);</code></pre><h4 id="B-把System-out用字符缓冲流包装一下使用"><a href="#B-把System-out用字符缓冲流包装一下使用" class="headerlink" title="B:把System.out用字符缓冲流包装一下使用"></a>B:把System.out用字符缓冲流包装一下使用</h4><pre><code>        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));</code></pre><h2 id="6-随机访问流-理解"><a href="#6-随机访问流-理解" class="headerlink" title="6:随机访问流(理解)"></a>6:随机访问流(理解)</h2><h3 id="1-可以按照文件指针的位置写数据和读数据。"><a href="#1-可以按照文件指针的位置写数据和读数据。" class="headerlink" title="(1)可以按照文件指针的位置写数据和读数据。"></a>(1)可以按照文件指针的位置写数据和读数据。</h3><h3 id="2-案例："><a href="#2-案例：" class="headerlink" title="(2)案例："></a>(2)案例：</h3><h4 id="A-写数据"><a href="#A-写数据" class="headerlink" title="A:写数据"></a>A:写数据</h4><h4 id="B-读数据"><a href="#B-读数据" class="headerlink" title="B:读数据"></a>B:读数据</h4><h4 id="C-获取和改变文件指针的位置"><a href="#C-获取和改变文件指针的位置" class="headerlink" title="C:获取和改变文件指针的位置"></a>C:获取和改变文件指针的位置</h4><h2 id="7-合并流-理解"><a href="#7-合并流-理解" class="headerlink" title="7:合并流(理解)"></a>7:合并流(理解)</h2><h3 id="1-把多个输入流的数据写到一个输出流中。"><a href="#1-把多个输入流的数据写到一个输出流中。" class="headerlink" title="(1)把多个输入流的数据写到一个输出流中。"></a>(1)把多个输入流的数据写到一个输出流中。</h3><h3 id="2-构造方法："><a href="#2-构造方法：" class="headerlink" title="(2)构造方法："></a>(2)构造方法：</h3><pre><code>    A:SequenceInputStream(InputStream s1, InputStream s2)     B:SequenceInputStream(Enumeration&lt;? extends InputStream&gt; e) </code></pre><h2 id="8-序列化流-理解"><a href="#8-序列化流-理解" class="headerlink" title="8:序列化流(理解)"></a>8:序列化流(理解)</h2><h3 id="1-可以把对象写入文本文件或者在网络中传输"><a href="#1-可以把对象写入文本文件或者在网络中传输" class="headerlink" title="(1)可以把对象写入文本文件或者在网络中传输"></a>(1)可以把对象写入文本文件或者在网络中传输</h3><h3 id="2-如何实现序列化呢"><a href="#2-如何实现序列化呢" class="headerlink" title="(2)如何实现序列化呢?"></a>(2)如何实现序列化呢?</h3><pre><code>    让被序列化的对象所属类实现序列化接口。    该接口是一个标记接口。没有功能需要实现。</code></pre><h3 id="3-注意问题："><a href="#3-注意问题：" class="headerlink" title="(3)注意问题："></a>(3)注意问题：</h3><pre><code>    把数据写到文件后，在去修改类会产生一个问题。    如何解决该问题呢?        在类文件中，给出一个固定的序列化id值。        而且，这样也可以解决黄色警告线问题</code></pre><h3 id="4-面试题："><a href="#4-面试题：" class="headerlink" title="(4)面试题："></a>(4)面试题：</h3><pre><code>    什么时候序列化?    如何实现序列化?    什么是反序列化?</code></pre><h2 id="9-Properties-理解"><a href="#9-Properties-理解" class="headerlink" title="9:Properties(理解)"></a>9:Properties(理解)</h2><h3 id="1-是一个集合类，Hashtable的子类"><a href="#1-是一个集合类，Hashtable的子类" class="headerlink" title="(1)是一个集合类，Hashtable的子类"></a>(1)是一个集合类，Hashtable的子类</h3><h3 id="2-特有功能"><a href="#2-特有功能" class="headerlink" title="(2)特有功能"></a>(2)特有功能</h3><pre><code>    A:public Object setProperty(String key,String value)    B:public String getProperty(String key)    C:public Set&lt;String&gt; stringPropertyNames()</code></pre><h3 id="3-和IO流结合的方法"><a href="#3-和IO流结合的方法" class="headerlink" title="(3)和IO流结合的方法"></a>(3)和IO流结合的方法</h3><pre><code>    把键值对形式的文本文件内容加载到集合中    public void load(Reader reader)    public void load(InputStream inStream)    把集合中的数据存储到文本文件中    public void store(Writer writer,String comments)    public void store(OutputStream out,String comments)</code></pre><h3 id="4-案例："><a href="#4-案例：" class="headerlink" title="(4)案例："></a>(4)案例：</h3><pre><code>    A:根据给定的文件判断是否有键为&quot;lisi&quot;的，如果有就修改其值为100    B:写一个程序实现控制猜数字小游戏程序不能玩超过5次</code></pre><h2 id="10-NIO-了解"><a href="#10-NIO-了解" class="headerlink" title="10:NIO(了解)"></a>10:NIO(了解)</h2><h3 id="1-JDK4出现的NIO，对以前的IO操作进行了优化，提供了效率。但是大部分我们看到的还是以前的IO"><a href="#1-JDK4出现的NIO，对以前的IO操作进行了优化，提供了效率。但是大部分我们看到的还是以前的IO" class="headerlink" title="(1)JDK4出现的NIO，对以前的IO操作进行了优化，提供了效率。但是大部分我们看到的还是以前的IO"></a>(1)JDK4出现的NIO，对以前的IO操作进行了优化，提供了效率。但是大部分我们看到的还是以前的IO</h3><h3 id="2-JDK7的NIO的使用"><a href="#2-JDK7的NIO的使用" class="headerlink" title="(2)JDK7的NIO的使用"></a>(2)JDK7的NIO的使用</h3><pre><code>    Path:路径    Paths:通过静态方法返回一个路径    Files:提供了常见的功能        复制文本文件        把集合中的数据写到文本文件</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day21</title>
      <link href="/2020/062235357.html"/>
      <url>/2020/062235357.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-字符流-掌握"><a href="#1-字符流-掌握" class="headerlink" title="1:字符流(掌握)"></a>1:字符流(掌握)</h2><h3 id="1-字节流操作中文数据不是特别的方便，所以就出现了转换流。"><a href="#1-字节流操作中文数据不是特别的方便，所以就出现了转换流。" class="headerlink" title="(1)字节流操作中文数据不是特别的方便，所以就出现了转换流。"></a>(1)字节流操作中文数据不是特别的方便，所以就出现了转换流。</h3><pre><code>   转换流的作用就是把字节流转换字符流来使用。</code></pre><h3 id="2-转换流其实是一个字符流"><a href="#2-转换流其实是一个字符流" class="headerlink" title="(2)转换流其实是一个字符流"></a>(2)转换流其实是一个字符流</h3><pre><code>    字符流 = 字节流 + 编码表</code></pre><h3 id="3-编码表"><a href="#3-编码表" class="headerlink" title="(3)编码表"></a>(3)编码表</h3><h4 id="A-就是由字符和对应的数值组成的一张表"><a href="#A-就是由字符和对应的数值组成的一张表" class="headerlink" title="A:就是由字符和对应的数值组成的一张表"></a>A:就是由字符和对应的数值组成的一张表</h4><h4 id="B-常见的编码表"><a href="#B-常见的编码表" class="headerlink" title="B:常见的编码表"></a>B:常见的编码表</h4><pre><code>        ASCII        ISO-8859-1        GB2312        GBK        GB18030        UTF-8</code></pre><h4 id="C-字符串中的编码问题"><a href="#C-字符串中的编码问题" class="headerlink" title="C:字符串中的编码问题"></a>C:字符串中的编码问题</h4><pre><code>        编码            String -- byte[]        解码            byte[] -- String</code></pre><h3 id="4-IO流中的编码问题"><a href="#4-IO流中的编码问题" class="headerlink" title="(4)IO流中的编码问题"></a>(4)IO流中的编码问题</h3><h4 id="A-OutputStreamWriter"><a href="#A-OutputStreamWriter" class="headerlink" title="A:OutputStreamWriter"></a>A:OutputStreamWriter</h4><pre><code>        OutputStreamWriter(OutputStream os):默认编码，GBK        OutputStreamWriter(OutputStream os,String charsetName):指定编码。</code></pre><h4 id="B-InputStreamReader"><a href="#B-InputStreamReader" class="headerlink" title="B:InputStreamReader"></a>B:InputStreamReader</h4><pre><code>        InputStreamReader(InputStream is):默认编码，GBK        InputStreamReader(InputStream is,String charsetName):指定编码</code></pre><h4 id="C-编码问题其实很简单"><a href="#C-编码问题其实很简单" class="headerlink" title="C:编码问题其实很简单"></a>C:编码问题其实很简单</h4><pre><code>        编码只要一致即可</code></pre><h3 id="5-字符流"><a href="#5-字符流" class="headerlink" title="(5)字符流"></a>(5)字符流</h3><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><pre><code>        |--InputStreamReader            |--FileReader        |--BufferedReader</code></pre><h4 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h4><pre><code>        |--OutputStreamWriter            |--FileWriter        |--BufferedWriter</code></pre><h3 id="6-复制文本文件-5种方式"><a href="#6-复制文本文件-5种方式" class="headerlink" title="(6)复制文本文件(5种方式)"></a>(6)复制文本文件(5种方式)</h3><h2 id="2-IO流小结-掌握"><a href="#2-IO流小结-掌握" class="headerlink" title="2:IO流小结(掌握)"></a>2:IO流小结(掌握)</h2><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><h4 id="–字节流"><a href="#–字节流" class="headerlink" title="|–字节流"></a>|–字节流</h4><pre><code>        |--字节输入流            InputStream                int read():一次读取一个字节                int read(byte[] bys):一次读取一个字节数组                |--FileInputStream                |--BufferedInputStream        |--字节输出流            OutputStream                void write(int by):一次写一个字节                void write(byte[] bys,int index,int len):一次写一个字节数组的一部分                |--FileOutputStream                |--BufferedOutputStream</code></pre><h4 id="–字符流"><a href="#–字符流" class="headerlink" title="|–字符流"></a>|–字符流</h4><pre><code>        |--字符输入流            Reader                int read():一次读取一个字符                int read(char[] chs):一次读取一个字符数组                |--InputStreamReader                    |--FileReader                |--BufferedReader                    String readLine():一次读取一个字符串        |--字符输出流            Writer                void write(int ch):一次写一个字符                void write(char[] chs,int index,int len):一次写一个字符数组的一部分                |--OutputStreamWriter                    |--FileWriter                |--BufferedWriter                    void newLine():写一个换行符                    void write(String line):一次写一个字符串</code></pre><h2 id="3-案例-理解-练习一遍"><a href="#3-案例-理解-练习一遍" class="headerlink" title="3:案例(理解 练习一遍)"></a>3:案例(理解 练习一遍)</h2><pre><code>A:复制文本文件 5种方式(掌握)B:复制图片(二进制流数据) 4种方式(掌握)C:把集合中的数据存储到文本文件D:把文本文件中的数据读取到集合并遍历集合E:复制单级文件夹F:复制单级文件夹中指定的文件并修改名称    回顾一下批量修改名称G:复制多级文件夹H:键盘录入学生信息按照总分从高到低存储到文本文件I:把某个文件中的字符串排序后输出到另一个文本文件中J:用Reader模拟BufferedReader的特有功能K:模拟LineNumberReader的特有功能</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day20</title>
      <link href="/2020/062119164.html"/>
      <url>/2020/062119164.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-递归-理解"><a href="#1-递归-理解" class="headerlink" title="1:递归(理解)"></a>1:递归(理解)</h2><h3 id="1-方法定义中调用方法本身的现象"><a href="#1-方法定义中调用方法本身的现象" class="headerlink" title="(1)方法定义中调用方法本身的现象"></a>(1)方法定义中调用方法本身的现象</h3><pre><code>    举例：老和尚给小和尚讲故事，我们学编程</code></pre><h3 id="2-递归的注意事项；"><a href="#2-递归的注意事项；" class="headerlink" title="(2)递归的注意事项；"></a>(2)递归的注意事项；</h3><h4 id="A-要有出口，否则就是死递归"><a href="#A-要有出口，否则就是死递归" class="headerlink" title="A:要有出口，否则就是死递归"></a>A:要有出口，否则就是死递归</h4><h4 id="B-次数不能过多，否则内存溢出"><a href="#B-次数不能过多，否则内存溢出" class="headerlink" title="B:次数不能过多，否则内存溢出"></a>B:次数不能过多，否则内存溢出</h4><h4 id="C-构造方法不能递归使用"><a href="#C-构造方法不能递归使用" class="headerlink" title="C:构造方法不能递归使用"></a>C:构造方法不能递归使用</h4><h3 id="3-递归的案例："><a href="#3-递归的案例：" class="headerlink" title="(3)递归的案例："></a>(3)递归的案例：</h3><h4 id="A-递归求阶乘"><a href="#A-递归求阶乘" class="headerlink" title="A:递归求阶乘"></a>A:递归求阶乘</h4><h4 id="B-兔子问题"><a href="#B-兔子问题" class="headerlink" title="B:兔子问题"></a>B:兔子问题</h4><h4 id="C-递归输出指定目录下所有指定后缀名的文件绝对路径"><a href="#C-递归输出指定目录下所有指定后缀名的文件绝对路径" class="headerlink" title="C:递归输出指定目录下所有指定后缀名的文件绝对路径"></a>C:递归输出指定目录下所有指定后缀名的文件绝对路径</h4><h4 id="D-递归删除带内容的目录-小心使用"><a href="#D-递归删除带内容的目录-小心使用" class="headerlink" title="D:递归删除带内容的目录(小心使用)"></a>D:递归删除带内容的目录(小心使用)</h4><h2 id="2-IO流-掌握"><a href="#2-IO流-掌握" class="headerlink" title="2:IO流(掌握)"></a>2:IO流(掌握)</h2><h3 id="1-IO用于在设备间进行数据传输的操作"><a href="#1-IO用于在设备间进行数据传输的操作" class="headerlink" title="(1)IO用于在设备间进行数据传输的操作"></a>(1)IO用于在设备间进行数据传输的操作</h3><h3 id="2-分类："><a href="#2-分类：" class="headerlink" title="(2)分类："></a>(2)分类：</h3><h4 id="A-流向"><a href="#A-流向" class="headerlink" title="A:流向"></a>A:流向</h4><pre><code>        输入流    读取数据        输出流    写出数据</code></pre><h4 id="B-数据类型"><a href="#B-数据类型" class="headerlink" title="B:数据类型"></a>B:数据类型</h4><pre><code>        字节流                    字节输入流                字节输出流        字符流                字符输入流                字符输出流</code></pre><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><pre><code>        a:如果我们没有明确说明按照什么分，默认按照数据类型分。        b:除非文件用windows自带的记事本打开我们能够读懂，才采用字符流，否则建议使用字节流。</code></pre><h3 id="3-FileOutputStream写出数据"><a href="#3-FileOutputStream写出数据" class="headerlink" title="(3)FileOutputStream写出数据"></a>(3)FileOutputStream写出数据</h3><h4 id="A-操作步骤"><a href="#A-操作步骤" class="headerlink" title="A:操作步骤"></a>A:操作步骤</h4><pre><code>        a:创建字节输出流对象        b:调用write()方法        c:释放资源</code></pre><h4 id="B-代码体现："><a href="#B-代码体现：" class="headerlink" title="B:代码体现："></a>B:代码体现：</h4><pre><code>        FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);        fos.write(&quot;hello&quot;.getBytes());        fos.close();</code></pre><h4 id="C-要注意的问题"><a href="#C-要注意的问题" class="headerlink" title="C:要注意的问题?"></a>C:要注意的问题?</h4><pre><code>        a:创建字节输出流对象做了几件事情?        b:为什么要close()?        c:如何实现数据的换行?        d:如何实现数据的追加写入?</code></pre><h3 id="4-FileInputStream读取数据"><a href="#4-FileInputStream读取数据" class="headerlink" title="(4)FileInputStream读取数据"></a>(4)FileInputStream读取数据</h3><h4 id="A-操作步骤-1"><a href="#A-操作步骤-1" class="headerlink" title="A:操作步骤"></a>A:操作步骤</h4><pre><code>        a:创建字节输入流对象        b:调用read()方法        c:释放资源</code></pre><h4 id="B-代码体现：-1"><a href="#B-代码体现：-1" class="headerlink" title="B:代码体现："></a>B:代码体现：</h4><pre><code>        FileInputStream fis = new FileInputStream(&quot;fos.txt&quot;);        //方式1        int by = 0;        while((by=fis.read())!=-1) {            System.out.print((char)by);        }        //方式2        byte[] bys = new byte[1024];        int len = 0;        while((len=fis.read(bys))!=-1) {            System.out.print(new String(bys,0,len));        }        fis.close();</code></pre><h3 id="5-案例：2种实现"><a href="#5-案例：2种实现" class="headerlink" title="(5)案例：2种实现"></a>(5)案例：2种实现</h3><h4 id="A-复制文本文件"><a href="#A-复制文本文件" class="headerlink" title="A:复制文本文件"></a>A:复制文本文件</h4><h4 id="B-复制图片"><a href="#B-复制图片" class="headerlink" title="B:复制图片"></a>B:复制图片</h4><h4 id="C-复制视频"><a href="#C-复制视频" class="headerlink" title="C:复制视频"></a>C:复制视频</h4><h3 id="6-字节缓冲区流"><a href="#6-字节缓冲区流" class="headerlink" title="(6)字节缓冲区流"></a>(6)字节缓冲区流</h3><h4 id="A-BufferedOutputStream"><a href="#A-BufferedOutputStream" class="headerlink" title="A:BufferedOutputStream"></a>A:BufferedOutputStream</h4><h4 id="B-BufferedInputStream"><a href="#B-BufferedInputStream" class="headerlink" title="B:BufferedInputStream"></a>B:BufferedInputStream</h4><h3 id="7-案例：4种实现"><a href="#7-案例：4种实现" class="headerlink" title="(7)案例：4种实现"></a>(7)案例：4种实现</h3><h4 id="A-复制文本文件-1"><a href="#A-复制文本文件-1" class="headerlink" title="A:复制文本文件"></a>A:复制文本文件</h4><h4 id="B-复制图片-1"><a href="#B-复制图片-1" class="headerlink" title="B:复制图片"></a>B:复制图片</h4><h4 id="C-复制视频-1"><a href="#C-复制视频-1" class="headerlink" title="C:复制视频"></a>C:复制视频</h4><h2 id="3-自学字符流"><a href="#3-自学字符流" class="headerlink" title="3:自学字符流"></a>3:自学字符流</h2><h3 id="IO流分类"><a href="#IO流分类" class="headerlink" title="IO流分类"></a>IO流分类</h3><h4 id="字节流："><a href="#字节流：" class="headerlink" title="字节流："></a>字节流：</h4><pre><code>        InputStream            FileInputStream            BufferedInputStream        OutputStream            FileOutputStream            BufferedOutputStream</code></pre><h4 id="字符流："><a href="#字符流：" class="headerlink" title="字符流："></a>字符流：</h4><pre><code>        Reader            FileReader            BufferedReader        Writer            FileWriter            BufferedWriter</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day19</title>
      <link href="/2020/062048156.html"/>
      <url>/2020/062048156.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-异常-理解"><a href="#1-异常-理解" class="headerlink" title="1:异常(理解)"></a>1:异常(理解)</h2><h3 id="1-程序出现的不正常的情况。"><a href="#1-程序出现的不正常的情况。" class="headerlink" title="(1)程序出现的不正常的情况。"></a>(1)程序出现的不正常的情况。</h3><h3 id="2-异常的体系"><a href="#2-异常的体系" class="headerlink" title="(2)异常的体系"></a>(2)异常的体系</h3><pre><code>    Throwable        |--Error    严重问题，我们不处理。        |--Exception            |--RuntimeException    运行期异常，我们需要修正代码            |--非RuntimeException 编译期异常，必须处理的，否则程序编译不通过</code></pre><h3 id="3-异常的处理："><a href="#3-异常的处理：" class="headerlink" title="(3)异常的处理："></a>(3)异常的处理：</h3><h4 id="A-JVM的默认处理"><a href="#A-JVM的默认处理" class="headerlink" title="A:JVM的默认处理"></a>A:JVM的默认处理</h4><pre><code>        把异常的名称,原因,位置等信息输出在控制台，但是呢程序不能继续执行了。</code></pre><h4 id="B-自己处理"><a href="#B-自己处理" class="headerlink" title="B:自己处理"></a>B:自己处理</h4><pre><code>        a:try...catch...finally            自己编写处理代码,后面的程序可以继续执行        b:throws            把自己处理不了的，在方法上声明，告诉调用者，这里有问题</code></pre><h3 id="4-面试题"><a href="#4-面试题" class="headerlink" title="(4)面试题"></a>(4)面试题</h3><h4 id="A-编译期异常和运行期异常的区别"><a href="#A-编译期异常和运行期异常的区别" class="headerlink" title="A:编译期异常和运行期异常的区别?"></a>A:编译期异常和运行期异常的区别?</h4><pre><code>        编译期异常 必须要处理的，否则编译不通过        运行期异常 可以不处理，也可以处理</code></pre><h4 id="B-throw和throws是的区别"><a href="#B-throw和throws是的区别" class="headerlink" title="B:throw和throws是的区别"></a>B:throw和throws是的区别</h4><pre><code>        throw:            在方法体中,后面跟的是异常对象名,并且只能是一个            throw抛出的是一个异常对象，说明这里肯定有一个异常产生了        throws:            在方法声明上,后面跟的是异常的类名,可以是多个            throws是声明方法有异常，是一种可能性，这个异常并不一定会产生</code></pre><h3 id="5-finally关键字及其面试题"><a href="#5-finally关键字及其面试题" class="headerlink" title="(5)finally关键字及其面试题"></a>(5)finally关键字及其面试题</h3><h4 id="A-finally用于释放资源，它的代码永远会执行。特殊情况：在执行到finally之前jvm退出了"><a href="#A-finally用于释放资源，它的代码永远会执行。特殊情况：在执行到finally之前jvm退出了" class="headerlink" title="A:finally用于释放资源，它的代码永远会执行。特殊情况：在执行到finally之前jvm退出了"></a>A:finally用于释放资源，它的代码永远会执行。特殊情况：在执行到finally之前jvm退出了</h4><h4 id="B-面试题"><a href="#B-面试题" class="headerlink" title="B:面试题"></a>B:面试题</h4><pre><code>        a:final,finally,finalize的区别?        b:如果在catch里面有return,请问finally还执行吗?如果执行,在return前还是后            会，前。            实际上在中间。这个上课我们讲过</code></pre><h4 id="C-异常处理的变形"><a href="#C-异常处理的变形" class="headerlink" title="C:异常处理的变形"></a>C:异常处理的变形</h4><pre><code>        try...catch...finally        try...catch...        try...catch...catch...        try...catch...catch...fianlly        try...finally</code></pre><h3 id="6-自定义异常"><a href="#6-自定义异常" class="headerlink" title="(6)自定义异常"></a>(6)自定义异常</h3><pre><code>    继承自Exception或者RuntimeException,只需要提供无参构造和一个带参构造即可</code></pre><h3 id="7-异常的注意实现"><a href="#7-异常的注意实现" class="headerlink" title="(7)异常的注意实现"></a>(7)异常的注意实现</h3><pre><code>    A:父的方法有异常抛出,子的重写方法在抛出异常的时候必须要小于等于父的异常     B:父的方法没有异常抛出,子的重写方法不能有异常抛出    C:父的方法抛出多个异常,子的重写方法必须比父少或者小</code></pre><h2 id="2-File-掌握"><a href="#2-File-掌握" class="headerlink" title="2:File(掌握)"></a>2:File(掌握)</h2><h3 id="1-IO流操作中大部分都是对文件的操作，所以Java就提供了File类供我们来操作文件"><a href="#1-IO流操作中大部分都是对文件的操作，所以Java就提供了File类供我们来操作文件" class="headerlink" title="(1)IO流操作中大部分都是对文件的操作，所以Java就提供了File类供我们来操作文件"></a>(1)IO流操作中大部分都是对文件的操作，所以Java就提供了File类供我们来操作文件</h3><h3 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="(2)构造方法"></a>(2)构造方法</h3><pre><code>    A:File file = new File(&quot;e:\\demo\\a.txt&quot;);    B:File file = new File(&quot;e:\\demo&quot;,&quot;a.txt&quot;);    C:File file = new File(&quot;e:\\demo&quot;);      File file2 = new File(file,&quot;a.txt&quot;);</code></pre><h3 id="3-File类的功能-自己补齐"><a href="#3-File类的功能-自己补齐" class="headerlink" title="(3)File类的功能(自己补齐)"></a>(3)File类的功能(自己补齐)</h3><h4 id="A-创建功能"><a href="#A-创建功能" class="headerlink" title="A:创建功能"></a>A:创建功能</h4><pre><code>    public boolean createNewFile():创建文件 如果存在这样的文件，就不创建了    public boolean mkdir():创建文件夹 如果存在这样的文件夹，就不创建了    public boolean mkdirs():创建文件夹,如果父文件夹不存在，会帮你创建出来</code></pre><ul><li><p>骑白马的不一定是王子，可能是班长。  </p></li><li><p>注意：你到底要创建文件还是文件夹，你最清楚，方法不要调错了。</p><h4 id="B-删除功能"><a href="#B-删除功能" class="headerlink" title="B:删除功能"></a>B:删除功能</h4><pre><code> public boolean delete()</code></pre></li><li></li><li><p>注意：</p></li><li><p>A:如果你创建文件或者文件夹忘了写盘符路径，那么，默认在项目路径下。</p></li><li><p>B:Java中的删除不走回收站。</p></li><li><p>C:要删除一个文件夹，请注意该文件夹内不能包含文件或者文件夹</p></li></ul><h4 id="C-重命名功能"><a href="#C-重命名功能" class="headerlink" title="C:重命名功能"></a>C:重命名功能</h4><pre><code>    public boolean renameTo(File dest)</code></pre><ul><li>如果路径名相同，就是改名。</li><li>如果路径名不同，就是改名并剪切。</li><li></li><li>路径以盘符开始：绝对路径    c:\a.txt</li><li>路径不以盘符开始：相对路径    a.txt</li></ul><h4 id="D-判断功能"><a href="#D-判断功能" class="headerlink" title="D:判断功能"></a>D:判断功能</h4><pre><code>public boolean isDirectory():判断是否是目录public boolean isFile():判断是否是文件public boolean exists():判断是否存在public boolean canRead():判断是否可读public boolean canWrite():判断是否可写public boolean isHidden():判断是否隐藏</code></pre><h4 id="E-获取功能"><a href="#E-获取功能" class="headerlink" title="E:获取功能"></a>E:获取功能</h4><pre><code>public String[] list():获取指定目录下的所有文件或者文件夹的名称数组public File[] listFiles():获取指定目录下的所有文件或者文件夹的File数组</code></pre><h4 id="F-高级获取功能"><a href="#F-高级获取功能" class="headerlink" title="F:高级获取功能"></a>F:高级获取功能</h4><h4 id="G-过滤器功能"><a href="#G-过滤器功能" class="headerlink" title="G:过滤器功能"></a>G:过滤器功能</h4><h3 id="4-案例："><a href="#4-案例：" class="headerlink" title="(4)案例："></a>(4)案例：</h3><h4 id="A-输出指定目录下指定后缀名的文件名称"><a href="#A-输出指定目录下指定后缀名的文件名称" class="headerlink" title="A:输出指定目录下指定后缀名的文件名称"></a>A:输出指定目录下指定后缀名的文件名称</h4><pre><code>        a:先获取所有的，在遍历的时候判断，再输出        b:先判断，再获取，最后直接遍历输出即可</code></pre><h4 id="B-批量修改文件名称"><a href="#B-批量修改文件名称" class="headerlink" title="B:批量修改文件名称"></a>B:批量修改文件名称</h4>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day18</title>
      <link href="/2020/061931965.html"/>
      <url>/2020/061931965.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Map-掌握"><a href="#1-Map-掌握" class="headerlink" title="1:Map(掌握)"></a>1:Map(掌握)</h2><h3 id="1-将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。"><a href="#1-将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。" class="headerlink" title="(1)将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。"></a>(1)将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。</h3><h3 id="2-Map和Collection的区别"><a href="#2-Map和Collection的区别" class="headerlink" title="(2)Map和Collection的区别?"></a>(2)Map和Collection的区别?</h3><pre><code>    A:Map 存储的是键值对形式的元素，键唯一，值可以重复。夫妻对    B:Collection 存储的是单独出现的元素，子接口Set元素唯一，子接口List元素可重复。光棍</code></pre><h3 id="3-Map接口功能概述-自己补齐"><a href="#3-Map接口功能概述-自己补齐" class="headerlink" title="(3)Map接口功能概述(自己补齐)"></a>(3)Map接口功能概述(自己补齐)</h3><h4 id="A-添加功能"><a href="#A-添加功能" class="headerlink" title="A:添加功能"></a>A:添加功能</h4><pre><code>    V put(K key,V value):添加元素。这个其实还有另一个功能?先不告诉你，等会讲         如果键是第一次存储，就直接存储元素，返回null         如果键不是第一次存在，就用值把以前的值替换掉，返回以前的值</code></pre><h4 id="B-删除功能"><a href="#B-删除功能" class="headerlink" title="B:删除功能"></a>B:删除功能</h4><pre><code>     void clear():移除所有的键值对元素     V remove(Object key)：根据键删除键值对元素，并把值返回</code></pre><h4 id="C-判断功能"><a href="#C-判断功能" class="headerlink" title="C:判断功能"></a>C:判断功能</h4><pre><code>     boolean containsKey(Object key)：判断集合是否包含指定的键      boolean containsValue(Object value):判断集合是否包含指定的值      boolean isEmpty()：判断集合是否为空</code></pre><h4 id="D-获取功能"><a href="#D-获取功能" class="headerlink" title="D:获取功能"></a>D:获取功能</h4><pre><code>     Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet():???     V get(Object key):根据键获取值     Set&lt;K&gt; keySet():获取集合中所有键的集合     Collection&lt;V&gt; values():获取集合中所有值的集合</code></pre><h4 id="E-长度功能"><a href="#E-长度功能" class="headerlink" title="E:长度功能"></a>E:长度功能</h4><pre><code>    int size()：返回集合中的键值对的对数</code></pre><h3 id="4-Map集合的遍历"><a href="#4-Map集合的遍历" class="headerlink" title="(4)Map集合的遍历"></a>(4)Map集合的遍历</h3><h4 id="A-键找值"><a href="#A-键找值" class="headerlink" title="A:键找值"></a>A:键找值</h4><pre><code>        a:获取所有键的集合        b:遍历键的集合,得到每一个键        c:根据键到集合中去找值</code></pre><h4 id="B-键值对对象找键和值"><a href="#B-键值对对象找键和值" class="headerlink" title="B:键值对对象找键和值"></a>B:键值对对象找键和值</h4><pre><code>        a:获取所有的键值对对象的集合        b:遍历键值对对象的集合，获取每一个键值对对象        c:根据键值对对象去获取键和值    代码体现：        Map&lt;String,String&gt; hm = new HashMap&lt;String,String&gt;();        hm.put(&quot;it002&quot;,&quot;hello&quot;);        hm.put(&quot;it003&quot;,&quot;world&quot;);        hm.put(&quot;it001&quot;,&quot;java&quot;);        //方式1 键找值        Set&lt;String&gt; set = hm.keySet();        for(String key : set) {            String value = hm.get(key);            System.out.println(key+&quot;---&quot;+value);        }        //方式2 键值对对象找键和值        Set&lt;Map.Entry&lt;String,String&gt;&gt; set2 = hm.entrySet();        for(Map.Entry&lt;String,String&gt; me : set2) {            String key = me.getKey();            String value = me.getValue();            System.out.println(key+&quot;---&quot;+value);        }</code></pre><h3 id="5-HashMap集合的练习"><a href="#5-HashMap集合的练习" class="headerlink" title="(5)HashMap集合的练习"></a>(5)HashMap集合的练习</h3><pre><code>    A:HashMap&lt;String,String&gt;    B:HashMap&lt;Integer,String&gt;    C:HashMap&lt;String,Student&gt;    D:HashMap&lt;Student,String&gt;</code></pre><h3 id="6-TreeMap集合的练习"><a href="#6-TreeMap集合的练习" class="headerlink" title="(6)TreeMap集合的练习"></a>(6)TreeMap集合的练习</h3><pre><code>    A:TreeMap&lt;String,String&gt;    B:TreeMap&lt;Student,String&gt;</code></pre><h3 id="7-案例"><a href="#7-案例" class="headerlink" title="(7)案例"></a>(7)案例</h3><pre><code>    A:统计一个字符串中每个字符出现的次数    B:集合的嵌套遍历        a:HashMap嵌套HashMap        b:HashMap嵌套ArrayList        c:ArrayList嵌套HashMap        d:多层嵌套</code></pre><h2 id="2-Collections-理解"><a href="#2-Collections-理解" class="headerlink" title="2:Collections(理解)"></a>2:Collections(理解)</h2><h3 id="1-是针对集合进行操作的工具类"><a href="#1-是针对集合进行操作的工具类" class="headerlink" title="(1)是针对集合进行操作的工具类"></a>(1)是针对集合进行操作的工具类</h3><h3 id="2-面试题：Collection和Collections的区别"><a href="#2-面试题：Collection和Collections的区别" class="headerlink" title="(2)面试题：Collection和Collections的区别"></a>(2)面试题：Collection和Collections的区别</h3><pre><code>    A:Collection 是单列集合的顶层接口，有两个子接口List和Set    B:Collections 是针对集合进行操作的工具类，可以对集合进行排序和查找等</code></pre><h3 id="3-常见的几个小方法："><a href="#3-常见的几个小方法：" class="headerlink" title="(3)常见的几个小方法："></a>(3)常见的几个小方法：</h3><pre><code>    A:public static &lt;T&gt; void sort(List&lt;T&gt; list)    B:public static &lt;T&gt; int binarySearch(List&lt;?&gt; list,T key)    C:public static &lt;T&gt; T max(Collection&lt;?&gt; coll)    D:public static void reverse(List&lt;?&gt; list)    E:public static void shuffle(List&lt;?&gt; list)</code></pre><h3 id="4-案例"><a href="#4-案例" class="headerlink" title="(4)案例"></a>(4)案例</h3><pre><code>    A:ArrayList集合存储自定义对象的排序    B:模拟斗地主洗牌和发牌    C:模拟斗地主洗牌和发牌并对牌进行排序</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day17</title>
      <link href="/2020/061830877.html"/>
      <url>/2020/061830877.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-登录注册案例-理解"><a href="#1-登录注册案例-理解" class="headerlink" title="1:登录注册案例(理解)"></a>1:登录注册案例(理解)</h2><h2 id="2-Set集合-理解"><a href="#2-Set集合-理解" class="headerlink" title="2:Set集合(理解)"></a>2:Set集合(理解)</h2><h3 id="1-Set集合的特点"><a href="#1-Set集合的特点" class="headerlink" title="(1)Set集合的特点"></a>(1)Set集合的特点</h3><pre><code>    无序,唯一</code></pre><h3 id="2-HashSet集合-掌握"><a href="#2-HashSet集合-掌握" class="headerlink" title="(2)HashSet集合(掌握)"></a>(2)HashSet集合(掌握)</h3><h4 id="A-底层数据结构是哈希表-是一个元素为链表的数组"><a href="#A-底层数据结构是哈希表-是一个元素为链表的数组" class="headerlink" title="A:底层数据结构是哈希表(是一个元素为链表的数组)"></a>A:底层数据结构是哈希表(是一个元素为链表的数组)</h4><h4 id="B-哈希表底层依赖两个方法：hashCode-和equals"><a href="#B-哈希表底层依赖两个方法：hashCode-和equals" class="headerlink" title="B:哈希表底层依赖两个方法：hashCode()和equals()"></a>B:哈希表底层依赖两个方法：hashCode()和equals()</h4><pre><code>      执行顺序：        首先比较哈希值是否相同            相同：继续执行equals()方法                返回true：元素重复了，不添加                返回false：直接把元素添加到集合            不同：就直接把元素添加到集合</code></pre><h4 id="C-如何保证元素唯一性的呢"><a href="#C-如何保证元素唯一性的呢" class="headerlink" title="C:如何保证元素唯一性的呢?"></a>C:如何保证元素唯一性的呢?</h4><pre><code>        由hashCode()和equals()保证的</code></pre><h4 id="D-开发的时候，代码非常的简单，自动生成即可。"><a href="#D-开发的时候，代码非常的简单，自动生成即可。" class="headerlink" title="D:开发的时候，代码非常的简单，自动生成即可。"></a>D:开发的时候，代码非常的简单，自动生成即可。</h4><h4 id="E-HashSet存储字符串并遍历"><a href="#E-HashSet存储字符串并遍历" class="headerlink" title="E:HashSet存储字符串并遍历"></a>E:HashSet存储字符串并遍历</h4><h4 id="F-HashSet存储自定义对象并遍历-对象的成员变量值相同即为同一个元素"><a href="#F-HashSet存储自定义对象并遍历-对象的成员变量值相同即为同一个元素" class="headerlink" title="F:HashSet存储自定义对象并遍历(对象的成员变量值相同即为同一个元素)"></a>F:HashSet存储自定义对象并遍历(对象的成员变量值相同即为同一个元素)</h4><h3 id="3-TreeSet集合"><a href="#3-TreeSet集合" class="headerlink" title="(3)TreeSet集合"></a>(3)TreeSet集合</h3><h4 id="A-底层数据结构是红黑树-是一个自平衡的二叉树"><a href="#A-底层数据结构是红黑树-是一个自平衡的二叉树" class="headerlink" title="A:底层数据结构是红黑树(是一个自平衡的二叉树)"></a>A:底层数据结构是红黑树(是一个自平衡的二叉树)</h4><h4 id="B-保证元素的排序方式"><a href="#B-保证元素的排序方式" class="headerlink" title="B:保证元素的排序方式"></a>B:保证元素的排序方式</h4><pre><code>        a:自然排序(元素具备比较性)            让元素所属的类实现Comparable接口        b:比较器排序(集合具备比较性)            让集合构造方法接收Comparator的实现类对象</code></pre><h4 id="C-把我们讲过的代码看一遍即可"><a href="#C-把我们讲过的代码看一遍即可" class="headerlink" title="C:把我们讲过的代码看一遍即可"></a>C:把我们讲过的代码看一遍即可</h4><h3 id="4-案例："><a href="#4-案例：" class="headerlink" title="(4)案例："></a>(4)案例：</h3><h4 id="A-获取无重复的随机数"><a href="#A-获取无重复的随机数" class="headerlink" title="A:获取无重复的随机数"></a>A:获取无重复的随机数</h4><h4 id="B-键盘录入学生按照总分从高到底输出"><a href="#B-键盘录入学生按照总分从高到底输出" class="headerlink" title="B:键盘录入学生按照总分从高到底输出"></a>B:键盘录入学生按照总分从高到底输出</h4><h2 id="3-Collection集合总结-掌握"><a href="#3-Collection集合总结-掌握" class="headerlink" title="3:Collection集合总结(掌握)"></a>3:Collection集合总结(掌握)</h2><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><h4 id="–List-有序-可重复"><a href="#–List-有序-可重复" class="headerlink" title="|–List    有序,可重复"></a>|–List    有序,可重复</h4><pre><code>        |--ArrayList            底层数据结构是数组，查询快，增删慢。            线程不安全，效率高            |--Vector            底层数据结构是数组，查询快，增删慢。            线程安全，效率低        |--LinkedList            底层数据结构是链表，查询慢，增删快。            线程不安全，效率高</code></pre><h4 id="–Set-无序-唯一"><a href="#–Set-无序-唯一" class="headerlink" title="|–Set    无序,唯一"></a>|–Set    无序,唯一</h4><pre><code>        |--HashSet            底层数据结构是哈希表。            如何保证元素唯一性的呢?                依赖两个方法：hashCode()和equals()                开发中自动生成这两个方法即可            |--LinkedHashSet                底层数据结构是链表和哈希表                由链表保证元素有序                由哈希表保证元素唯一        |--TreeSet            底层数据结构是红黑树。            如何保证元素排序的呢?                自然排序                比较器排序            如何保证元素唯一性的呢?                根据比较的返回值是否是0来决定</code></pre><h2 id="4-针对Collection集合我们到底使用谁呢-掌握"><a href="#4-针对Collection集合我们到底使用谁呢-掌握" class="headerlink" title="4:针对Collection集合我们到底使用谁呢?(掌握)"></a>4:针对Collection集合我们到底使用谁呢?(掌握)</h2><pre><code>唯一吗?    是：Set        排序吗?            是：TreeSet            否：HashSet    如果你知道是Set，但是不知道是哪个Set，就用HashSet。    否：List        要安全吗?            是：Vector            否：ArrayList或者LinkedList                查询多：ArrayList                增删多：LinkedList    如果你知道是List，但是不知道是哪个List，就用ArrayList。如果你知道是Collection集合，但是不知道使用谁，就用ArrayList。如果你知道用集合，就用ArrayList。</code></pre><h2 id="5-在集合中常见的数据结构-掌握"><a href="#5-在集合中常见的数据结构-掌握" class="headerlink" title="5:在集合中常见的数据结构(掌握)"></a>5:在集合中常见的数据结构(掌握)</h2><pre><code>ArrayXxx:底层数据结构是数组，查询快，增删慢LinkedXxx:底层数据结构是链表，查询慢，增删快HashXxx:底层数据结构是哈希表。依赖两个方法：hashCode()和equals()TreeXxx:底层数据结构是二叉树。两种方式排序：自然排序和比较器排序</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day16</title>
      <link href="/2020/061747196.html"/>
      <url>/2020/061747196.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-List的子类-掌握"><a href="#1-List的子类-掌握" class="headerlink" title="1:List的子类(掌握)"></a>1:List的子类(掌握)</h2><h3 id="1-List的子类特点"><a href="#1-List的子类特点" class="headerlink" title="(1)List的子类特点"></a>(1)List的子类特点</h3><pre><code>    ArrayList:        底层数据结构是数组，查询快，增删慢        线程不安全，效率高    Vector:        底层数据结构是数组，查询快，增删慢        线程安全，效率低    LinkedList:        底层数据结构是链表，查询慢，增删快        线程不安全，效率高</code></pre><h3 id="2-ArrayList"><a href="#2-ArrayList" class="headerlink" title="(2)ArrayList"></a>(2)ArrayList</h3><pre><code>    A:没有特有功能需要学习    B:案例        a:ArrayList存储字符串并遍历        b:ArrayList存储自定义对象并遍历</code></pre><h3 id="3-Vector"><a href="#3-Vector" class="headerlink" title="(3)Vector"></a>(3)Vector</h3><h4 id="A-有特有功能"><a href="#A-有特有功能" class="headerlink" title="A:有特有功能"></a>A:有特有功能</h4><pre><code>        a:添加            public void addElement(E obj)        --    add()        b:获取            public E elementAt(int index)        --    get()            public Enumeration&lt;E&gt; elements()    --  iterator()</code></pre><h4 id="B-案例"><a href="#B-案例" class="headerlink" title="B:案例"></a>B:案例</h4><pre><code>        a:Vector存储字符串并遍历        b:Vector存储自定义对象并遍历</code></pre><h3 id="4-LinkedList"><a href="#4-LinkedList" class="headerlink" title="(4)LinkedList"></a>(4)LinkedList</h3><h4 id="A-有特有功能-1"><a href="#A-有特有功能-1" class="headerlink" title="A:有特有功能"></a>A:有特有功能</h4><pre><code>        a:添加            addFirst()            addLast()        b:删除            removeFirst()            removeLast()        c:获取            getFirst()            getLast()</code></pre><h4 id="B-案例-1"><a href="#B-案例-1" class="headerlink" title="B:案例"></a>B:案例</h4><pre><code>        a:LinkedList存储字符串并遍历        b:LinkedList存储自定义对象并遍历</code></pre><h3 id="5-案例："><a href="#5-案例：" class="headerlink" title="(5)案例："></a>(5)案例：</h3><h4 id="A-去除集合中的多个字符串的重复元素"><a href="#A-去除集合中的多个字符串的重复元素" class="headerlink" title="A:去除集合中的多个字符串的重复元素"></a>A:去除集合中的多个字符串的重复元素</h4><pre><code>        如果字符串的内容相同，即为重复元素</code></pre><h4 id="B-去除集合中的多个自定义对象的重复元素"><a href="#B-去除集合中的多个自定义对象的重复元素" class="headerlink" title="B:去除集合中的多个自定义对象的重复元素"></a>B:去除集合中的多个自定义对象的重复元素</h4><pre><code>        如果自定义对象的成员变量值都相同，即为重复元素</code></pre><h4 id="C-用LinkedList模拟一个栈数据结构的集合类，并测试。"><a href="#C-用LinkedList模拟一个栈数据结构的集合类，并测试。" class="headerlink" title="C:用LinkedList模拟一个栈数据结构的集合类，并测试。"></a>C:用LinkedList模拟一个栈数据结构的集合类，并测试。</h4><pre><code>        你要定义一个集合类，只不过内部可以使用LinkedList来实现。</code></pre><h2 id="2-泛型-掌握"><a href="#2-泛型-掌握" class="headerlink" title="2:泛型(掌握)"></a>2:泛型(掌握)</h2><h3 id="1-泛型概述"><a href="#1-泛型概述" class="headerlink" title="(1)泛型概述"></a>(1)泛型概述</h3><pre><code>    是一种把明确类型的工作推迟到创建对象或者调用方法的时候才去明确的特殊的类型。</code></pre><h3 id="2-格式："><a href="#2-格式：" class="headerlink" title="(2)格式："></a>(2)格式：</h3><pre><code>    &lt;数据类型&gt;    注意：该数据类型只能是引用类型。</code></pre><h3 id="3-好处："><a href="#3-好处：" class="headerlink" title="(3)好处："></a>(3)好处：</h3><pre><code>    A:把运行时期的问题提前到了编译期间    B:避免了强制类型转换    C:优化了程序设计，解决了黄色警告线问题，让程序更安全</code></pre><h3 id="4-泛型的前世今生"><a href="#4-泛型的前世今生" class="headerlink" title="(4)泛型的前世今生"></a>(4)泛型的前世今生</h3><pre><code>    A:泛型的由来        Object类型作为任意类型的时候，在向下转型的时候，会隐含一个转型问题    B:泛型类    C:泛型方法    D:泛型接口    E:泛型高级通配符        ?        ? extends E        ? super E</code></pre><h3 id="5-我们在哪里使用呢"><a href="#5-我们在哪里使用呢" class="headerlink" title="(5)我们在哪里使用呢?"></a>(5)我们在哪里使用呢?</h3><pre><code>    一般是在集合中使用。</code></pre><h2 id="3-增强for循环-掌握"><a href="#3-增强for循环-掌握" class="headerlink" title="3:增强for循环(掌握)"></a>3:增强for循环(掌握)</h2><h3 id="1-是for循环的一种"><a href="#1-是for循环的一种" class="headerlink" title="(1)是for循环的一种"></a>(1)是for循环的一种</h3><h3 id="2-格式：-1"><a href="#2-格式：-1" class="headerlink" title="(2)格式："></a>(2)格式：</h3><pre><code>    for(元素的数据类型 变量名 : 数组或者Collection集合的对象) {        使用该变量即可，该变量其实就是数组或者集合中的元素。    }</code></pre><h3 id="3-好处：-1"><a href="#3-好处：-1" class="headerlink" title="(3)好处："></a>(3)好处：</h3><pre><code>    简化了数组和集合的遍历</code></pre><h3 id="4-弊端"><a href="#4-弊端" class="headerlink" title="(4)弊端"></a>(4)弊端</h3><pre><code>    增强for循环的目标不能为null。建议在使用前，先判断是否为null。</code></pre><h2 id="4-静态导入-了解"><a href="#4-静态导入-了解" class="headerlink" title="4:静态导入(了解)"></a>4:静态导入(了解)</h2><h3 id="1-可以导入到方法级别的导入"><a href="#1-可以导入到方法级别的导入" class="headerlink" title="(1)可以导入到方法级别的导入"></a>(1)可以导入到方法级别的导入</h3><h3 id="2-格式：-2"><a href="#2-格式：-2" class="headerlink" title="(2)格式："></a>(2)格式：</h3><pre><code>    import static 包名....类名.方法名;</code></pre><h3 id="3-注意事项："><a href="#3-注意事项：" class="headerlink" title="(3)注意事项："></a>(3)注意事项：</h3><pre><code>    A:方法必须是静态的    B:如果多个类下有同名的方法，就不好区分了，还得加上前缀。        所以一般我们并不使用静态导入，但是一定要能够看懂。</code></pre><h2 id="5-可变参数-掌握"><a href="#5-可变参数-掌握" class="headerlink" title="5:可变参数(掌握)"></a>5:可变参数(掌握)</h2><h3 id="1-如果我们在写方法的时候，参数个数不明确，就应该定义可变参数。"><a href="#1-如果我们在写方法的时候，参数个数不明确，就应该定义可变参数。" class="headerlink" title="(1)如果我们在写方法的时候，参数个数不明确，就应该定义可变参数。"></a>(1)如果我们在写方法的时候，参数个数不明确，就应该定义可变参数。</h3><h3 id="2-格式：-3"><a href="#2-格式：-3" class="headerlink" title="(2)格式："></a>(2)格式：</h3><pre><code>    修饰符 返回值类型 方法名(数据类型... 变量) {}    注意：        A:该变量其实是一个数组名        B:如果一个方法有多个参数，并且有可变参数，可变参数必须在最后</code></pre><h3 id="3-Arrays工具类的一个方法"><a href="#3-Arrays工具类的一个方法" class="headerlink" title="(3)Arrays工具类的一个方法"></a>(3)Arrays工具类的一个方法</h3><pre><code>    asList()把数组转成集合。    注意：这个集合的长度不能改变。</code></pre><h2 id="6-练习-掌握"><a href="#6-练习-掌握" class="headerlink" title="6:练习(掌握)"></a>6:练习(掌握)</h2><h3 id="A-集合的嵌套遍历"><a href="#A-集合的嵌套遍历" class="headerlink" title="A:集合的嵌套遍历"></a>A:集合的嵌套遍历</h3><h3 id="B-产生10个1-20之间的随机数，要求随机数不能重复"><a href="#B-产生10个1-20之间的随机数，要求随机数不能重复" class="headerlink" title="B:产生10个1-20之间的随机数，要求随机数不能重复"></a>B:产生10个1-20之间的随机数，要求随机数不能重复</h3><h3 id="C-键盘录入多个数据，以0结束，并在控制台输出最大值"><a href="#C-键盘录入多个数据，以0结束，并在控制台输出最大值" class="headerlink" title="C:键盘录入多个数据，以0结束，并在控制台输出最大值"></a>C:键盘录入多个数据，以0结束，并在控制台输出最大值</h3><h2 id="7-要掌握的代码"><a href="#7-要掌握的代码" class="headerlink" title="7:要掌握的代码"></a>7:要掌握的代码</h2><pre><code>集合存储元素，加入泛型，并可以使用增强for遍历。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day15</title>
      <link href="/2020/061647388.html"/>
      <url>/2020/061647388.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-对象数组-掌握"><a href="#1-对象数组-掌握" class="headerlink" title="1:对象数组(掌握)"></a>1:对象数组(掌握)</h2><h3 id="1-数组既可以存储基本数据类型，也可以存储引用类型。它存储引用类型的时候的数组就叫对象数组。"><a href="#1-数组既可以存储基本数据类型，也可以存储引用类型。它存储引用类型的时候的数组就叫对象数组。" class="headerlink" title="(1)数组既可以存储基本数据类型，也可以存储引用类型。它存储引用类型的时候的数组就叫对象数组。"></a>(1)数组既可以存储基本数据类型，也可以存储引用类型。它存储引用类型的时候的数组就叫对象数组。</h3><h3 id="2-案例："><a href="#2-案例：" class="headerlink" title="(2)案例："></a>(2)案例：</h3><pre><code>    用数组存储5个学生对象，并遍历数组。</code></pre><h2 id="2-集合-Collection-掌握"><a href="#2-集合-Collection-掌握" class="headerlink" title="2:集合(Collection)(掌握)"></a>2:集合(Collection)(掌握)</h2><h3 id="1-集合的由来"><a href="#1-集合的由来" class="headerlink" title="(1)集合的由来?"></a>(1)集合的由来?</h3><pre><code>    我们学习的是Java -- 面向对象 -- 操作很多对象 -- 存储 -- 容器(数组和StringBuffer) -- 数组    而数组的长度固定，所以不适合做变化的需求，Java就提供了集合供我们使用。</code></pre><h3 id="2-集合和数组的区别"><a href="#2-集合和数组的区别" class="headerlink" title="(2)集合和数组的区别?"></a>(2)集合和数组的区别?</h3><h4 id="A-长度区别"><a href="#A-长度区别" class="headerlink" title="A:长度区别"></a>A:长度区别</h4><pre><code>        数组固定        集合可变</code></pre><h4 id="B-内容区别"><a href="#B-内容区别" class="headerlink" title="B:内容区别"></a>B:内容区别</h4><pre><code>        数组可以是基本类型，也可以是引用类型        集合只能是引用类型</code></pre><h4 id="C-元素内容"><a href="#C-元素内容" class="headerlink" title="C:元素内容"></a>C:元素内容</h4><pre><code>        数组只能存储同一种类型        集合可以存储不同类型(其实集合一般存储的也是同一种类型)</code></pre><h3 id="3-集合的继承体系结构"><a href="#3-集合的继承体系结构" class="headerlink" title="(3)集合的继承体系结构?"></a>(3)集合的继承体系结构?</h3><pre><code>    由于需求不同，Java就提供了不同的集合类。这多个集合类的数据结构不同，但是它们都是要提供存储和遍历功能的，    我们把它们的共性不断的向上提取，最终就形成了集合的继承体系结构图。    Collection        |--List            |--ArrayList            |--Vector            |--LinkedList        |--Set            |--HashSet            |--TreeSet</code></pre><h3 id="4-Collection的功能概述-自己补齐"><a href="#4-Collection的功能概述-自己补齐" class="headerlink" title="(4)Collection的功能概述(自己补齐)"></a>(4)Collection的功能概述(自己补齐)</h3><h4 id="A-添加功能"><a href="#A-添加功能" class="headerlink" title="A:添加功能"></a>A:添加功能</h4><ul><li>boolean add(Object obj):添加一个元素</li><li>boolean addAll(Collection c):添加一个集合的元素<h4 id="B-删除功能"><a href="#B-删除功能" class="headerlink" title="B:删除功能"></a>B:删除功能</h4></li><li>void clear():移除所有元素</li><li>boolean remove(Object o):移除一个元素</li><li>boolean removeAll(Collection c):移除一个集合的元素(是一个还是所有)<h4 id="C-判断功能"><a href="#C-判断功能" class="headerlink" title="C:判断功能"></a>C:判断功能</h4></li><li>boolean contains(Object o)：判断集合中是否包含指定的元素</li><li>boolean containsAll(Collection c)：判断集合中是否包含指定的集合元素(是一个还是所有)</li><li>boolean isEmpty()：判断集合是否为空<h4 id="D-获取功能"><a href="#D-获取功能" class="headerlink" title="D:获取功能"></a>D:获取功能</h4></li><li>Iterator<E> iterator()(重点)<h4 id="E-长度功能"><a href="#E-长度功能" class="headerlink" title="E:长度功能"></a>E:长度功能</h4></li><li>int size():元素的个数</li><li>面试题：数组有没有length()方法呢?字符串有没有length()方法呢?集合有没有length()方法呢?</li></ul><h4 id="F-交集-了解"><a href="#F-交集-了解" class="headerlink" title="F:交集(了解)"></a>F:交集(了解)</h4><ul><li>boolean retainAll(Collection c):两个集合都有的元素?思考元素去哪了，返回的boolean又是什么意思呢?</li></ul><h4 id="G-把集合转数组-了解"><a href="#G-把集合转数组-了解" class="headerlink" title="G:把集合转数组(了解)"></a>G:把集合转数组(了解)</h4><ul><li>Object[] toArray()</li></ul><h3 id="5-Collection集合的遍历"><a href="#5-Collection集合的遍历" class="headerlink" title="(5)Collection集合的遍历"></a>(5)Collection集合的遍历</h3><h4 id="A-把集合转数组-了解"><a href="#A-把集合转数组-了解" class="headerlink" title="A:把集合转数组(了解)"></a>A:把集合转数组(了解)</h4><h4 id="B-迭代器-集合专用方式"><a href="#B-迭代器-集合专用方式" class="headerlink" title="B:迭代器(集合专用方式)"></a>B:迭代器(集合专用方式)</h4><h3 id="6-迭代器"><a href="#6-迭代器" class="headerlink" title="(6)迭代器"></a>(6)迭代器</h3><h4 id="A-是集合的获取元素的方式。"><a href="#A-是集合的获取元素的方式。" class="headerlink" title="A:是集合的获取元素的方式。"></a>A:是集合的获取元素的方式。</h4><h4 id="B-是依赖于集合而存在的。"><a href="#B-是依赖于集合而存在的。" class="headerlink" title="B:是依赖于集合而存在的。"></a>B:是依赖于集合而存在的。</h4><h4 id="C-迭代器的原理和源码。"><a href="#C-迭代器的原理和源码。" class="headerlink" title="C:迭代器的原理和源码。"></a>C:迭代器的原理和源码。</h4><pre><code>        a:为什么定义为了一个接口而不是实现类?        b:看了看迭代器的内部类实现。</code></pre><h3 id="7-Collection集合的案例-遍历方式-迭代器"><a href="#7-Collection集合的案例-遍历方式-迭代器" class="headerlink" title="(7)Collection集合的案例(遍历方式 迭代器)"></a>(7)Collection集合的案例(遍历方式 迭代器)</h3><pre><code>    集合的操作步骤：        A:创建集合对象        B:创建元素对象        C:把元素添加到集合        D:遍历集合</code></pre><h4 id="A-存储字符串并遍历"><a href="#A-存储字符串并遍历" class="headerlink" title="A:存储字符串并遍历"></a>A:存储字符串并遍历</h4><pre><code>        import java.util.Collection;        import java.util.ArrayList;        import java.util.Iterator;        public class CollectionDemo {            public static void main(String[] args) {                //创建集合对象                Collection c = new ArrayList();                //创建并添加元素                c.add(&quot;hello&quot;);                c.add(&quot;world&quot;);                c.add(&quot;java&quot;);                //遍历集合                Iterator it = c.iterator();                while(it.hasNext()) {                    String s =(String) it.next();                    System.out.println(s);                }            }        }</code></pre><h4 id="B-存储自定义对象并遍历"><a href="#B-存储自定义对象并遍历" class="headerlink" title="B:存储自定义对象并遍历"></a>B:存储自定义对象并遍历</h4><pre><code>        public class Student {            private String name;            private int age;            public Student(){}            public Student(String name,int age) {                this.name = name;                this.age = age;            }            //getXxx()/setXxx()        }        import java.util.Collection;        import java.util.ArrayList;        import java.util.Iterator;        public class StudentDemo {            public static void main(String[] args) {                //创建集合对象                Collection c = new ArrayList();                //创建学生对象                Student s1 = new Student(&quot;林青霞&quot;,27);                Student s2 = new Student(&quot;风清扬&quot;,30);                Student s3 = new Student(&quot;刘意&quot;,30);                Student s4 = new Student(&quot;武鑫&quot;,25);                Student s5 = new Student(&quot;刘晓曲&quot;,16);                //添加元素                c.add(s1);                c.add(s2);                c.add(s3);                c.add(s4);                c.add(s5);                //遍历集合                Iterator it = c.iterator();                while(it.hasNext()) {                    Student s = (Student)it.next();                    System.out.println(s.getName()+&quot;---&quot;+s.getAge());                }            }        }</code></pre><h2 id="3-集合-List-掌握"><a href="#3-集合-List-掌握" class="headerlink" title="3:集合(List)(掌握)"></a>3:集合(List)(掌握)</h2><h3 id="1-List是Collection的子接口"><a href="#1-List是Collection的子接口" class="headerlink" title="(1)List是Collection的子接口"></a>(1)List是Collection的子接口</h3><pre><code>    特点：有序(存储顺序和取出顺序一致)，可重复。</code></pre><h3 id="2-List的特有功能：-自己补齐"><a href="#2-List的特有功能：-自己补齐" class="headerlink" title="(2)List的特有功能：(自己补齐)"></a>(2)List的特有功能：(自己补齐)</h3><h4 id="A-添加功能-1"><a href="#A-添加功能-1" class="headerlink" title="A:添加功能"></a>A:添加功能</h4><ul><li>void add(int index,Object element):在指定位置添加元素</li></ul><h4 id="B-删除功能-1"><a href="#B-删除功能-1" class="headerlink" title="B:删除功能"></a>B:删除功能</h4><ul><li>Object remove(int index)：根据索引删除元素,返回被删除的元素</li></ul><h4 id="C-获取功能"><a href="#C-获取功能" class="headerlink" title="C:获取功能"></a>C:获取功能</h4><ul><li>Object get(int index):获取指定位置的元素</li></ul><h4 id="D-迭代器功能"><a href="#D-迭代器功能" class="headerlink" title="D:迭代器功能"></a>D:迭代器功能</h4><ul><li>ListIterator listIterator()：List集合特有的迭代器</li></ul><h4 id="E-修改功能"><a href="#E-修改功能" class="headerlink" title="E:修改功能"></a>E:修改功能</h4><ul><li>Object set(int index,Object element):根据索引修改元素，返回被修饰的元素</li></ul><h3 id="3-List集合的特有遍历功能"><a href="#3-List集合的特有遍历功能" class="headerlink" title="(3)List集合的特有遍历功能"></a>(3)List集合的特有遍历功能</h3><h4 id="A-由size-和get-结合。"><a href="#A-由size-和get-结合。" class="headerlink" title="A:由size()和get()结合。"></a>A:由size()和get()结合。</h4><h4 id="B-代码演示"><a href="#B-代码演示" class="headerlink" title="B:代码演示"></a>B:代码演示</h4><pre><code>                //创建集合对象                List list = new ArrayList();                //创建并添加元素                list.add(&quot;hello&quot;);                list.add(&quot;world&quot;);                list.add(&quot;java&quot;);                //遍历集合                Iterator it = list.iterator();                while(it.hasNext()) {                    String s =(String) it.next();                    System.out.println(s);                }                System.out.println(&quot;----------&quot;);                for(int x=0; x&lt;list.size(); x++) {                    String s =(String) list.get(x);                    System.out.println(s);                }</code></pre><h3 id="4-列表迭代器的特有功能；-了解"><a href="#4-列表迭代器的特有功能；-了解" class="headerlink" title="(4)列表迭代器的特有功能；(了解)"></a>(4)列表迭代器的特有功能；(了解)</h3><pre><code>    可以逆向遍历，但是要先正向遍历，所以无意义，基本不使用。</code></pre><h3 id="5-并发修改异常"><a href="#5-并发修改异常" class="headerlink" title="(5)并发修改异常"></a>(5)并发修改异常</h3><h4 id="A-出现的现象"><a href="#A-出现的现象" class="headerlink" title="A:出现的现象"></a>A:出现的现象</h4><pre><code>        迭代器遍历集合，集合修改集合元素</code></pre><h4 id="B-原因"><a href="#B-原因" class="headerlink" title="B:原因"></a>B:原因</h4><pre><code>        迭代器是依赖于集合的，而集合的改变迭代器并不知道。</code></pre><h4 id="C-解决方案"><a href="#C-解决方案" class="headerlink" title="C:解决方案"></a>C:解决方案</h4><pre><code>        a:迭代器遍历，迭代器修改(ListIterator)            元素添加在刚才迭代的位置        b:集合遍历，集合修改(size()和get())            元素添加在集合的末尾</code></pre><h3 id="6-常见数据结构"><a href="#6-常见数据结构" class="headerlink" title="(6)常见数据结构"></a>(6)常见数据结构</h3><h4 id="A-栈-先进后出"><a href="#A-栈-先进后出" class="headerlink" title="A:栈 先进后出"></a>A:栈 先进后出</h4><h4 id="B-队列-先进先出"><a href="#B-队列-先进先出" class="headerlink" title="B:队列 先进先出"></a>B:队列 先进先出</h4><h4 id="C-数组-查询快，增删慢"><a href="#C-数组-查询快，增删慢" class="headerlink" title="C:数组 查询快，增删慢"></a>C:数组 查询快，增删慢</h4><h4 id="D-链表-查询慢，增删快"><a href="#D-链表-查询慢，增删快" class="headerlink" title="D:链表 查询慢，增删快"></a>D:链表 查询慢，增删快</h4><h3 id="7-List的子类特点-面试题"><a href="#7-List的子类特点-面试题" class="headerlink" title="(7)List的子类特点(面试题)"></a>(7)List的子类特点(面试题)</h3><pre><code>    ArrayList        底层数据结构是数组，查询快，增删慢。        线程不安全，效率高。    Vector        底层数据结构是数组，查询快，增删慢。        线程安全，效率低。    LinkedList        底层数据结构是链表，查询慢，增删快。        线程不安全，效率高。    到底使用谁呢?看需求?    分析：        要安全吗?            要：Vector(即使要，也不使用这个，后面再说)            不要：ArrayList或者LinkedList                查询多；ArrayList                增删多：LinkedList    什么都不知道，就用ArrayList。</code></pre><h3 id="8-List集合的案例-遍历方式-迭代器和普通for"><a href="#8-List集合的案例-遍历方式-迭代器和普通for" class="headerlink" title="(8)List集合的案例(遍历方式 迭代器和普通for)"></a>(8)List集合的案例(遍历方式 迭代器和普通for)</h3><pre><code>    A:存储字符串并遍历    B:存储自定义对象并遍历</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day14</title>
      <link href="/2020/061431197.html"/>
      <url>/2020/061431197.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-正则表达式-理解"><a href="#1-正则表达式-理解" class="headerlink" title="1:正则表达式(理解)"></a>1:正则表达式(理解)</h2><h3 id="1-就是符合一定规则的字符串"><a href="#1-就是符合一定规则的字符串" class="headerlink" title="(1)就是符合一定规则的字符串"></a>(1)就是符合一定规则的字符串</h3><h3 id="2-常见规则"><a href="#2-常见规则" class="headerlink" title="(2)常见规则"></a>(2)常见规则</h3><h4 id="A-字符"><a href="#A-字符" class="headerlink" title="A:字符"></a>A:字符</h4><pre><code>        x 字符 x。举例：&#39;a&#39;表示字符a        \\ 反斜线字符。        \n 新行（换行）符 (&#39;\u000A&#39;)         \r 回车符 (&#39;\u000D&#39;)</code></pre><h4 id="B-字符类"><a href="#B-字符类" class="headerlink" title="B:字符类"></a>B:字符类</h4><pre><code>        [abc] a、b 或 c（简单类）         [^abc] 任何字符，除了 a、b 或 c（否定）         [a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内（范围）         [0-9] 0到9的字符都包括</code></pre><h4 id="C-预定义字符类"><a href="#C-预定义字符类" class="headerlink" title="C:预定义字符类"></a>C:预定义字符类</h4><pre><code>        . 任何字符。我的就是.字符本身，怎么表示呢? \.        \d 数字：[0-9]        \w 单词字符：[a-zA-Z_0-9]            在正则表达式里面组成单词的东西必须有这些东西组成</code></pre><h4 id="D-边界匹配器"><a href="#D-边界匹配器" class="headerlink" title="D:边界匹配器"></a>D:边界匹配器</h4><pre><code>        ^ 行的开头         $ 行的结尾         \b 单词边界            就是不是单词字符的地方。            举例：hello world?haha;xixi</code></pre><h4 id="E-Greedy-数量词"><a href="#E-Greedy-数量词" class="headerlink" title="E:Greedy 数量词"></a>E:Greedy 数量词</h4><pre><code>        X? X，一次或一次也没有        X* X，零次或多次        X+ X，一次或多次        X{n} X，恰好 n 次         X{n,} X，至少 n 次         X{n,m} X，至少 n 次，但是不超过 m 次 </code></pre><h3 id="3-常见功能：-分别用的是谁呢"><a href="#3-常见功能：-分别用的是谁呢" class="headerlink" title="(3)常见功能：(分别用的是谁呢?)"></a>(3)常见功能：(分别用的是谁呢?)</h3><h4 id="A-判断功能"><a href="#A-判断功能" class="headerlink" title="A:判断功能"></a>A:判断功能</h4><pre><code>        String类的public boolean matches(String regex)</code></pre><h4 id="B-分割功能"><a href="#B-分割功能" class="headerlink" title="B:分割功能"></a>B:分割功能</h4><pre><code>        String类的public String[] split(String regex)</code></pre><h4 id="C-替换功能"><a href="#C-替换功能" class="headerlink" title="C:替换功能"></a>C:替换功能</h4><pre><code>        String类的public String replaceAll(String regex,String replacement)</code></pre><h4 id="D-获取功能"><a href="#D-获取功能" class="headerlink" title="D:获取功能"></a>D:获取功能</h4><pre><code>        Pattern和Matcher            Pattern p = Pattern.compile(&quot;a*b&quot;);            Matcher m = p.matcher(&quot;aaaaab&quot;);            find():查找存不存在            group():获取刚才查找过的数据</code></pre><h3 id="4-案例"><a href="#4-案例" class="headerlink" title="(4)案例"></a>(4)案例</h3><pre><code>    A:判断电话号码和邮箱    B:按照不同的规则分割数据    C:把论坛中的数字替换为*    D:获取字符串中由3个字符组成的单词</code></pre><h2 id="2-Math-掌握"><a href="#2-Math-掌握" class="headerlink" title="2:Math(掌握)"></a>2:Math(掌握)</h2><h3 id="1-针对数学运算进行操作的类"><a href="#1-针对数学运算进行操作的类" class="headerlink" title="(1)针对数学运算进行操作的类"></a>(1)针对数学运算进行操作的类</h3><h3 id="2-常见方法-自己补齐"><a href="#2-常见方法-自己补齐" class="headerlink" title="(2)常见方法(自己补齐)"></a>(2)常见方法(自己补齐)</h3><h4 id="A-绝对值"><a href="#A-绝对值" class="headerlink" title="A:绝对值"></a>A:绝对值</h4><pre><code>    public static int abs(int a)：绝对值    </code></pre><h4 id="B-向上取整"><a href="#B-向上取整" class="headerlink" title="B:向上取整"></a>B:向上取整</h4><pre><code>    public static double ceil(double a):向上取整</code></pre><h4 id="C-向下取整"><a href="#C-向下取整" class="headerlink" title="C:向下取整"></a>C:向下取整</h4><pre><code>    public static double floor(double a):向下取整</code></pre><h4 id="D-两个数据中的大值"><a href="#D-两个数据中的大值" class="headerlink" title="D:两个数据中的大值"></a>D:两个数据中的大值</h4><pre><code>    public static int max(int a,int b):最大值 (min自学)</code></pre><h4 id="E-a的b次幂"><a href="#E-a的b次幂" class="headerlink" title="E:a的b次幂"></a>E:a的b次幂</h4><pre><code>    public static double pow(double a,double b):a的b次幂</code></pre><h4 id="F-随机数"><a href="#F-随机数" class="headerlink" title="F:随机数"></a>F:随机数</h4><pre><code>    public static double random():随机数 [0.0,1.0)</code></pre><h4 id="G-四舍五入"><a href="#G-四舍五入" class="headerlink" title="G:四舍五入"></a>G:四舍五入</h4><pre><code>    public static int round(float a) 四舍五入(参数为double的自学)</code></pre><h4 id="H-正平方根"><a href="#H-正平方根" class="headerlink" title="H:正平方根"></a>H:正平方根</h4><pre><code>    public static double sqrt(double a):正平方根</code></pre><h3 id="3-案例："><a href="#3-案例：" class="headerlink" title="(3)案例："></a>(3)案例：</h3><pre><code>    A:猜数字小游戏    B:获取任意范围的随机数</code></pre><h2 id="3-Random-理解"><a href="#3-Random-理解" class="headerlink" title="3:Random(理解)"></a>3:Random(理解)</h2><h3 id="1-用于产生随机数的类"><a href="#1-用于产生随机数的类" class="headerlink" title="(1)用于产生随机数的类"></a>(1)用于产生随机数的类</h3><h3 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="(2)构造方法:"></a>(2)构造方法:</h3><pre><code>    A:Random() 默认种子，每次产生的随机数不同    B:Random(long seed) 指定种子，每次种子相同，随机数就相同</code></pre><h3 id="3-成员方法"><a href="#3-成员方法" class="headerlink" title="(3)成员方法:"></a>(3)成员方法:</h3><pre><code>    A:int nextInt() 返回int范围内的随机数    B:int nextInt(int n) 返回[0,n)范围内的随机数</code></pre><h2 id="4-System-掌握"><a href="#4-System-掌握" class="headerlink" title="4:System(掌握)"></a>4:System(掌握)</h2><h3 id="1-系统类-提供了一些有用的字段和方法"><a href="#1-系统类-提供了一些有用的字段和方法" class="headerlink" title="(1)系统类,提供了一些有用的字段和方法"></a>(1)系统类,提供了一些有用的字段和方法</h3><h3 id="2-成员方法-自己补齐"><a href="#2-成员方法-自己补齐" class="headerlink" title="(2)成员方法(自己补齐)"></a>(2)成员方法(自己补齐)</h3><h4 id="A-运行垃圾回收器"><a href="#A-运行垃圾回收器" class="headerlink" title="A:运行垃圾回收器"></a>A:运行垃圾回收器</h4><pre><code>    public static void gc()：运行垃圾回收器。     </code></pre><h4 id="B-退出jvm"><a href="#B-退出jvm" class="headerlink" title="B:退出jvm"></a>B:退出jvm</h4><pre><code>    public static void exit(int status):终止当前正在运行的 Java 虚拟机。参数用作状态码；根据惯例，非 0 的状态码表示异常终止。</code></pre><h4 id="C-获取当前时间的毫秒值"><a href="#C-获取当前时间的毫秒值" class="headerlink" title="C:获取当前时间的毫秒值"></a>C:获取当前时间的毫秒值</h4><pre><code>    public static long currentTimeMillis():返回以毫秒为单位的当前时间</code></pre><h4 id="D-数组复制"><a href="#D-数组复制" class="headerlink" title="D:数组复制"></a>D:数组复制</h4><pre><code>    public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length)     从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。</code></pre><h2 id="5-BigInteger-理解"><a href="#5-BigInteger-理解" class="headerlink" title="5:BigInteger(理解)"></a>5:BigInteger(理解)</h2><h3 id="1-针对大整数的运算"><a href="#1-针对大整数的运算" class="headerlink" title="(1)针对大整数的运算"></a>(1)针对大整数的运算</h3><h3 id="2-构造方法-1"><a href="#2-构造方法-1" class="headerlink" title="(2)构造方法"></a>(2)构造方法</h3><pre><code>    A:BigInteger(String s)</code></pre><h3 id="3-成员方法-自己补齐"><a href="#3-成员方法-自己补齐" class="headerlink" title="(3)成员方法(自己补齐)"></a>(3)成员方法(自己补齐)</h3><pre><code>    A:加    B:减    C:乘    D:除    E:商和余数</code></pre><h2 id="6-BigDecimal-理解"><a href="#6-BigDecimal-理解" class="headerlink" title="6:BigDecimal(理解)"></a>6:BigDecimal(理解)</h2><h3 id="1-浮点数据做运算，会丢失精度。所以，针对浮点数据的操作建议采用BigDecimal。-金融相关的项目"><a href="#1-浮点数据做运算，会丢失精度。所以，针对浮点数据的操作建议采用BigDecimal。-金融相关的项目" class="headerlink" title="(1)浮点数据做运算，会丢失精度。所以，针对浮点数据的操作建议采用BigDecimal。(金融相关的项目)"></a>(1)浮点数据做运算，会丢失精度。所以，针对浮点数据的操作建议采用BigDecimal。(金融相关的项目)</h3><h3 id="2-构造方法-2"><a href="#2-构造方法-2" class="headerlink" title="(2)构造方法"></a>(2)构造方法</h3><pre><code>    A:BigDecimal(String s)</code></pre><h3 id="3-成员方法："><a href="#3-成员方法：" class="headerlink" title="(3)成员方法："></a>(3)成员方法：</h3><h4 id="A-加"><a href="#A-加" class="headerlink" title="A:加"></a>A:加</h4><pre><code>    public BigInteger add(BigInteger val):加</code></pre><h4 id="B-减"><a href="#B-减" class="headerlink" title="B:减"></a>B:减</h4><pre><code>    public BigInteger subtract(BigInteger val):减</code></pre><h4 id="C-乘"><a href="#C-乘" class="headerlink" title="C:乘"></a>C:乘</h4><pre><code>    public BigInteger multiply(BigInteger val):乘</code></pre><h4 id="D-除"><a href="#D-除" class="headerlink" title="D:除"></a>D:除</h4><pre><code>    public BigInteger divide(BigInteger val):除</code></pre><h4 id="E-自己保留小数几位"><a href="#E-自己保留小数几位" class="headerlink" title="E:自己保留小数几位"></a>E:自己保留小数几位</h4><pre><code>    public BigInteger[] divideAndRemainder(BigInteger val):返回商和余数的数组</code></pre><h2 id="7-Date-DateFormat-掌握"><a href="#7-Date-DateFormat-掌握" class="headerlink" title="7:Date/DateFormat(掌握)"></a>7:Date/DateFormat(掌握)</h2><h3 id="1-Date是日期类，可以精确到毫秒。"><a href="#1-Date是日期类，可以精确到毫秒。" class="headerlink" title="(1)Date是日期类，可以精确到毫秒。"></a>(1)Date是日期类，可以精确到毫秒。</h3><h4 id="A-构造方法"><a href="#A-构造方法" class="headerlink" title="A:构造方法"></a>A:构造方法</h4><pre><code>        Date()        Date(long time)</code></pre><h4 id="B-成员方法"><a href="#B-成员方法" class="headerlink" title="B:成员方法"></a>B:成员方法</h4><pre><code>        getTime()        setTime(long time)</code></pre><h4 id="C-日期和毫秒值的相互转换"><a href="#C-日期和毫秒值的相互转换" class="headerlink" title="C:日期和毫秒值的相互转换"></a>C:日期和毫秒值的相互转换</h4><pre><code>    案例：你来到这个世界多少天了?</code></pre><h3 id="2-DateFormat针对日期进行格式化和针对字符串进行解析的类，但是是抽象类，所以使用其子类SimpleDateFormat"><a href="#2-DateFormat针对日期进行格式化和针对字符串进行解析的类，但是是抽象类，所以使用其子类SimpleDateFormat" class="headerlink" title="(2)DateFormat针对日期进行格式化和针对字符串进行解析的类，但是是抽象类，所以使用其子类SimpleDateFormat"></a>(2)DateFormat针对日期进行格式化和针对字符串进行解析的类，但是是抽象类，所以使用其子类SimpleDateFormat</h3><pre><code>    A:SimpleDateFormat(String pattern) 给定模式        yyyy-MM-dd HH:mm:ss    B:日期和字符串的转换        a:Date -- String            format()        b:String -- Date            parse()    C:案例：        制作了一个针对日期操作的工具类。</code></pre><h2 id="8-Calendar-掌握"><a href="#8-Calendar-掌握" class="headerlink" title="8:Calendar(掌握)"></a>8:Calendar(掌握)</h2><h3 id="1-日历类，封装了所有的日历字段值，通过统一的方法根据传入不同的日历字段可以获取值。"><a href="#1-日历类，封装了所有的日历字段值，通过统一的方法根据传入不同的日历字段可以获取值。" class="headerlink" title="(1)日历类，封装了所有的日历字段值，通过统一的方法根据传入不同的日历字段可以获取值。"></a>(1)日历类，封装了所有的日历字段值，通过统一的方法根据传入不同的日历字段可以获取值。</h3><h3 id="2-如何得到一个日历对象呢"><a href="#2-如何得到一个日历对象呢" class="headerlink" title="(2)如何得到一个日历对象呢?"></a>(2)如何得到一个日历对象呢?</h3><pre><code>    Calendar rightNow = Calendar.getInstance();    本质返回的是子类对象</code></pre><h3 id="3-成员方法-1"><a href="#3-成员方法-1" class="headerlink" title="(3)成员方法"></a>(3)成员方法</h3><pre><code>    A:根据日历字段得到对应的值    B:根据日历字段和一个正负数确定是添加还是减去对应日历字段的值    C:设置日历对象的年月日</code></pre><h3 id="4-案例："><a href="#4-案例：" class="headerlink" title="(4)案例："></a>(4)案例：</h3><pre><code>    计算任意一年的2月份有多少天?</code></pre><hr><p>看看下面的类，是否都熟悉，简要说明每个类主要是干什么呢?  </p><pre><code>Object类     Object 是类层次结构的根类。  每个类都使用 Object 作为超类。  所有对象（包括数组）都实现这个类的方法。 Scanner        一个可以使用正则表达式来解析基本类型和字符串的简单文本扫描器。 String        String 类代表字符串。Java 程序中的所有字符串字面值（如 &quot;abc&quot; ）都作为此类的实例实现。 StringBuffer/StringBuilder        线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。  虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。Arrays        此类包含用来操作数组（比如排序和搜索）的各种方法。  此类还包含一个允许将数组作为列表来查看的静态工厂。 Integer        Integer 类在对象中包装了一个基本类型 int 的值。  Integer 类型的对象包含一个 int 类型的字段。 Character        Character 类在对象中包装一个基本类型 char 的值。  Character 类型的对象包含类型为 char 的单个字段。 Pattern        正则表达式的编译表示形式。指定为字符串的正则表达式必须首先被编译为此类的实例。  然后，可将得到的模式用于创建 Matcher 对象，依照正则表达式，该对象可以与任意字符序列匹配。  执行匹配所涉及的所有状态都驻留在匹配器中，所以多个匹配器可以共享同一模式。Matcher        通过解释 Pattern 对 character sequence 执行匹配操作的引擎。  通过调用模式的 matcher 方法从模式创建匹配器。Math        Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。 Random        此类的实例用于生成伪随机数流。此类使用 48 位的种子，使用线性同余公式 (linear congruential form) 对其进行了修改（请参阅 Donald Knuth 的The Art of Computer Programming, Volume 3，第 3.2.1 节）。 System        System 类包含一些有用的类字段和方法。它不能被实例化。   在 System 类提供的设施中，有标准输入、标准输出和错误输出流；对外部定义的属性和环境变量的访问；   加载文件和库的方法；还有快速复制数组的一部分的实用方法。 BigInteger        不可变的任意精度的整数。所有操作中，都以二进制补码形式表示 BigInteger（如 Java 的基本整数类型）。BigDecimal        不可变的、任意精度的有符号十进制数。BigDecimal 由任意精度的整数非标度值 和 32 位的整数标度 (scale) 组成。  如果为零或正数，则标度是小数点后的位数。如果为负数，则将该数的非标度值乘以 10 的负 scale 次幂。  因此，BigDecimal 表示的数值是 (unscaledValue × 10-scale)。 Date        类 Date 表示特定的瞬间，精确到毫秒。 DateFormat        DateFormat 是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。  日期/时间格式化子类（如 SimpleDateFormat）允许进行格式化（也就是日期 -&gt; 文本）、解析（文本-&gt; 日期）和标准化。  将日期表示为 Date 对象，或者表示为从 GMT（格林尼治标准时间）1970 年 1 月 1 日 00:00:00 这一刻开始的毫秒数。Calendar        Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等 日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。  瞬间可用毫秒值来表示，它是距历元（即格林威治标准时间 1970 年 1 月 1 日的 00:00:00.000，格里高利历）的偏移量。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day13</title>
      <link href="/2020/061348028.html"/>
      <url>/2020/061348028.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-StringBuffer-掌握"><a href="#1-StringBuffer-掌握" class="headerlink" title="1:StringBuffer(掌握)"></a>1:StringBuffer(掌握)</h2><h3 id="1-用字符串做拼接，比较耗时并且也耗内存，而这种拼接操作又是比较常见的，为了解决这个问题，Java就提供了"><a href="#1-用字符串做拼接，比较耗时并且也耗内存，而这种拼接操作又是比较常见的，为了解决这个问题，Java就提供了" class="headerlink" title="(1)用字符串做拼接，比较耗时并且也耗内存，而这种拼接操作又是比较常见的，为了解决这个问题，Java就提供了"></a>(1)用字符串做拼接，比较耗时并且也耗内存，而这种拼接操作又是比较常见的，为了解决这个问题，Java就提供了</h3><pre><code>   一个字符串缓冲区类。StringBuffer供我们使用。</code></pre><h3 id="2-StringBuffer的构造方法"><a href="#2-StringBuffer的构造方法" class="headerlink" title="(2)StringBuffer的构造方法"></a>(2)StringBuffer的构造方法</h3><pre><code>    A:StringBuffer()    B:StringBuffer(int size)    C:StringBuffer(String str)</code></pre><h3 id="3-StringBuffer的常见功能-自己补齐方法的声明和方法的解释"><a href="#3-StringBuffer的常见功能-自己补齐方法的声明和方法的解释" class="headerlink" title="(3)StringBuffer的常见功能(自己补齐方法的声明和方法的解释)"></a>(3)StringBuffer的常见功能(自己补齐方法的声明和方法的解释)</h3><h4 id="A-添加功能"><a href="#A-添加功能" class="headerlink" title="A:添加功能"></a>A:添加功能</h4><pre><code>        public StringBuffer append(String str):可以把任意类型数据添加到字符串缓冲区里面,并返回字符串缓冲区本身        public StringBuffer insert(int offset,String str):在指定位置把任意类型的数据插入到字符串缓冲区里面,并返回字符串缓冲区本身</code></pre><h4 id="B-删除功能"><a href="#B-删除功能" class="headerlink" title="B:删除功能"></a>B:删除功能</h4><pre><code>         public StringBuffer deleteCharAt(int index):删除指定位置的字符，并返回本身          public StringBuffer delete(int start,int end):删除从指定位置开始指定位置结束的内容，并返回本身</code></pre><h4 id="C-替换功能"><a href="#C-替换功能" class="headerlink" title="C:替换功能"></a>C:替换功能</h4><pre><code>        public StringBuffer replace(int start,int end,String str):从start开始到end用str替换</code></pre><h4 id="D-反转功能"><a href="#D-反转功能" class="headerlink" title="D:反转功能"></a>D:反转功能</h4><pre><code>        public StringBuffer reverse()</code></pre><h4 id="E-截取功能-注意这个返回值"><a href="#E-截取功能-注意这个返回值" class="headerlink" title="E:截取功能(注意这个返回值)"></a>E:截取功能(注意这个返回值)</h4><pre><code>        注意返回值类型不再是StringBuffer本身了          public String substring(int start)          public String substring(int start,int end)</code></pre><h3 id="4-StringBuffer的练习-做一遍"><a href="#4-StringBuffer的练习-做一遍" class="headerlink" title="(4)StringBuffer的练习(做一遍)"></a>(4)StringBuffer的练习(做一遍)</h3><pre><code>    A:String和StringBuffer相互转换        String -- StringBuffer            构造方法        StringBuffer -- String            toString()方法    B:字符串的拼接    C:把字符串反转    D:判断一个字符串是否对称</code></pre><h3 id="5-面试题"><a href="#5-面试题" class="headerlink" title="(5)面试题"></a>(5)面试题</h3><pre><code>    小细节：        StringBuffer：同步的，数据安全，效率低。        StringBuilder：不同步的，数据不安全，效率高。    A:String,StringBuffer,StringBuilder的区别    B:StringBuffer和数组的区别?</code></pre><h3 id="6-注意的问题："><a href="#6-注意的问题：" class="headerlink" title="(6)注意的问题："></a>(6)注意的问题：</h3><pre><code>    String作为形式参数，StringBuffer作为形式参数。</code></pre><h2 id="2-数组高级以及Arrays-掌握"><a href="#2-数组高级以及Arrays-掌握" class="headerlink" title="2:数组高级以及Arrays(掌握)"></a>2:数组高级以及Arrays(掌握)</h2><h3 id="1-排序"><a href="#1-排序" class="headerlink" title="(1)排序"></a>(1)排序</h3><h4 id="A-冒泡排序"><a href="#A-冒泡排序" class="headerlink" title="A:冒泡排序"></a>A:冒泡排序</h4><pre><code>        相邻元素两两比较，大的往后放，第一次完毕，最大值出现在了最大索引处。同理，其他的元素就可以排好。        public static void bubbleSort(int[] arr) {            for(int x=0; x&lt;arr.length-1; x++) {                for(int y=0; y&lt;arr.length-1-x; y++) {                    if(arr[y] &gt; arr[y+1]) {                        int temp = arr[y];                        arr[y] = arr[y+1];                        arr[y+1] = temp;                    }                }            }        }</code></pre><h4 id="B-选择排序"><a href="#B-选择排序" class="headerlink" title="B:选择排序"></a>B:选择排序</h4><pre><code>        把0索引的元素，和索引1以后的元素都进行比较，第一次完毕，最小值出现在了0索引。同理，其他的元素就可以排好。        public static void selectSort(int[] arr) {            for(int x=0; x&lt;arr.length-1; x++) {                for(int y=x+1; y&lt;arr.length; y++) {                    if(arr[y] &lt; arr[x]) {                        int temp = arr[x];                        arr[x] = arr[y];                        arr[y] = temp;                    }                }            }        }</code></pre><h3 id="2-查找"><a href="#2-查找" class="headerlink" title="(2)查找"></a>(2)查找</h3><h4 id="A-基本查找"><a href="#A-基本查找" class="headerlink" title="A:基本查找"></a>A:基本查找</h4><pre><code>        针对数组无序的情况        public static int getIndex(int[] arr,int value) {            int index = -1;            for(int x=0; x&lt;arr.length; x++) {                if(arr[x] == value) {                    index = x;                    break;                }            }            return index;        }</code></pre><h4 id="B-二分查找-折半查找"><a href="#B-二分查找-折半查找" class="headerlink" title="B:二分查找(折半查找)"></a>B:二分查找(折半查找)</h4><pre><code>        针对数组有序的情况(千万不要先排序，在查找)        public static int binarySearch(int[] arr,int value) {            int min = 0;            int max = arr.length-1;            int mid = (min+max)/2;            while(arr[mid] != value) {                if(arr[mid] &gt; value) {                    max = mid - 1;                }else if(arr[mid] &lt; value) {                    min = mid + 1;                }                if(min &gt; max) {                    return -1;                }                mid = (min+max)/2;            }            return mid;        }</code></pre><h3 id="3-Arrays工具类"><a href="#3-Arrays工具类" class="headerlink" title="(3)Arrays工具类"></a>(3)Arrays工具类</h3><pre><code>    A:是针对数组进行操作的工具类。包括排序和查找等功能。    B:要掌握的方法(自己补齐方法)        把数组转成字符串：        排序：        二分查找：</code></pre><h3 id="4-Arrays工具类的源码解析"><a href="#4-Arrays工具类的源码解析" class="headerlink" title="(4)Arrays工具类的源码解析"></a>(4)Arrays工具类的源码解析</h3><h3 id="5-把字符串中的字符进行排序"><a href="#5-把字符串中的字符进行排序" class="headerlink" title="(5)把字符串中的字符进行排序"></a>(5)把字符串中的字符进行排序</h3><pre><code>    举例：        &quot;edacbgf&quot;        得到结果        &quot;abcdefg&quot;</code></pre><h2 id="3-Integer-掌握"><a href="#3-Integer-掌握" class="headerlink" title="3:Integer(掌握)"></a>3:Integer(掌握)</h2><h3 id="1-为了让基本类型的数据进行更多的操作，Java就为每种基本类型提供了对应的包装类类型"><a href="#1-为了让基本类型的数据进行更多的操作，Java就为每种基本类型提供了对应的包装类类型" class="headerlink" title="(1)为了让基本类型的数据进行更多的操作，Java就为每种基本类型提供了对应的包装类类型"></a>(1)为了让基本类型的数据进行更多的操作，Java就为每种基本类型提供了对应的包装类类型</h3><pre><code>    byte         Byte    short        Short    int            Integer    long        Long    float        Float    double        Double    char        Character    boolean        Boolean</code></pre><h3 id="2-Integer的构造方法"><a href="#2-Integer的构造方法" class="headerlink" title="(2)Integer的构造方法"></a>(2)Integer的构造方法</h3><pre><code>    A:Integer i = new Integer(100);    B:Integer i = new Integer(&quot;100&quot;);        注意：这里的字符串必须是由数字字符组成</code></pre><h3 id="3-String和int的相互转换"><a href="#3-String和int的相互转换" class="headerlink" title="(3)String和int的相互转换"></a>(3)String和int的相互转换</h3><pre><code>    A:String -- int        Integer.parseInt(&quot;100&quot;);    B:int -- String        String.valueOf(100);</code></pre><h3 id="4-其他的功能-了解"><a href="#4-其他的功能-了解" class="headerlink" title="(4)其他的功能(了解)"></a>(4)其他的功能(了解)</h3><pre><code>    进制转换</code></pre><h3 id="5-JDK5的新特性"><a href="#5-JDK5的新特性" class="headerlink" title="(5)JDK5的新特性"></a>(5)JDK5的新特性</h3><pre><code>    自动装箱    基本类型--引用类型    自动拆箱    引用类型--基本类型    把下面的这个代码理解即可：        Integer i = 100;        i += 200;</code></pre><h3 id="6-面试题"><a href="#6-面试题" class="headerlink" title="(6)面试题"></a>(6)面试题</h3><pre><code>    -128到127之间的数据缓冲池问题</code></pre><h2 id="4-Character-了解"><a href="#4-Character-了解" class="headerlink" title="4:Character(了解)"></a>4:Character(了解)</h2><h3 id="1-Character构造方法"><a href="#1-Character构造方法" class="headerlink" title="(1)Character构造方法"></a>(1)Character构造方法</h3><pre><code>    Character ch = new Character(&#39;a&#39;);</code></pre><h3 id="2-要掌握的方法：-自己补齐"><a href="#2-要掌握的方法：-自己补齐" class="headerlink" title="(2)要掌握的方法：(自己补齐)"></a>(2)要掌握的方法：(自己补齐)</h3><h4 id="A-判断给定的字符是否是大写"><a href="#A-判断给定的字符是否是大写" class="headerlink" title="A:判断给定的字符是否是大写"></a>A:判断给定的字符是否是大写</h4><pre><code>    public static boolean isUpperCase(char ch):判断给定的字符是否是大写字符</code></pre><h4 id="B-判断给定的字符是否是小写"><a href="#B-判断给定的字符是否是小写" class="headerlink" title="B:判断给定的字符是否是小写"></a>B:判断给定的字符是否是小写</h4><pre><code>    public static boolean isLowerCase(char ch):判断给定的字符是否是小写字符</code></pre><h4 id="C-判断给定的字符是否是数字字符"><a href="#C-判断给定的字符是否是数字字符" class="headerlink" title="C:判断给定的字符是否是数字字符"></a>C:判断给定的字符是否是数字字符</h4><pre><code>    public static boolean isDigit(char ch):判断给定的字符是否是数字字符</code></pre><h4 id="D-把给定的字符转成大写"><a href="#D-把给定的字符转成大写" class="headerlink" title="D:把给定的字符转成大写"></a>D:把给定的字符转成大写</h4><pre><code>    public static char toUpperCase(char ch):把给定的字符转换为大写字符</code></pre><h4 id="E-把给定的字符转成小写"><a href="#E-把给定的字符转成小写" class="headerlink" title="E:把给定的字符转成小写"></a>E:把给定的字符转成小写</h4><pre><code>    public static char toLowerCase(char ch):把给定的字符转换为小写字符</code></pre><h3 id="3-案例："><a href="#3-案例：" class="headerlink" title="(3)案例："></a>(3)案例：</h3><pre><code>    统计字符串中大写，小写及数字字符出现的次数</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day12</title>
      <link href="/2020/061231581.html"/>
      <url>/2020/061231581.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Scanner的使用-了解"><a href="#1-Scanner的使用-了解" class="headerlink" title="1:Scanner的使用(了解)"></a>1:Scanner的使用(了解)</h2><h3 id="1-在JDK5以后出现的用于键盘录入数据的类。"><a href="#1-在JDK5以后出现的用于键盘录入数据的类。" class="headerlink" title="(1)在JDK5以后出现的用于键盘录入数据的类。"></a>(1)在JDK5以后出现的用于键盘录入数据的类。</h3><h3 id="2-构造方法："><a href="#2-构造方法：" class="headerlink" title="(2)构造方法："></a>(2)构造方法：</h3><h4 id="A-讲解了System-in这个东西。"><a href="#A-讲解了System-in这个东西。" class="headerlink" title="A:讲解了System.in这个东西。"></a>A:讲解了System.in这个东西。</h4><pre><code>        它其实是标准的输入流,对应于键盘录入</code></pre><h4 id="B-构造方法"><a href="#B-构造方法" class="headerlink" title="B:构造方法"></a>B:构造方法</h4><pre><code>        InputStream is = System.in;        Scanner(InputStream is)</code></pre><h4 id="C-常用的格式"><a href="#C-常用的格式" class="headerlink" title="C:常用的格式"></a>C:常用的格式</h4><pre><code>        Scanner sc = new Scanner(System.in);</code></pre><h3 id="3-基本方法格式："><a href="#3-基本方法格式：" class="headerlink" title="(3)基本方法格式："></a>(3)基本方法格式：</h3><pre><code>    A:hasNextXxx() 判断是否是某种类型的    B:nextXxx()    返回某种类型的元素</code></pre><h3 id="4-要掌握的两个方法"><a href="#4-要掌握的两个方法" class="headerlink" title="(4)要掌握的两个方法"></a>(4)要掌握的两个方法</h3><pre><code>    A:public int nextInt()    B:public String nextLine()</code></pre><h3 id="5-需要注意的小问题"><a href="#5-需要注意的小问题" class="headerlink" title="(5)需要注意的小问题"></a>(5)需要注意的小问题</h3><h4 id="A-同一个Scanner对象，先获取数值，再获取字符串会出现一个小问题。"><a href="#A-同一个Scanner对象，先获取数值，再获取字符串会出现一个小问题。" class="headerlink" title="A:同一个Scanner对象，先获取数值，再获取字符串会出现一个小问题。"></a>A:同一个Scanner对象，先获取数值，再获取字符串会出现一个小问题。</h4><h4 id="B-解决方案："><a href="#B-解决方案：" class="headerlink" title="B:解决方案："></a>B:解决方案：</h4><pre><code>        a:重新定义一个Scanner对象        b:把所有的数据都用字符串获取，然后再进行相应的转换</code></pre><h2 id="2-String类的概述和使用-掌握"><a href="#2-String类的概述和使用-掌握" class="headerlink" title="2:String类的概述和使用(掌握)"></a>2:String类的概述和使用(掌握)</h2><h3 id="1-多个字符组成的一串数据。"><a href="#1-多个字符组成的一串数据。" class="headerlink" title="(1)多个字符组成的一串数据。"></a>(1)多个字符组成的一串数据。</h3><pre><code>    其实它可以和字符数组进行相互转换。</code></pre><h3 id="2-构造方法：-1"><a href="#2-构造方法：-1" class="headerlink" title="(2)构造方法："></a>(2)构造方法：</h3><pre><code>    A:public String()    B:public String(byte[] bytes)    C:public String(byte[] bytes,int offset,int length)    D:public String(char[] value)    E:public String(char[] value,int offset,int count)    F:public String(String original)    下面的这一个虽然不是构造方法，但是结果也是一个字符串对象    G:String s = &quot;hello&quot;;</code></pre><h3 id="3-字符串的特点"><a href="#3-字符串的特点" class="headerlink" title="(3)字符串的特点"></a>(3)字符串的特点</h3><pre><code>    A:字符串一旦被赋值，就不能改变。        注意：这里指的是字符串的内容不能改变，而不是引用不能改变。    B:字面值作为字符串对象和通过构造方法创建对象的不同        String s = new String(&quot;hello&quot;);和String s = &quot;hello&quot;的区别?</code></pre><h3 id="4-字符串的面试题-看程序写结果"><a href="#4-字符串的面试题-看程序写结果" class="headerlink" title="(4)字符串的面试题(看程序写结果)"></a>(4)字符串的面试题(看程序写结果)</h3><h4 id="A-和equals"><a href="#A-和equals" class="headerlink" title="A:==和equals()"></a>A:==和equals()</h4><pre><code>        String s1 = new String(&quot;hello&quot;);        String s2 = new String(&quot;hello&quot;);        System.out.println(s1 == s2);// false        System.out.println(s1.equals(s2));// true        String s3 = new String(&quot;hello&quot;);        String s4 = &quot;hello&quot;;        System.out.println(s3 == s4);// false        System.out.println(s3.equals(s4));// true        String s5 = &quot;hello&quot;;        String s6 = &quot;hello&quot;;        System.out.println(s5 == s6);// true        System.out.println(s5.equals(s6));// true</code></pre><h4 id="B-字符串的拼接"><a href="#B-字符串的拼接" class="headerlink" title="B:字符串的拼接"></a>B:字符串的拼接</h4><pre><code>        String s1 = &quot;hello&quot;;        String s2 = &quot;world&quot;;        String s3 = &quot;helloworld&quot;;        System.out.println(s3 == s1 + s2);// false        System.out.println(s3.equals((s1 + s2)));// true        System.out.println(s3 == &quot;hello&quot; + &quot;world&quot;);// false 这个我们错了，应该是true        System.out.println(s3.equals(&quot;hello&quot; + &quot;world&quot;));// true</code></pre><h3 id="5-字符串的功能-自己补齐方法中文意思"><a href="#5-字符串的功能-自己补齐方法中文意思" class="headerlink" title="(5)字符串的功能(自己补齐方法中文意思)"></a>(5)字符串的功能(自己补齐方法中文意思)</h3><h4 id="A-判断功能"><a href="#A-判断功能" class="headerlink" title="A:判断功能"></a>A:判断功能</h4><pre><code>        boolean equals(Object obj)        boolean equalsIgnoreCase(String str)        boolean contains(String str)        boolean startsWith(String str)        boolean endsWith(String str)        boolean isEmpty()</code></pre><h4 id="B-获取功能"><a href="#B-获取功能" class="headerlink" title="B:获取功能"></a>B:获取功能</h4><pre><code>        int length()        char charAt(int index)        int indexOf(int ch)        int indexOf(String str)        int indexOf(int ch,int fromIndex)        int indexOf(String str,int fromIndex)        String substring(int start)        String substring(int start,int end)</code></pre><h4 id="C-转换功能"><a href="#C-转换功能" class="headerlink" title="C:转换功能"></a>C:转换功能</h4><pre><code>        byte[] getBytes()        char[] toCharArray()        static String valueOf(char[] chs)        static String valueOf(int i)        String toLowerCase()        String toUpperCase()        String concat(String str)</code></pre><h4 id="D-其他功能"><a href="#D-其他功能" class="headerlink" title="D:其他功能"></a>D:其他功能</h4><pre><code>        a:替换功能             String replace(char old,char new)            String replace(String old,String new)        b:去空格功能            String trim()        c:按字典比较功能            int compareTo(String str)            int compareToIgnoreCase(String str) </code></pre><h3 id="6-字符串的案例"><a href="#6-字符串的案例" class="headerlink" title="(6)字符串的案例"></a>(6)字符串的案例</h3><pre><code>    A:模拟用户登录    B:字符串遍历    C:统计字符串中大写，小写及数字字符的个数    D:把字符串的首字母转成大写，其他小写    E:把int数组拼接成一个指定格式的字符串    F:字符串反转    G:统计大串中小串出现的次数</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day11</title>
      <link href="/2020/061131261.html"/>
      <url>/2020/061131261.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Eclipse的概述使用-掌握"><a href="#1-Eclipse的概述使用-掌握" class="headerlink" title="1:Eclipse的概述使用(掌握)"></a>1:Eclipse的概述使用(掌握)</h2><pre><code>请参照ppt和课堂练习.txt</code></pre><h2 id="2-API的概述-了解"><a href="#2-API的概述-了解" class="headerlink" title="2:API的概述(了解)"></a>2:API的概述(了解)</h2><h3 id="1-应用程序编程接口。"><a href="#1-应用程序编程接口。" class="headerlink" title="(1)应用程序编程接口。"></a>(1)应用程序编程接口。</h3><h3 id="2-就是JDK提供给我们的一些提高编程效率的java类。"><a href="#2-就是JDK提供给我们的一些提高编程效率的java类。" class="headerlink" title="(2)就是JDK提供给我们的一些提高编程效率的java类。"></a>(2)就是JDK提供给我们的一些提高编程效率的java类。</h3><h2 id="3-Object类-掌握"><a href="#3-Object类-掌握" class="headerlink" title="3:Object类(掌握)"></a>3:Object类(掌握)</h2><h3 id="1-Object是类层次结构的根类，所有的类都直接或者间接的继承自Object类。"><a href="#1-Object是类层次结构的根类，所有的类都直接或者间接的继承自Object类。" class="headerlink" title="(1)Object是类层次结构的根类，所有的类都直接或者间接的继承自Object类。"></a>(1)Object是类层次结构的根类，所有的类都直接或者间接的继承自Object类。</h3><h3 id="2-Object类的构造方法有一个，并且是无参构造"><a href="#2-Object类的构造方法有一个，并且是无参构造" class="headerlink" title="(2)Object类的构造方法有一个，并且是无参构造"></a>(2)Object类的构造方法有一个，并且是无参构造</h3><pre><code>    这其实就是理解当时我们说过，子类构造方法默认访问父类的构造是无参构造</code></pre><h3 id="3-要掌握的方法："><a href="#3-要掌握的方法：" class="headerlink" title="(3)要掌握的方法："></a>(3)要掌握的方法：</h3><h4 id="A-toString"><a href="#A-toString" class="headerlink" title="A:toString()"></a>A:toString()</h4><pre><code>        返回对象的字符串表示，默认是由类的全路径+&#39;@&#39;+哈希值的十六进制表示。        这个表示其实是没有意义的，一般子类都会重写该方法。        如何重写呢?过程我也讲解过了，基本上就是要求信息简单明了。        但是最终还是自动生成。</code></pre><h4 id="B-equals"><a href="#B-equals" class="headerlink" title="B:equals()"></a>B:equals()</h4><pre><code>        比较两个对象是否相同。默认情况下，比较的是地址值是否相同。        而比较地址值是没有意义的，所以，一般子类也会重写该方法。        重写过程，我也详细的讲解和分析了。        但是最终还是自动生成。</code></pre><h3 id="4-要了解的方法："><a href="#4-要了解的方法：" class="headerlink" title="(4)要了解的方法："></a>(4)要了解的方法：</h3><h4 id="A-hashCode"><a href="#A-hashCode" class="headerlink" title="A:hashCode()"></a>A:hashCode()</h4><pre><code>        返回对象的哈希值。不是实际地址值，可以理解为地址值。</code></pre><h4 id="B-getClass"><a href="#B-getClass" class="headerlink" title="B:getClass()"></a>B:getClass()</h4><pre><code>        返回对象的字节码文件对象，反射中我们会详细讲解    </code></pre><h4 id="C-finalize"><a href="#C-finalize" class="headerlink" title="C:finalize()"></a>C:finalize()</h4><pre><code>        用于垃圾回收，在不确定的时间</code></pre><h4 id="D-clone"><a href="#D-clone" class="headerlink" title="D:clone()"></a>D:clone()</h4><pre><code>        可以实现对象的克隆，包括成员变量的数据复制，但是它和两个引用指向同一个对象是有区别的。</code></pre><h3 id="5-两个注意问题；"><a href="#5-两个注意问题；" class="headerlink" title="(5)两个注意问题；"></a>(5)两个注意问题；</h3><h4 id="A-直接输出一个对象名称，其实默认调用了该对象的toString-方法。"><a href="#A-直接输出一个对象名称，其实默认调用了该对象的toString-方法。" class="headerlink" title="A:直接输出一个对象名称，其实默认调用了该对象的toString()方法。"></a>A:直接输出一个对象名称，其实默认调用了该对象的toString()方法。</h4><h4 id="B-面试题"><a href="#B-面试题" class="headerlink" title="B:面试题"></a>B:面试题</h4><pre><code>        ==和equals()的区别?        A:==            基本类型：比较的是值是否相同            引用类型：比较的是地址值是否相同        B:equals()            只能比较引用类型。默认情况下，比较的是地址值是否相同。            但是，我们可以根据自己的需要重写该方法。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day10</title>
      <link href="/2020/061047836.html"/>
      <url>/2020/061047836.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-形式参数和返回值的问题-理解"><a href="#1-形式参数和返回值的问题-理解" class="headerlink" title="1:形式参数和返回值的问题(理解)"></a>1:形式参数和返回值的问题(理解)</h2><h3 id="1-形式参数："><a href="#1-形式参数：" class="headerlink" title="(1)形式参数："></a>(1)形式参数：</h3><pre><code>    类名：需要该类的对象    抽象类名：需要该类的子类对象    接口名：需要该接口的实现类对象</code></pre><h3 id="2-返回值类型："><a href="#2-返回值类型：" class="headerlink" title="(2)返回值类型："></a>(2)返回值类型：</h3><pre><code>    类名：返回的是该类的对象    抽象类名：返回的是该类的子类对象    接口名：返回的是该接口的实现类的对象</code></pre><h3 id="3-链式编程"><a href="#3-链式编程" class="headerlink" title="(3)链式编程"></a>(3)链式编程</h3><pre><code>    对象.方法1().方法2().......方法n();    这种用法：其实在方法1()调用完毕后，应该一个对象；              方法2()调用完毕后，应该返回一个对象。              方法n()调用完毕后，可能是对象，也可以不是对象。</code></pre><h2 id="2-包-理解"><a href="#2-包-理解" class="headerlink" title="2:包(理解)"></a>2:包(理解)</h2><h3 id="1-其实就是文件夹"><a href="#1-其实就是文件夹" class="headerlink" title="(1)其实就是文件夹"></a>(1)其实就是文件夹</h3><h3 id="2-作用："><a href="#2-作用：" class="headerlink" title="(2)作用："></a>(2)作用：</h3><pre><code>    A:区分同名的类    B:对类进行分类管理        a:按照功能分        b:按照模块分</code></pre><h3 id="3-包的定义-掌握"><a href="#3-包的定义-掌握" class="headerlink" title="(3)包的定义(掌握)"></a>(3)包的定义(掌握)</h3><pre><code>    package 包名;    多级包用.分开。</code></pre><h3 id="4-注意事项：-掌握"><a href="#4-注意事项：-掌握" class="headerlink" title="(4)注意事项：(掌握)"></a>(4)注意事项：(掌握)</h3><pre><code>    A:package语句必须在文件中的第一条有效语句    B:在一个java文件中，只能有一个package    C:如果没有package，默认就是无包名</code></pre><h3 id="5-带包的编译和运行"><a href="#5-带包的编译和运行" class="headerlink" title="(5)带包的编译和运行"></a>(5)带包的编译和运行</h3><pre><code>    A:手动式    B:自动式(掌握)        javac -d . HelloWorld.java</code></pre><h2 id="3-导包-掌握"><a href="#3-导包-掌握" class="headerlink" title="3:导包(掌握)"></a>3:导包(掌握)</h2><h3 id="1-我们多次使用一个带包的类，非常的麻烦，这个时候，Java就提供了一个关键字import。"><a href="#1-我们多次使用一个带包的类，非常的麻烦，这个时候，Java就提供了一个关键字import。" class="headerlink" title="(1)我们多次使用一个带包的类，非常的麻烦，这个时候，Java就提供了一个关键字import。"></a>(1)我们多次使用一个带包的类，非常的麻烦，这个时候，Java就提供了一个关键字import。</h3><h3 id="2-格式："><a href="#2-格式：" class="headerlink" title="(2)格式："></a>(2)格式：</h3><pre><code>    import 包名...类名;    另一种：        import 包名...*;(不建议)</code></pre><h3 id="3-package-import-class的顺序"><a href="#3-package-import-class的顺序" class="headerlink" title="(3)package,import,class的顺序"></a>(3)package,import,class的顺序</h3><pre><code>    package &gt; import &gt; class</code></pre><h2 id="4-权限修饰符-掌握"><a href="#4-权限修饰符-掌握" class="headerlink" title="4:权限修饰符(掌握)"></a>4:权限修饰符(掌握)</h2><h3 id="1-权限修饰符"><a href="#1-权限修饰符" class="headerlink" title="(1)权限修饰符"></a>(1)权限修饰符</h3><pre><code>                本类    同一个包下    不同包下的子类    不同包下的无关类    private        Y    默认        Y        Y    protected    Y        Y            Y    public        Y        Y            Y                Y</code></pre><h3 id="2-这四种权限修饰符在任意时刻只能出现一种。"><a href="#2-这四种权限修饰符在任意时刻只能出现一种。" class="headerlink" title="(2)这四种权限修饰符在任意时刻只能出现一种。"></a>(2)这四种权限修饰符在任意时刻只能出现一种。</h3><pre><code>    public class Demo {}        </code></pre><h2 id="5-常见的修饰符-理解"><a href="#5-常见的修饰符-理解" class="headerlink" title="5:常见的修饰符(理解)"></a>5:常见的修饰符(理解)</h2><h3 id="1-分类："><a href="#1-分类：" class="headerlink" title="(1)分类："></a>(1)分类：</h3><pre><code>    权限修饰符：private,默认,protected,public    状态修饰符：static,final    抽象修饰符：abstract</code></pre><h3 id="2-常见的类及其组成的修饰"><a href="#2-常见的类及其组成的修饰" class="headerlink" title="(2)常见的类及其组成的修饰"></a>(2)常见的类及其组成的修饰</h3><pre><code>    类：        默认,public,final,abstract        常用的：public    成员变量：        private,默认,protected,public,static,final        常用的：private    构造方法：        private,默认,protected,public        常用的：public    成员方法：        private,默认,protected,public,static,final,abstract        常用的：public</code></pre><h3 id="3-另外比较常见的："><a href="#3-另外比较常见的：" class="headerlink" title="(3)另外比较常见的："></a>(3)另外比较常见的：</h3><pre><code>    public static final int X = 10;    public static void show() {}    public final void show() {}    public abstract void show();</code></pre><h2 id="6-内部类-理解"><a href="#6-内部类-理解" class="headerlink" title="6:内部类(理解)"></a>6:内部类(理解)</h2><h3 id="1-把类定义在另一个类的内部，该类就被称为内部类。"><a href="#1-把类定义在另一个类的内部，该类就被称为内部类。" class="headerlink" title="(1)把类定义在另一个类的内部，该类就被称为内部类。"></a>(1)把类定义在另一个类的内部，该类就被称为内部类。</h3><pre><code>    举例：把类B定义在类A中，类B就被称为内部类。</code></pre><h3 id="2-内部类的访问规则"><a href="#2-内部类的访问规则" class="headerlink" title="(2)内部类的访问规则"></a>(2)内部类的访问规则</h3><pre><code>    A:可以直接访问外部类的成员，包括私有    B:外部类要想访问内部类成员，必须创建对象</code></pre><h3 id="3-内部类的分类"><a href="#3-内部类的分类" class="headerlink" title="(3)内部类的分类"></a>(3)内部类的分类</h3><pre><code>    A:成员内部类    B:局部内部类</code></pre><h3 id="4-成员内部类"><a href="#4-成员内部类" class="headerlink" title="(4)成员内部类"></a>(4)成员内部类</h3><pre><code>    A:private 为了数据的安全性    B:static 为了访问的方便性    成员内部类不是静态的：        外部类名.内部类名 对象名 = new 外部类名.new 内部类名();    成员内部类是静态的：        外部类名.内部类名 对象名 = new 外部类名.内部类名();</code></pre><h3 id="5-成员内部类的面试题-填空"><a href="#5-成员内部类的面试题-填空" class="headerlink" title="(5)成员内部类的面试题(填空)"></a>(5)成员内部类的面试题(填空)</h3><pre><code>    30,20,10    class Outer {        public int num = 10;        class Inner {            public int num = 20;            public viod show() {                int num  = 30;                System.out.println(num);                System.out.println(this.num);                System.out.println(Outer.this.num);            }        }    }</code></pre><h3 id="6-局部内部类"><a href="#6-局部内部类" class="headerlink" title="(6)局部内部类"></a>(6)局部内部类</h3><pre><code>    A:局部内部类访问局部变量必须加final修饰。    B:为什么呢?        因为局部变量使用完毕就消失，而堆内存的数据并不会立即消失。        所以，堆内存还是用该变量，而改变量已经没有了。        为了让该值还存在，就加final修饰。        通过反编译工具我们看到了，加入final后，堆内存直接存储的是值，而不是变量名。</code></pre><h3 id="7-匿名内部类-掌握"><a href="#7-匿名内部类-掌握" class="headerlink" title="(7)匿名内部类(掌握)"></a>(7)匿名内部类(掌握)</h3><pre><code>    A:是局部内部类的简化形式    B:前提        存在一个类或者接口    C:格式:        new 类名或者接口名() {            重写方法;        }    D:本质：        其实是继承该类或者实现接口的子类匿名对象</code></pre><h3 id="8-匿名内部类在开发中的使用"><a href="#8-匿名内部类在开发中的使用" class="headerlink" title="(8)匿名内部类在开发中的使用"></a>(8)匿名内部类在开发中的使用</h3><pre><code>    我们在开发的时候，会看到抽象类，或者接口作为参数。    而这个时候，我们知道实际需要的是一个子类对象。    如果该方法仅仅调用一次，我们就可以使用匿名内部类的格式简化。    interface Person {        public abstract void study();    }    class PersonDemo {        public void method(Person p) {            p.study();        }    }    class PersonTest {        public static void main(String[] args) {            PersonDemo pd = new PersonDemo();            pd.method(new Person() {                public void study() {                    System.out.println(&quot;好好学习，天天向上&quot;);                }            });        }    }</code></pre><h3 id="9-匿名内部类的面试题-补齐代码"><a href="#9-匿名内部类的面试题-补齐代码" class="headerlink" title="(9)匿名内部类的面试题(补齐代码)"></a>(9)匿名内部类的面试题(补齐代码)</h3><pre><code>    interface Inter {        void show();    }    class Outer {        //补齐代码        public static Inter method() {            return new Inter() {                public void show() {                    System.out.println(&quot;HelloWorld&quot;);                }                };        }    }    class OuterDemo {        public static void main(String[] args) {            Outer.method().show(); //&quot;HelloWorld&quot;        }    }</code></pre><hr><p>1:形式参数和返回值问题   </p><pre><code>形式参数    基本类型    类名：需要该类的对象    引用类型    抽象类名：需要改类的子类对象                接口名：需要该接口的实现类对象返回值类型    基本类型    类名：返回的是该类的对象    引用类型    抽象类名：返回的是该类的子类对象                接口名：返回的是该接口的实现类的对象</code></pre><p>2:包的定义及注意事项  </p><pre><code>定义：package 报名;注意事项    A：package语句必须在文件中的定义一条有效语句            B：在一个Java文件中，只能有一个package            C：如果没有package，默认就是无包名</code></pre><p>3:导包及注意事项  </p><pre><code>（1）我们多次使用一个带包的类，非常麻烦，这个时候，Java就提供了一个关键字import（2）格式：            import 包名...类名；（3）package ，import，class的顺序        package&gt;import&gt;class</code></pre><p>4:四种权限修饰符及其特点  </p><pre><code>(1)权限修饰符                本类    同一个包下    不同包下的子类    不同包下的无关类    private        Y    默认        Y        Y    protected    Y        Y            Y    public        Y        Y            Y                Y(2)这四种权限修饰符在任意时刻只能出现一种。    public class Demo {}        </code></pre><p>5:常见的修饰符及组合  </p><pre><code>(1)分类：            权限修饰符：private,默认，protected，public            状态修饰符：static,final            抽象修饰符：abstract(2)常见的类及其组成的修饰    类：        默认,public,final,abstract        常用的：public    成员变量：        private,默认,protected,public,static,final        常用的：private    构造方法：        private,默认,protected,public        常用的：public    成员方法：        private,默认,protected,public,static,final,abstract        常用的：public(3)另外比较常见的：    public static final int X = 10;    public static void show() {}    public final void show() {}    public abstract void show();        </code></pre><p>6:内部类的概述及访问特点  </p><pre><code>(1)把类定义在另一个类的内部，该类就被称为内部类。    举例：把类B定义在类A中，类B就被称为内部类。(2)内部类的访问规则    A:可以直接访问外部类的成员，包括私有    B:外部类要想访问内部类成员，必须创建对象</code></pre><p>7:内部类的分类  </p><pre><code>(1)内部类的分类    A:成员内部类    B:局部内部类(2)成员内部类    A:private 为了数据的安全性    B:static 为了访问的方便性    成员内部类不是静态的：        外部类名.内部类名 对象名 = new 外部类名.new 内部类名();    成员内部类是静态的：        外部类名.内部类名 对象名 = new 外部类名.内部类名();(3)成员内部类的面试题(填空)    30,20,10    class Outer {        public int num = 10;        class Inner {            public int num = 20;            public viod show() {                int num  = 30;                System.out.println(num);                System.out.println(this.num);                System.out.println(Outer.this.num);            }        }    }(4)局部内部类    A:局部内部类访问局部变量必须加final修饰。    B:为什么呢?        因为局部变量使用完毕就消失，而堆内存的数据并不会立即消失。        所以，堆内存还是用该变量，而改变量已经没有了。        为了让该值还存在，就加final修饰。        通过反编译工具我们看到了，加入final后，堆内存直接存储的是值，而不是变量名。(5)匿名内部类(掌握)    A:是局部内部类的简化形式    B:前提        存在一个类或者接口    C:格式:        new 类名或者接口名() {            重写方法;        }    D:本质：        其实是继承该类或者实现接口的子类匿名对象</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day09</title>
      <link href="/2020/060911293.html"/>
      <url>/2020/060911293.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-final关键字-掌握"><a href="#1-final关键字-掌握" class="headerlink" title="1:final关键字(掌握)"></a>1:final关键字(掌握)</h2><h3 id="1-是最终的意思，可以修饰类，方法，变量。"><a href="#1-是最终的意思，可以修饰类，方法，变量。" class="headerlink" title="(1)是最终的意思，可以修饰类，方法，变量。"></a>(1)是最终的意思，可以修饰类，方法，变量。</h3><h3 id="2-特点："><a href="#2-特点：" class="headerlink" title="(2)特点："></a>(2)特点：</h3><pre><code>    A:它修饰的类，不能被继承。    B:它修饰的方法，不能被重写。    C:它修饰的变量，是一个常量。</code></pre><h3 id="3-面试相关："><a href="#3-面试相关：" class="headerlink" title="(3)面试相关："></a>(3)面试相关：</h3><pre><code>    A:局部变量        a:基本类型 值不能发生改变        b:引用类型 地址值不能发生改变，但是对象的内容是可以改变的    B:初始化时机        a:只能初始化一次。        b:常见的给值            定义的时候。(推荐)            构造方法中。</code></pre><h2 id="2-多态-掌握"><a href="#2-多态-掌握" class="headerlink" title="2:多态(掌握)"></a>2:多态(掌握)</h2><h3 id="1-同一个对象在不同时刻体现出来的不同状态。"><a href="#1-同一个对象在不同时刻体现出来的不同状态。" class="headerlink" title="(1)同一个对象在不同时刻体现出来的不同状态。"></a>(1)同一个对象在不同时刻体现出来的不同状态。</h3><h3 id="2-多态的前提："><a href="#2-多态的前提：" class="headerlink" title="(2)多态的前提："></a>(2)多态的前提：</h3><pre><code>    A:有继承或者实现关系。    B:有方法重写。    C:有父类或者父接口引用指向子类对象。    多态的分类：        a:具体类多态            class Fu {}            class Zi extends Fu {}            Fu f = new Zi();        b:抽象类多态            abstract class Fu {}            class Zi extends Fu {}            Fu f = new Zi();        c:接口多态            interface Fu {}            class Zi implements Fu {}            Fu f = new Zi();</code></pre><h3 id="3-多态中的成员访问特点"><a href="#3-多态中的成员访问特点" class="headerlink" title="(3)多态中的成员访问特点"></a>(3)多态中的成员访问特点</h3><pre><code>    A:成员变量        编译看左边，运行看左边    B:构造方法        子类的构造都会默认访问父类构造    C:成员方法        编译看左边，运行看右边    D:静态方法        编译看左边，运行看左边    为什么?        因为成员方法有重写。</code></pre><h3 id="4-多态的好处："><a href="#4-多态的好处：" class="headerlink" title="(4)多态的好处："></a>(4)多态的好处：</h3><pre><code>    A:提高代码的维护性(继承体现)    B:提高代码的扩展性(多态体现)</code></pre><h3 id="5-多态的弊端："><a href="#5-多态的弊端：" class="headerlink" title="(5)多态的弊端："></a>(5)多态的弊端：</h3><pre><code>    父不能使用子的特有功能。    现象：        子可以当作父使用，父不能当作子使用。</code></pre><h3 id="6-多态中的转型"><a href="#6-多态中的转型" class="headerlink" title="(6)多态中的转型"></a>(6)多态中的转型</h3><pre><code>    A:向上转型        从子到父    B:向下转型        从父到子</code></pre><h3 id="7-孔子装爹的案例帮助大家理解多态"><a href="#7-孔子装爹的案例帮助大家理解多态" class="headerlink" title="(7)孔子装爹的案例帮助大家理解多态"></a>(7)孔子装爹的案例帮助大家理解多态</h3><h3 id="8-多态的练习"><a href="#8-多态的练习" class="headerlink" title="(8)多态的练习"></a>(8)多态的练习</h3><pre><code>    A:猫狗案例    B:老师和学生案例</code></pre><h2 id="3-抽象类-掌握"><a href="#3-抽象类-掌握" class="headerlink" title="3:抽象类(掌握)"></a>3:抽象类(掌握)</h2><h3 id="1-把多个共性的东西提取到一个类中，这是继承的做法。"><a href="#1-把多个共性的东西提取到一个类中，这是继承的做法。" class="headerlink" title="(1)把多个共性的东西提取到一个类中，这是继承的做法。"></a>(1)把多个共性的东西提取到一个类中，这是继承的做法。</h3><pre><code>   但是呢，这多个共性的东西，在有些时候，方法声明一样，但是方法体。   也就是说，方法声明一样，但是每个具体的对象在具体实现的时候内容不一样。   所以，我们在定义这些共性的方法的时候，就不能给出具体的方法体。   而一个没有具体的方法体的方法是抽象的方法。   在一个类中如果有抽象方法，该类必须定义为抽象类。</code></pre><h3 id="2-抽象类的特点"><a href="#2-抽象类的特点" class="headerlink" title="(2)抽象类的特点"></a>(2)抽象类的特点</h3><pre><code>    A:抽象类和抽象方法必须用关键字abstract修饰    B:抽象类中不一定有抽象方法,但是有抽象方法的类一定是抽象类    C:抽象类不能实例化    D:抽象类的子类        a:是一个抽象类。        b:是一个具体类。这个类必须重写抽象类中的所有抽象方法。</code></pre><h3 id="3-抽象类的成员特点："><a href="#3-抽象类的成员特点：" class="headerlink" title="(3)抽象类的成员特点："></a>(3)抽象类的成员特点：</h3><pre><code>    A:成员变量        有变量，有常量    B:构造方法        有构造方法    C:成员方法        有抽象，有非抽象</code></pre><h3 id="4-抽象类的练习"><a href="#4-抽象类的练习" class="headerlink" title="(4)抽象类的练习"></a>(4)抽象类的练习</h3><pre><code>    A:猫狗案例练习    B:老师案例练习    C:学生案例练习    D:员工案例练习</code></pre><h3 id="5-抽象类的几个小问题"><a href="#5-抽象类的几个小问题" class="headerlink" title="(5)抽象类的几个小问题"></a>(5)抽象类的几个小问题</h3><pre><code>    A:抽象类有构造方法，不能实例化，那么构造方法有什么用?        用于子类访问父类数据的初始化    B:一个类如果没有抽象方法,却定义为了抽象类，有什么用?        为了不让创建对象    C:abstract不能和哪些关键字共存        a:final    冲突        b:private 冲突        c:static 无意义</code></pre><h2 id="4-接口-掌握"><a href="#4-接口-掌握" class="headerlink" title="4:接口(掌握)"></a>4:接口(掌握)</h2><h3 id="1-回顾猫狗案例，它们仅仅提供一些基本功能。"><a href="#1-回顾猫狗案例，它们仅仅提供一些基本功能。" class="headerlink" title="(1)回顾猫狗案例，它们仅仅提供一些基本功能。"></a>(1)回顾猫狗案例，它们仅仅提供一些基本功能。</h3><pre><code>   比如：猫钻火圈，狗跳高等功能，不是动物本身就具备的，   是在后面的培养中训练出来的，这种额外的功能，java提供了接口表示。</code></pre><h3 id="2-接口的特点："><a href="#2-接口的特点：" class="headerlink" title="(2)接口的特点："></a>(2)接口的特点：</h3><pre><code>    A:接口用关键字interface修饰        interface 接口名 {}    B:类实现接口用implements修饰        class 类名 implements 接口名 {}    C:接口不能实例化    D:接口的实现类        a:是一个抽象类。        b:是一个具体类，这个类必须重写接口中的所有抽象方法。</code></pre><h3 id="3-接口的成员特点："><a href="#3-接口的成员特点：" class="headerlink" title="(3)接口的成员特点："></a>(3)接口的成员特点：</h3><pre><code>    A:成员变量        只能是常量        默认修饰符：public static final    B:构造方法        没有构造方法    C:成员方法        只能是抽象的        默认修饰符：public abstract</code></pre><h3 id="4-类与类-类与接口-接口与接口"><a href="#4-类与类-类与接口-接口与接口" class="headerlink" title="(4)类与类,类与接口,接口与接口"></a>(4)类与类,类与接口,接口与接口</h3><pre><code>    A:类与类        继承关系，只能单继承，可以多层继承    B:类与接口        实现关系，可以单实现，也可以多实现。        还可以在继承一个类的同时，实现多个接口    C:接口与接口        继承关系，可以单继承，也可以多继承</code></pre><h3 id="5-抽象类和接口的区别-自己补齐"><a href="#5-抽象类和接口的区别-自己补齐" class="headerlink" title="(5)抽象类和接口的区别(自己补齐)?"></a>(5)抽象类和接口的区别(自己补齐)?</h3><pre><code>    A:成员区别        抽象类：        接口：    B:关系区别:        类与类：        类与接口：        接口与接口：    C:设计理念不同        抽象类：is a，抽象类中定义的是共性功能。        接口：like a，接口中定义的是扩展功能。</code></pre><h3 id="6-练习："><a href="#6-练习：" class="headerlink" title="(6)练习："></a>(6)练习：</h3><pre><code>    A:猫狗案例，加入跳高功能    B:老师和学生案例，加入抽烟功能0</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day08</title>
      <link href="/2020/060860636.html"/>
      <url>/2020/060860636.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-如何制作帮助文档-了解"><a href="#1-如何制作帮助文档-了解" class="headerlink" title="1:如何制作帮助文档(了解)"></a>1:如何制作帮助文档(了解)</h2><h3 id="1-写一个类"><a href="#1-写一个类" class="headerlink" title="(1)写一个类"></a>(1)写一个类</h3><h3 id="2-加入文档注释"><a href="#2-加入文档注释" class="headerlink" title="(2)加入文档注释"></a>(2)加入文档注释</h3><h3 id="3-通过javadoc工具生成即可"><a href="#3-通过javadoc工具生成即可" class="headerlink" title="(3)通过javadoc工具生成即可"></a>(3)通过javadoc工具生成即可</h3><pre><code>    javadoc -d 目录 -author -version ArrayTool.java</code></pre><h2 id="2-通过JDK提供的API学习了Math类-掌握"><a href="#2-通过JDK提供的API学习了Math类-掌握" class="headerlink" title="2:通过JDK提供的API学习了Math类(掌握)"></a>2:通过JDK提供的API学习了Math类(掌握)</h2><h3 id="1-API-Application-Programming-Interface"><a href="#1-API-Application-Programming-Interface" class="headerlink" title="(1)API(Application Programming Interface)"></a>(1)API(Application Programming Interface)</h3><pre><code>    应用程序编程接口(帮助文档)</code></pre><h3 id="2-如何使用呢"><a href="#2-如何使用呢" class="headerlink" title="(2)如何使用呢?"></a>(2)如何使用呢?</h3><pre><code>    请参照        day08\code\02_如何使用JDK提供的帮助文档\如何使用帮助文档.txt</code></pre><h3 id="3-Math类"><a href="#3-Math类" class="headerlink" title="(3)Math类"></a>(3)Math类</h3><pre><code>    A:是针对数学进行操作的类    B:没有构造方法，因为它的成员都是静态的    C:产生随机数        public static double random(): [0.0,1.0)    D:如何产生一个1-100之间的随机数        int number = (int)(Math.random()*100)+1;    E:猜数字小游戏</code></pre><h2 id="3-代码块-理解"><a href="#3-代码块-理解" class="headerlink" title="3:代码块(理解)"></a>3:代码块(理解)</h2><h3 id="1-用-括起来的代码。"><a href="#1-用-括起来的代码。" class="headerlink" title="(1)用{}括起来的代码。"></a>(1)用{}括起来的代码。</h3><h3 id="2-分类："><a href="#2-分类：" class="headerlink" title="(2)分类："></a>(2)分类：</h3><pre><code>    A:局部代码块        用于限定变量的生命周期，及早释放，提高内存利用率。    B:构造代码块        把多个构造方法中相同的代码可以放到这里，每个构造方法执行前，首先执行构造代码块。    C:静态代码块        对类的数据进行初始化，仅仅只执行一次。</code></pre><h3 id="3-静态代码块-构造代码块-构造方法的顺序问题"><a href="#3-静态代码块-构造代码块-构造方法的顺序问题" class="headerlink" title="(3)静态代码块,构造代码块,构造方法的顺序问题?"></a>(3)静态代码块,构造代码块,构造方法的顺序问题?</h3><pre><code>    静态代码块 &gt; 构造代码块 &gt; 构造方法</code></pre><h2 id="4-继承-掌握"><a href="#4-继承-掌握" class="headerlink" title="4:继承(掌握)"></a>4:继承(掌握)</h2><h3 id="1-把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该独立的类产生一个关系，"><a href="#1-把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该独立的类产生一个关系，" class="headerlink" title="(1)把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该独立的类产生一个关系，"></a>(1)把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该独立的类产生一个关系，</h3><pre><code>   这多个类就具备了这些内容。这个关系叫继承。</code></pre><h3 id="2-Java中如何表示继承呢-格式是什么呢"><a href="#2-Java中如何表示继承呢-格式是什么呢" class="headerlink" title="(2)Java中如何表示继承呢?格式是什么呢?"></a>(2)Java中如何表示继承呢?格式是什么呢?</h3><pre><code>    A:用关键字extends表示    B:格式：        class 子类名 extends 父类名 {}</code></pre><h3 id="3-继承的好处："><a href="#3-继承的好处：" class="headerlink" title="(3)继承的好处："></a>(3)继承的好处：</h3><pre><code>    A:提高了代码的复用性    B:提高了代码的维护性    C:让类与类产生了一个关系，是多态的前提</code></pre><h3 id="4-继承的弊端："><a href="#4-继承的弊端：" class="headerlink" title="(4)继承的弊端："></a>(4)继承的弊端：</h3><pre><code>    A:让类的耦合性增强。这样某个类的改变，就会影响其他和该类相关的类。        原则：低耦合，高内聚。        耦合：类与类的关系        内聚：自己完成某件事情的能力    B:打破了封装性</code></pre><h3 id="5-Java中继承的特点"><a href="#5-Java中继承的特点" class="headerlink" title="(5)Java中继承的特点"></a>(5)Java中继承的特点</h3><pre><code>    A:Java中类只支持单继承    B:Java中可以多层(重)继承(继承体系)</code></pre><h3 id="6-继承的注意事项："><a href="#6-继承的注意事项：" class="headerlink" title="(6)继承的注意事项："></a>(6)继承的注意事项：</h3><pre><code>    A:子类不能继承父类的私有成员    B:子类不能继承父类的构造方法，但是可以通过super去访问    C:不要为了部分功能而去继承</code></pre><h3 id="7-什么时候使用继承呢"><a href="#7-什么时候使用继承呢" class="headerlink" title="(7)什么时候使用继承呢?"></a>(7)什么时候使用继承呢?</h3><pre><code>    A:继承体现的是：is a的关系。    B:采用假设法</code></pre><h3 id="8-Java继承中的成员关系"><a href="#8-Java继承中的成员关系" class="headerlink" title="(8)Java继承中的成员关系"></a>(8)Java继承中的成员关系</h3><pre><code>    A:成员变量        a:子类的成员变量名称和父类中的成员变量名称不一样，这个太简单        b:子类的成员变量名称和父类中的成员变量名称一样，这个怎么访问呢?            子类的方法访问变量的查找顺序：                在子类方法的局部范围找，有就使用。                在子类的成员范围找，有就使用。                在父类的成员范围找，有就使用。                找不到，就报错。    B:构造方法        a:子类的构造方法默认会去访问父类的无参构造方法            是为了子类访问父类数据的初始化        b:父类中如果没有无参构造方法，怎么办?            子类通过super去明确调用带参构造            子类通过this调用本身的其他构造，但是一定会有一个去访问了父类的构造            让父类提供无参构造    C:成员方法        a:子类的成员方法和父类中的成员方法名称不一样，这个太简单        b:子类的成员方法和父类中的成员方法名称一样，这个怎么访问呢?            通过子类对象访问一个方法的查找顺序：                在子类中找，有就使用                在父类中找，有就使用                找不到，就报错</code></pre><h3 id="9-两个面试题："><a href="#9-两个面试题：" class="headerlink" title="(9)两个面试题："></a>(9)两个面试题：</h3><pre><code>    A:Override和Overload的区别?Overload是否可以改变返回值类型?    B:this和super的区别和各自的作用?</code></pre><h3 id="10-数据初始化的面试题"><a href="#10-数据初始化的面试题" class="headerlink" title="(10)数据初始化的面试题"></a>(10)数据初始化的面试题</h3><pre><code>    A:一个类的初始化过程    B:子父类的构造执行过程    C:分层初始化</code></pre><h3 id="11-案例："><a href="#11-案例：" class="headerlink" title="(11)案例："></a>(11)案例：</h3><pre><code>    A:学生和老师案例        继承前        继承后    B:猫狗案例的分析和实现</code></pre><p>1:代码块是什么?代码块的分类和各自特点?  </p><p>用{}括起来的代码。<br>分类：<br>A：局部代码块：用于限定变量的生命周期，及早释放，提高内存利用率<br>B：构造代码块：把多个构造方法中相同的代码可以放到这里，每个构造方法执行前，首先执行构造代码块。<br>C：静态大妈快：对类的数据进行初始化，仅仅只执行一次。<br>静态代码块&gt;构造代码块&gt;局部代码块</p><p>2:静态代码块,构造代码块,构造方法的执行流程?    </p><p>3:继承概述  </p><p>把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该独立的类产生一个关系，这多个类就具备了这些内容，这个关系叫继承。</p><p>4:继承的好处  </p><p>A：提高了代码的复用性<br>B：提高了代码的维护性<br>C：让类与类产生了一个关系，是多态的前提</p><p>5:Java中继承的特点  </p><p>A：Java中类只支持单继承<br>B：Java中可以多层继承</p><p>6:Java中继承的注意事项?以及我们什么时候使用继承?  </p><p>A：子类不能继承父类的私有成员<br>B：子类不能继承父类的构造方法，但是可以通过super去访问<br>C：不要为了部分功能而去继承</p><p>A：继承体现的是： is a的关系<br>B：采用假设法</p><p>7:继承中的成员访问特点  </p><pre><code>A:成员变量    在子类方法中访问一个变量B:成员方法    在测试类中通过子类对象去访问一个方法</code></pre><p>8:继承中构造方法的执行流程?假如父类没有无参构造方法，子类应该怎么办?  </p><p>A：子类的构造方法默认会去访问父类的无参构造方法，是为了子类访问父类数据的初始化<br>B：            子类通过super去明确调用带参构造<br>    子类通过this调用本身的其他构造，但是一定会有一个去访问了父类的构造<br>    让父类提供无参构造<br>9:面试题：  </p><pre><code>方法重写和方法重载的区别?方法重载能改变返回值类型吗?Overload （方法重载）同一个类中，出现的方法名相同，参数列表不同的现象Override    （方法重写）在子类中，出现和父类中一摸一样的方法声明的现象方法重载能改变返回值类型，因为它和返回值类型无关this关键字和super关键字分别代表什么?以及他们各自的使用场景和作用。    this：代表当前类的对象引用    super：代表父类存储空间的标识。（可以理解为父类的引用，通过这个东西可以访问父类的成员）</code></pre><p>10:继承案例练习  </p><p>11:猜数字小游戏练习。  </p><pre><code>通过API学习并使用Math类的random()方法。        </code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day07</title>
      <link href="/2020/060759548.html"/>
      <url>/2020/060759548.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-成员变量和局部变量的区别-理解"><a href="#1-成员变量和局部变量的区别-理解" class="headerlink" title="1:成员变量和局部变量的区别(理解)"></a>1:成员变量和局部变量的区别(理解)</h2><h3 id="1-在类中的位置不同"><a href="#1-在类中的位置不同" class="headerlink" title="(1)在类中的位置不同"></a>(1)在类中的位置不同</h3><pre><code>    成员变量：类中方法外    局部变量：方法定义中或者方法声明上</code></pre><h3 id="2-在内存中的位置不同"><a href="#2-在内存中的位置不同" class="headerlink" title="(2)在内存中的位置不同"></a>(2)在内存中的位置不同</h3><pre><code>    成员变量：在堆中    局部变量：在栈中</code></pre><h3 id="3-生命周期不同"><a href="#3-生命周期不同" class="headerlink" title="(3)生命周期不同"></a>(3)生命周期不同</h3><pre><code>    成员变量：随着对象的创建而存在，随着对象的消失而消失    局部变量：随着方法的调用而存在，随着方法的调用完毕而消失</code></pre><h3 id="4-初始化值不同"><a href="#4-初始化值不同" class="headerlink" title="(4)初始化值不同"></a>(4)初始化值不同</h3><pre><code>    成员变量：有默认值    局部变量：没有默认值，必须定义，赋值，然后才能使用</code></pre><h2 id="2-类作为形式参数的问题-理解"><a href="#2-类作为形式参数的问题-理解" class="headerlink" title="2:类作为形式参数的问题?(理解)"></a>2:类作为形式参数的问题?(理解)</h2><h3 id="1-如果你看到一个方法需要的参数是一个类名，就应该知道这里实际需要的是一个具体的对象。"><a href="#1-如果你看到一个方法需要的参数是一个类名，就应该知道这里实际需要的是一个具体的对象。" class="headerlink" title="(1)如果你看到一个方法需要的参数是一个类名，就应该知道这里实际需要的是一个具体的对象。"></a>(1)如果你看到一个方法需要的参数是一个类名，就应该知道这里实际需要的是一个具体的对象。</h3><h2 id="3-匿名对象-理解"><a href="#3-匿名对象-理解" class="headerlink" title="3:匿名对象(理解)"></a>3:匿名对象(理解)</h2><h3 id="1-没有名字的对象"><a href="#1-没有名字的对象" class="headerlink" title="(1)没有名字的对象"></a>(1)没有名字的对象</h3><h3 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="(2)应用场景"></a>(2)应用场景</h3><pre><code>    A:调用方法，仅仅只调用一次的时候。    b:可以作为实际参数传递。</code></pre><h2 id="4-封装-理解"><a href="#4-封装-理解" class="headerlink" title="4:封装(理解)"></a>4:封装(理解)</h2><h3 id="1-隐藏实现细节，提供公共的访问方式"><a href="#1-隐藏实现细节，提供公共的访问方式" class="headerlink" title="(1)隐藏实现细节，提供公共的访问方式"></a>(1)隐藏实现细节，提供公共的访问方式</h3><h3 id="2-好处："><a href="#2-好处：" class="headerlink" title="(2)好处："></a>(2)好处：</h3><pre><code>    A:隐藏实现细节，提供公共的访问方式    B:提高代码的复用性    C:提高代码的安全性</code></pre><h3 id="3-设计原则"><a href="#3-设计原则" class="headerlink" title="(3)设计原则"></a>(3)设计原则</h3><pre><code>    把不想让外界知道的实现细节给隐藏起来，提供公共的访问方式</code></pre><h3 id="4-private是封装的一种体现。"><a href="#4-private是封装的一种体现。" class="headerlink" title="(4)private是封装的一种体现。"></a>(4)private是封装的一种体现。</h3><pre><code>    封装：类，方法，private修饰成员变量</code></pre><h2 id="private关键字-掌握"><a href="#private关键字-掌握" class="headerlink" title=":private关键字(掌握)"></a>:private关键字(掌握)</h2><h3 id="1-私有的意义，可以修饰成员变量和成员方法"><a href="#1-私有的意义，可以修饰成员变量和成员方法" class="headerlink" title="(1)私有的意义，可以修饰成员变量和成员方法"></a>(1)私有的意义，可以修饰成员变量和成员方法</h3><h3 id="2-特点："><a href="#2-特点：" class="headerlink" title="(2)特点："></a>(2)特点：</h3><pre><code>    被private修饰的后的成员只能在本类中被访问</code></pre><h3 id="3-private的应用："><a href="#3-private的应用：" class="headerlink" title="(3)private的应用："></a>(3)private的应用：</h3><pre><code>    以后再写一个类的时候：        把所有的成员变量给private了        提供对应的getXxx()/setXxx()方法</code></pre><h2 id="6-this关键字-掌握"><a href="#6-this关键字-掌握" class="headerlink" title="6:this关键字(掌握)"></a>6:this关键字(掌握)</h2><h3 id="1-代表当前类的引用对象"><a href="#1-代表当前类的引用对象" class="headerlink" title="(1)代表当前类的引用对象"></a>(1)代表当前类的引用对象</h3><pre><code>    记住：哪个对象调用方法，该方法内部的this就代表那个对象</code></pre><h3 id="2-this的应用场景："><a href="#2-this的应用场景：" class="headerlink" title="(2)this的应用场景："></a>(2)this的应用场景：</h3><pre><code>    A:解决了局部变量隐藏成员变量的问题    B:其实this还有其他的应用，明天讲解。</code></pre><h2 id="7-构造方法-掌握"><a href="#7-构造方法-掌握" class="headerlink" title="7:构造方法(掌握)"></a>7:构造方法(掌握)</h2><h3 id="1-作用：用于对对象的数据进行初始化"><a href="#1-作用：用于对对象的数据进行初始化" class="headerlink" title="(1)作用：用于对对象的数据进行初始化"></a>(1)作用：用于对对象的数据进行初始化</h3><h3 id="2-格式："><a href="#2-格式：" class="headerlink" title="(2)格式："></a>(2)格式：</h3><pre><code>    A:方法名和类名相同    B:没有返回值类型，连void都不能有    C:没有返回值    思考题：构造方法中可不可以有return语句呢?    可以。而是我们写成这个样子就OK了：return;    其实，在任何的void类型的方法的最后你都可以写上：return;</code></pre><h3 id="3-构造方法的注意事项"><a href="#3-构造方法的注意事项" class="headerlink" title="(3)构造方法的注意事项"></a>(3)构造方法的注意事项</h3><pre><code>    A:如果我们没写构造方法，系统将提供一个默认的无参构造方法    B:如果我们给出了构造方法，系统将不再提供默认构造方法        如果这个时候，我们要使用无参构造方法，就必须自己给出。        推荐：永远手动自己给出无参构造方法。</code></pre><h3 id="4-给成员变量赋值的方式"><a href="#4-给成员变量赋值的方式" class="headerlink" title="(4)给成员变量赋值的方式"></a>(4)给成员变量赋值的方式</h3><pre><code>    A:setXxx()    B:带参构造方法</code></pre><h3 id="5-标准案例"><a href="#5-标准案例" class="headerlink" title="(5)标准案例"></a>(5)标准案例</h3><pre><code>    class Student {        private String name;        private int age;        public Student(){}        public Student(String name,int age) {            this.name = name;            this.age = age;        }        public String getName() {            return name;        }        public void setName(String name) {            this.name = name;        }        public int getAge() {            return age;        }        public void setAge(int age) {            this.age = age;        }    }    测试：    class StudentDemo {        public static void main(String[] args) {            //方式1            Student s1 = new Student();            s1.setName(&quot;林青霞&quot;);            s1.setAge(27);            System.out.println(s1.getName()+&quot;---&quot;+s1.getAge());            //方式2            Student s2 = new Student(&quot;刘意&quot;,30);            System.out.println(s2.getName()+&quot;---&quot;+s2.getAge());        }    }</code></pre><h2 id="8-代码：Student-s-new-Student-做了哪些事情-理解"><a href="#8-代码：Student-s-new-Student-做了哪些事情-理解" class="headerlink" title="8:代码：Student s = new Student();做了哪些事情?(理解)"></a>8:代码：Student s = new Student();做了哪些事情?(理解)</h2><h3 id="1-把Student-class文件加载到内存"><a href="#1-把Student-class文件加载到内存" class="headerlink" title="(1)把Student.class文件加载到内存"></a>(1)把Student.class文件加载到内存</h3><h3 id="2-在栈内存为s开辟空间"><a href="#2-在栈内存为s开辟空间" class="headerlink" title="(2)在栈内存为s开辟空间"></a>(2)在栈内存为s开辟空间</h3><h3 id="3-在堆内存为学生对象申请空间"><a href="#3-在堆内存为学生对象申请空间" class="headerlink" title="(3)在堆内存为学生对象申请空间"></a>(3)在堆内存为学生对象申请空间</h3><h3 id="4-给学生的成员变量进行默认初始化。null-0"><a href="#4-给学生的成员变量进行默认初始化。null-0" class="headerlink" title="(4)给学生的成员变量进行默认初始化。null,0"></a>(4)给学生的成员变量进行默认初始化。null,0</h3><h3 id="5-给学生的成员变量进行显示初始化。林青霞-27"><a href="#5-给学生的成员变量进行显示初始化。林青霞-27" class="headerlink" title="(5)给学生的成员变量进行显示初始化。林青霞,27"></a>(5)给学生的成员变量进行显示初始化。林青霞,27</h3><h3 id="6-通过构造方法给成员变量进行初始化。刘意-30"><a href="#6-通过构造方法给成员变量进行初始化。刘意-30" class="headerlink" title="(6)通过构造方法给成员变量进行初始化。刘意,30"></a>(6)通过构造方法给成员变量进行初始化。刘意,30</h3><h3 id="7-对象构造完毕，把地址赋值给s变量"><a href="#7-对象构造完毕，把地址赋值给s变量" class="headerlink" title="(7)对象构造完毕，把地址赋值给s变量"></a>(7)对象构造完毕，把地址赋值给s变量</h3><p>9:面向对象的练习题(掌握)  </p><h3 id="1-标准的手机类的定义和测试"><a href="#1-标准的手机类的定义和测试" class="headerlink" title="(1)标准的手机类的定义和测试"></a>(1)标准的手机类的定义和测试</h3><h3 id="2-Demo类有求和方法，Test类进行测试。"><a href="#2-Demo类有求和方法，Test类进行测试。" class="headerlink" title="(2)Demo类有求和方法，Test类进行测试。"></a>(2)Demo类有求和方法，Test类进行测试。</h3><pre><code>    什么时候定义成员变量?    当该变量是用来描述一个类的时候。</code></pre><h3 id="3-长方形案例"><a href="#3-长方形案例" class="headerlink" title="(3)长方形案例"></a>(3)长方形案例</h3><h3 id="4-员工案例"><a href="#4-员工案例" class="headerlink" title="(4)员工案例"></a>(4)员工案例</h3><h3 id="5-MyMath案例-自己提供加减乘除并测试"><a href="#5-MyMath案例-自己提供加减乘除并测试" class="headerlink" title="(5)MyMath案例(自己提供加减乘除并测试)"></a>(5)MyMath案例(自己提供加减乘除并测试)</h3><h2 id="10-static关键字-理解"><a href="#10-static关键字-理解" class="headerlink" title="10:static关键字(理解)"></a>10:static关键字(理解)</h2><h3 id="1-静态的意思。可以修饰成员变量和成员方法。"><a href="#1-静态的意思。可以修饰成员变量和成员方法。" class="headerlink" title="(1)静态的意思。可以修饰成员变量和成员方法。"></a>(1)静态的意思。可以修饰成员变量和成员方法。</h3><h3 id="2-静态的特点："><a href="#2-静态的特点：" class="headerlink" title="(2)静态的特点："></a>(2)静态的特点：</h3><pre><code>    A:随着类的加载而加载    B:优先与对象存在    C:被类的所有对象共享        这其实也是我们判断该不该使用静态的依据。        举例：饮水机和水杯的问题思考    D:可以通过类名调用        既可以通过对象名调用，也可以通过类名调用，建议通过类名调用。</code></pre><h3 id="3-静态的内存图"><a href="#3-静态的内存图" class="headerlink" title="(3)静态的内存图"></a>(3)静态的内存图</h3><pre><code>    静态的内容在方法区的静态区</code></pre><h3 id="4-静态的注意事项；"><a href="#4-静态的注意事项；" class="headerlink" title="(4)静态的注意事项；"></a>(4)静态的注意事项；</h3><pre><code>    A:在静态方法中没有this对象    B:静态只能访问静态(代码测试过)</code></pre><h3 id="5-静态变量和成员变量的区别"><a href="#5-静态变量和成员变量的区别" class="headerlink" title="(5)静态变量和成员变量的区别"></a>(5)静态变量和成员变量的区别</h3><pre><code>    A:所属不同        静态变量：属于类，类变量        成员变量：属于对象，对象变量，实例变量    B:内存位置不同        静态变量：方法区的静态区        成员变量：堆内存    C:生命周期不同        静态变量：静态变量是随着类的加载而加载，随着类的消失而消失        成员变量：成员变量是随着对象的创建而存在，随着对象的消失而消失    D:调用不同        静态变量：可以通过对象名调用，也可以通过类名调用        成员变量：只能通过对象名调用</code></pre><h3 id="6-main方法是静态的"><a href="#6-main方法是静态的" class="headerlink" title="(6)main方法是静态的"></a>(6)main方法是静态的</h3><pre><code>    public:权限最大    static:不用创建对象调用    void:返回值给jvm没有意义    main:就是一个常见的名称。    String[] args:可以接收数据，提供程序的灵活性        格式：java MainDemo hello world java              java MainDemo 10 20 30</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day06</title>
      <link href="/2020/060610333.html"/>
      <url>/2020/060610333.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-二维数组-理解"><a href="#1-二维数组-理解" class="headerlink" title="1:二维数组(理解)"></a>1:二维数组(理解)</h2><h3 id="1-元素是一维数组的数组。"><a href="#1-元素是一维数组的数组。" class="headerlink" title="(1)元素是一维数组的数组。"></a>(1)元素是一维数组的数组。</h3><h3 id="2-格式："><a href="#2-格式：" class="headerlink" title="(2)格式："></a>(2)格式：</h3><pre><code>    A:数据类型[][] 数组名 = new 数据类型[m][n];    B:数据类型[][] 数组名 = new 数据类型[m][];    C:数据类型[][] 数组名 = new 数据类型[][]{{...},{...},{...}};    D:数据类型[][] 数组名 = {{...},{...},{...}};</code></pre><h3 id="3-案例-掌握"><a href="#3-案例-掌握" class="headerlink" title="(3)案例(掌握):"></a>(3)案例(掌握):</h3><pre><code>    A:二维数组的遍历    B:二维数组的求和    C:杨辉三角形</code></pre><h2 id="2-两个思考题-理解"><a href="#2-两个思考题-理解" class="headerlink" title="2:两个思考题(理解)"></a>2:两个思考题(理解)</h2><h3 id="1-Java中的参数传递问题"><a href="#1-Java中的参数传递问题" class="headerlink" title="(1)Java中的参数传递问题"></a>(1)Java中的参数传递问题</h3><pre><code>    Java中只有值传递。    基本类型：形式参数的改变不影响实际参数    引用类型：形式参数的改变直接影响实际参数</code></pre><h3 id="2-数据加密问题"><a href="#2-数据加密问题" class="headerlink" title="(2)数据加密问题"></a>(2)数据加密问题</h3><pre><code>    综合的小案例。</code></pre><h2 id="3-面向对象-掌握"><a href="#3-面向对象-掌握" class="headerlink" title="3:面向对象(掌握)"></a>3:面向对象(掌握)</h2><h3 id="1-面向对象"><a href="#1-面向对象" class="headerlink" title="(1)面向对象"></a>(1)面向对象</h3><pre><code>    面向对象是基于面向过程的编程思想</code></pre><h3 id="2-面向对象的思想特点"><a href="#2-面向对象的思想特点" class="headerlink" title="(2)面向对象的思想特点"></a>(2)面向对象的思想特点</h3><pre><code>    A:是一种更符合我们思考习惯的思想    B:把复杂的事情简单化    C:让我们从执行者变成了指挥者    举例：        买电脑        洗衣服        做饭        ...        万事万物皆对象</code></pre><h3 id="3-把大象装进冰箱-理解"><a href="#3-把大象装进冰箱-理解" class="headerlink" title="(3)把大象装进冰箱(理解)"></a>(3)把大象装进冰箱(理解)</h3><pre><code>    A:面向过程实现    B:面向对象实现    注意：如何让我们的操作更符合面向对象思想呢?    A:有哪些类    B:每个类有哪些成员    C:类与类的关系</code></pre><h3 id="4-类与对象"><a href="#4-类与对象" class="headerlink" title="(4)类与对象"></a>(4)类与对象</h3><pre><code>    A:现实世界的事物        属性    事物的基本描述        行为    事物的功能    B:Java语言中最基本的单位是类。所以，我们要用类来体现事物    C:类        成员变量    事物属性        成员方法    事物行为    D:类：是一组相关的属性和行为的集合。是一个抽象的概念。      对象：是该类事物的具体存在，是一个具体的实例。(对象)      举例：        学生：类        班长：对象</code></pre><h3 id="5-类的定义及使用"><a href="#5-类的定义及使用" class="headerlink" title="(5)类的定义及使用"></a>(5)类的定义及使用</h3><pre><code>    A:类的定义        成员变量    定义格式和以前一样，就是位置不同，在类中，方法外。        成员方法    定义格式和以前一样，就是去掉了static。    B:使用类的内容        a:创建对象? 格式            类名 对象名 =  new 类名();        b:如何使用成员变量和成员方法呢            对象名.成员变量            对象名.成员方法()</code></pre><h3 id="6-案例："><a href="#6-案例：" class="headerlink" title="(6)案例："></a>(6)案例：</h3><pre><code>    A:学生类的定义和使用    B:手机类的定义和使用</code></pre><h3 id="7-内存图"><a href="#7-内存图" class="headerlink" title="(7)内存图"></a>(7)内存图</h3><pre><code>    A:一个对象的内存图    B:二个对象的内存图    C:三个对象的内存图</code></pre><h3 id="8-Java程序的开发，设计和特征"><a href="#8-Java程序的开发，设计和特征" class="headerlink" title="(8)Java程序的开发，设计和特征"></a>(8)Java程序的开发，设计和特征</h3><pre><code>    A:开发：就是不断的创建对象，通过对象调用功能    B:设计：就是管理和维护对象间的关系    C:特征        a:封装        b:继承        c:多态</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day05</title>
      <link href="/2020/060410525.html"/>
      <url>/2020/060410525.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-方法-掌握"><a href="#1-方法-掌握" class="headerlink" title="1:方法(掌握)"></a>1:方法(掌握)</h2><h3 id="1-方法：就是完成特定功能的代码块。"><a href="#1-方法：就是完成特定功能的代码块。" class="headerlink" title="(1)方法：就是完成特定功能的代码块。"></a>(1)方法：就是完成特定功能的代码块。</h3><pre><code>    注意：在很多语言里面有函数的定义，而在Java中，函数被称为方法。</code></pre><h3 id="2-格式："><a href="#2-格式：" class="headerlink" title="(2)格式："></a>(2)格式：</h3><pre><code>    修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) {        方法体语句;        return 返回值;    }    修饰符：目前就用 public static。后面再详细讲解其他修饰符    返回值类型：就是功能结果的数据类型    方法名：就是起了一个名字，方便我们调用该方法。    参数类型：就是参数的数据类型    参数名：就是变量    参数分类：        实参：实际参与运算的数据        形参：方法上定义的，用于接收实际参数的变量    方法体语句：就是完成功能的代码块    return：结束方法    返回值：就是功能的结果，由return带给调用者。</code></pre><h3 id="3-两个明确："><a href="#3-两个明确：" class="headerlink" title="(3)两个明确："></a>(3)两个明确：</h3><pre><code>    返回值类型：结果的数据类型    参数列表：参数的个数及对应的数据类型</code></pre><h3 id="4-方法调用"><a href="#4-方法调用" class="headerlink" title="(4)方法调用"></a>(4)方法调用</h3><pre><code>    A:有明确返回值的方法        a:单独调用，没有意义        b:输出调用，不是很好，因为我可能需要不结果进行进一步的操作。但是讲课一般我就用了。        c:赋值调用，推荐方案    B:void类型修饰的方法        a:单独调用</code></pre><h3 id="5-案例："><a href="#5-案例：" class="headerlink" title="(5)案例："></a>(5)案例：</h3><pre><code>    A:求和方案    B:获取两个数中的较大值    C:比较两个数据是否相同    D:获取三个数中的最大值    E:输出m行n列的星形    F:输出nn乘法表</code></pre><h3 id="6-方法的注意事项"><a href="#6-方法的注意事项" class="headerlink" title="(6)方法的注意事项"></a>(6)方法的注意事项</h3><pre><code>    A:方法不调用不执行    B:方法之间是平级关系，不能嵌套定义    C:方法定义的时候，参数是用，隔开的    D:方法在调用的时候，不用在传递数据类型    E:如果方法有明确的返回值类型，就必须有return语句返回。</code></pre><h3 id="7-方法重载"><a href="#7-方法重载" class="headerlink" title="(7)方法重载"></a>(7)方法重载</h3><pre><code>    在同一个类中，方法名相同，参数列表不同。与返回值无关。    参数列表不同：        参数的个数不同。        参数的对应的数据类型不同。</code></pre><h3 id="8-方法重载案例"><a href="#8-方法重载案例" class="headerlink" title="(8)方法重载案例"></a>(8)方法重载案例</h3><pre><code>    不同的类型的多个同名方法的比较。</code></pre><h2 id="2-数组-掌握"><a href="#2-数组-掌握" class="headerlink" title="2:数组(掌握)"></a>2:数组(掌握)</h2><h3 id="1-数组："><a href="#1-数组：" class="headerlink" title="(1)数组："></a>(1)数组：</h3><pre><code>存储同一种数据类型的多个元素的容器。</code></pre><h3 id="2-特点："><a href="#2-特点：" class="headerlink" title="(2)特点："></a>(2)特点：</h3><pre><code>每一个元素都有编号，从0开始，最大编号是长度-1。         编号的专业叫法：索引</code></pre><h3 id="3-定义格式"><a href="#3-定义格式" class="headerlink" title="(3)定义格式"></a>(3)定义格式</h3><pre><code>    A:数据类型[] 数组名;    B:数据类型 数组名[];    推荐是用A方式，B方法就忘了吧。    但是要能看懂</code></pre><h3 id="4-数组的初始化"><a href="#4-数组的初始化" class="headerlink" title="(4)数组的初始化"></a>(4)数组的初始化</h3><pre><code>    A:动态初始化        只给长度，系统给出默认值        举例：int[] arr = new int[3];    B:静态初始化        给出值，系统决定长度        举例：int[] arr = new int[]{1,2,3};        简化版：int[] arr = {1,2,3};</code></pre><h3 id="5-Java的内存分配"><a href="#5-Java的内存分配" class="headerlink" title="(5)Java的内存分配"></a>(5)Java的内存分配</h3><pre><code>    A:栈 存储局部变量    B:堆 存储所有new出来的    C:方法区(面向对象部分详细讲解)    D:本地方法区(系统相关)    E:寄存器(CPU使用)    注意：        a:局部变量 在方法定义中或者方法声明上定义的变量。        b:栈内存和堆内存的区别            栈：数据使用完毕，就消失。            堆：每一个new出来的东西都有地址                每一个变量都有默认值                    byte,short,int,long 0                    float,double 0.0                    char &#39;\u0000&#39;                    boolean false                    引用类型 null                数据使用完毕后，在垃圾回收器空闲的时候回收。</code></pre><h3 id="6-数组内存图"><a href="#6-数组内存图" class="headerlink" title="(6)数组内存图"></a>(6)数组内存图</h3><pre><code>    A:一个数组    B:二个数组    C:三个数组(两个栈变量指向同一个堆内存)</code></pre><h3 id="7-数组的常见操作"><a href="#7-数组的常见操作" class="headerlink" title="(7)数组的常见操作"></a>(7)数组的常见操作</h3><pre><code>    A:遍历        方式1：            public static void printArray(int[] arr) {                for(int x=0; x&lt;arr.length; x++) {                    System.out.println(arr[x]);                }            }        方式2：            public static void printArray(int[] arr) {                System.out.print(&quot;[&quot;);                for(int x=0; x&lt;arr.length; x++) {                    if(x == arr.length-1) {                        System.out.println(arr[x]+&quot;]&quot;);                    }else {                        System.out.println(arr[x]+&quot;, &quot;);                    }                }            }    B:最值        最大值：            public static int getMax(int[] arr) {                int max = arr[0];                for(int x=1; x&lt;arr.length; x++) {                    if(arr[x] &gt; max) {                        max = arr[x];                    }                }                return max;            }        最小值：            public static int getMin(int[] arr) {                int min = arr[0];                for(int x=1; x&lt;arr.length; x++) {                    if(arr[x] &lt; min) {                        min = arr[x];                    }                }                return min;            }    C:逆序        方式1：            public static void reverse(int[] arr) {                for(int x=0; x&lt;arr.length/2; x++) {                    int temp = arr[x];                    arr[x] = arr[arr.length-1-x];                    arr[arr.length-1-x] = temp;                }            }        方式2：            public static void reverse(int[] arr) {                for(int start=0,end=arr.length-1; start&lt;=end; start++,end--) {                    int temp = arr[start];                    arr[start] = arr[end];                    arr[end] = temp;                }            }    D:查表            public static String getString(String[] strArray,int index) {                return strArray[index];            }    E:基本查找        方式1：            public static int getIndex(int[] arr,int value) {                for(int x=0; x&lt;arr.length; x++) {                    if(arr[x] == value) {                        return x;                    }                }                return -1;            }        方式2：            public static int getIndex(int[] arr,int value) {                int index = -1;                for(int x=0; x&lt;arr.length; x++) {                    if(arr[x] == value) {                        index = x;                        break;                    }                }                return index;            }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day04</title>
      <link href="/2020/060359868.html"/>
      <url>/2020/060359868.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-switch语句-掌握"><a href="#1-switch语句-掌握" class="headerlink" title="1:switch语句(掌握)"></a>1:switch语句(掌握)</h2><h3 id="1-格式："><a href="#1-格式：" class="headerlink" title="(1)格式："></a>(1)格式：</h3><pre><code>    switch(表达式) {        case 值1:            语句体1;            break;        case 值2:            语句体2;            break;        ...        default:            语句体n+1;            break;    }    格式解释说明：        switch:说明这是switch语句。        表达式:可以是byte,short,int,char            JDK5以后可以是枚举            JDK7以后可以是字符串        case:后面的值就是要和表达式进行比较的值        break:表示程序到这里中断，跳出switch语句        default:如果所有的情况都不匹配,就执行这里,相当于if语句中的else</code></pre><h3 id="2-面试题"><a href="#2-面试题" class="headerlink" title="(2)面试题"></a>(2)面试题</h3><pre><code>    switch语句的表达式可以是byte吗?可以是long吗?可以是String吗?        可以,不可以,JDK7以后可以</code></pre><h3 id="3-执行流程"><a href="#3-执行流程" class="headerlink" title="(3)执行流程:"></a>(3)执行流程:</h3><pre><code>    A:首先计算表达式的值    B:和每一个case进行匹配，如果有就执行对应的语句体，看到break就结束。    C:如果没有匹配，就执行default的语句体n+1。</code></pre><h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="(4)注意事项:"></a>(4)注意事项:</h3><pre><code>    A:case后面只能是常量，不能是变量，而且，多个case后面的值不能出现相同的    B:default可以省略吗?        可以省略，但是不建议，因为它的作用是对不正确的情况给出提示。        特殊情况：            case就可以把值固定。            A,B,C,D    C:break可以省略吗?        可以省略，但是结果可能不是我们想要的。        会出现一个现象：case穿透。        最终我们建议不要省略    D:default一定要在最后吗?        不是，可以在任意位置。但是建议在最后。    E:switch语句的结束条件        a:遇到break就结束了        b:执行到末尾就结束了</code></pre><h3 id="5-案例："><a href="#5-案例：" class="headerlink" title="(5)案例："></a>(5)案例：</h3><pre><code>    A:键盘录入一个数字(1-7),输出对应的星期几。    B:单项选择题    C:键盘录入一个字符串的问题        String s = sc.nextLine();    D:根据给定的月份,输出对应的季节</code></pre><h3 id="6-if语句和switch语句各自的场景"><a href="#6-if语句和switch语句各自的场景" class="headerlink" title="(6)if语句和switch语句各自的场景"></a>(6)if语句和switch语句各自的场景</h3><pre><code>    A:if        针对boolean类型的判断        针对一个范围的判断        针对几个常量的判断    B:switch        针对几个常量的判断</code></pre><h2 id="2-循环语句-掌握"><a href="#2-循环语句-掌握" class="headerlink" title="2:循环语句(掌握)"></a>2:循环语句(掌握)</h2><h3 id="1-有三种-for-while-do…while"><a href="#1-有三种-for-while-do…while" class="headerlink" title="(1)有三种:for,while,do…while"></a>(1)有三种:for,while,do…while</h3><h3 id="2-for循环语句"><a href="#2-for循环语句" class="headerlink" title="(2)for循环语句"></a>(2)for循环语句</h3><pre><code>    A:格式        for(初始化语句;判断条件语句;控制条件语句){            循环体语句;        }        执行流程：            a:执行初始化语句            b:执行判断条件语句                如果这里是true，就继续                如果这里是false，循环就结束            c:执行循环体语句            d:执行控制条件语句            e:回到b    B:注意事项        a:判断条件语句无论简单还是复杂，结果是boolean类型        b:循环体语句如果是一条，可以省略大括号，但是不建议        c:有分号就没有左大括号，有左大括号就没有分号    C:案例        a:输出10次HelloWorld        b:输出1-10的数据        c:输出10-1的数据        d:求1-10的和        e:求1-100的和,求1-100的偶数和,求1-100的奇数和        f:求5的阶乘        g:在控制台打印水仙花数        h:统计水仙花个数        i:改进版的回文数            一个五位数            个位 = 万位            十位 = 千位            个位 + 十位 + 千位 + 万位 = 百位        j:统计1-1000之间同时满足如下条件的数据有多少个            x%3==2            x%5==3            x%7==2</code></pre><h3 id="3-while循环"><a href="#3-while循环" class="headerlink" title="(3)while循环"></a>(3)while循环</h3><pre><code>    A:基本格式        while(判断条件语句) {            循环体语句;        }        扩展格式：        初始化语句;        while(判断条件语句){            循环体语句;            控制条件语句;        }        通过查看这个格式，我们就知道while循环可以和for循环等价转换。    B:while的练习        把for语句的练习用while改进    C:for和while的区别        a:使用上的区别            for语句的那个控制条件变量,在循环结束后不能在使用了。            而while的可以继续使用。        b:理解上的区别            for适合于一个范围的判断            while适合次数不明确的                举例:吃葡萄    D:案例：        a:珠穆朗玛峰问题        b:小芳存钱问题(break以后才能做)</code></pre><h3 id="4-do…while循环"><a href="#4-do…while循环" class="headerlink" title="(4)do…while循环"></a>(4)do…while循环</h3><pre><code>    A:基本格式        do {            循环体语句;        }while(判断条件语句);        扩展格式：        初始化语句;        do {            循环体语句;            控制条件语句;        }while(判断条件语句);        通过查看格式，我们就可以看出其实三种循环的格式可以是统一的。    B:三种循环的区别        a:do...while循环至少执行一次循环体        b:for和while必须先判断条件是否是true，然后后才能决定是否执行循环体</code></pre><h3 id="5-循环使用的注意事项-死循环"><a href="#5-循环使用的注意事项-死循环" class="headerlink" title="(5)循环使用的注意事项(死循环)"></a>(5)循环使用的注意事项(死循环)</h3><pre><code>    A:一定要注意修改控制条件,否则容易出现死循环。    B:最简单的死循环格式        a:while(true){...}        b:for(;;){}</code></pre><h2 id="3-控制跳转语句-掌握"><a href="#3-控制跳转语句-掌握" class="headerlink" title="3:控制跳转语句(掌握)"></a>3:控制跳转语句(掌握)</h2><h3 id="1-break-中断的意思"><a href="#1-break-中断的意思" class="headerlink" title="(1)break:中断的意思"></a>(1)break:中断的意思</h3><pre><code>    A:用在循环和switch语句中，离开此应用场景无意义。    B:作用        a:跳出单层循环        b:跳出多层循环，需要标签语句的配合</code></pre><h3 id="2-continue-继续"><a href="#2-continue-继续" class="headerlink" title="(2)continue:继续"></a>(2)continue:继续</h3><pre><code>    A:用在循环中，离开此应用场景无意义。    B:作用        a:跳出单层循环的一次，可以继续下一次    C:填空题        for(int x=1; x&lt;=10; x++) {            if(x%3 == 0) {                //补齐代码            }            System.out.println(&quot;Java基础班&quot;);        }        如何让控制台输出2次：Java基础班        如何让控制台输出7次：Java基础班        如何让控制台输出13次：Java基础班</code></pre><h3 id="3-return-返回"><a href="#3-return-返回" class="headerlink" title="(3)return:返回"></a>(3)return:返回</h3><pre><code>    A:用于结束方法的，后面还会在继续讲解和使用。    B:一旦遇到return,程序就不会在继续往后执行。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day03</title>
      <link href="/2020/060211165.html"/>
      <url>/2020/060211165.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-运算符-掌握"><a href="#1-运算符-掌握" class="headerlink" title="1:运算符(掌握)"></a>1:运算符(掌握)</h2><h3 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="(1)算术运算符"></a>(1)算术运算符</h3><pre><code>    A:+,-,*,/,%,++,--    B:+的用法        a:加法        b:正号        c:字符串连接符    C:/和%的区别        数据做除法操作的时候，/取得是商，%取得是余数    D:++和--的用法        a:他们的作用是自增或者自减        b:使用            **单独使用                放在操作数据的前面和后面效果一样。                a++或者++a效果一样。            **参与操作使用                放在操作数的前面：先自增或者自减，再参与操作                    int a = 10;                    int b = ++a;                放在操作数的后面：先参与操作，再自增或者自减                    int a = 10;                    int b = a++;</code></pre><h3 id="2-赋值运算符"><a href="#2-赋值运算符" class="headerlink" title="(2)赋值运算符"></a>(2)赋值运算符</h3><pre><code>    A:=,+=,-=,*=,/=,%=等    B:=叫做赋值运算符，也是最基本的赋值运算符        int x = 10; 把10赋值给int类型的变量x。    C:扩展的赋值运算符的特点        隐含了自动强制转换。        面试题：            short s = 1;            s = s + 1;            short s = 1;            s += 1;            请问上面的代码哪个有问题?</code></pre><h3 id="3-比较运算符"><a href="#3-比较运算符" class="headerlink" title="(3)比较运算符"></a>(3)比较运算符</h3><pre><code>    A:==,!=,&gt;,&gt;=,&lt;,&lt;=    B:无论运算符两端简单还是复杂最终结果是boolean类型。    C:千万不要把==写成了=</code></pre><h3 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="(4)逻辑运算符"></a>(4)逻辑运算符</h3><pre><code>    A:&amp;,|,^,!,&amp;&amp;,||    B:逻辑运算符用于连接boolean类型的式子    C:结论        &amp;:有false则false        |:有true则true        ^:相同则false，不同则true。            情侣关系。        !:非true则false，非false则true        &amp;&amp;:结果和&amp;是一样的，只不过有短路效果。左边是false，右边不执行。        ||:结果和|是一样的，只不过有短路效果。左边是true，右边不执行。</code></pre><h3 id="5-位运算符-了解"><a href="#5-位运算符-了解" class="headerlink" title="(5)位运算符(了解)"></a>(5)位运算符(了解)</h3><pre><code>    A:^的特殊用法        一个数据针对另一个数据位异或两次，该数不变    B:面试题        a:请实现两个变量的交换            **采用第三方变量            **用位异或运算符                左边a,b,a                右边a^b        b:请用最有效率的方式计算出2乘以8的结果            2&lt;&lt;3</code></pre><h3 id="6-三元运算符"><a href="#6-三元运算符" class="headerlink" title="(6)三元运算符"></a>(6)三元运算符</h3><pre><code>    A:格式        比较表达式?表达式1:表达式2;    B:执行流程：        首先计算比较表达式的值，看是true还是false。        如果是true，表达式1就是结果。        如果是false，表达式2就是结果。    C:案例：        a:比较两个数据是否相等        b:获取两个数据中的最大值        c:获取三个数据中的最大值</code></pre><h2 id="2-键盘录入-掌握"><a href="#2-键盘录入-掌握" class="headerlink" title="2:键盘录入(掌握)"></a>2:键盘录入(掌握)</h2><h3 id="1-实际开发中，数据是变化的，为了提高程序的灵活性，我们加入键盘录入数据。"><a href="#1-实际开发中，数据是变化的，为了提高程序的灵活性，我们加入键盘录入数据。" class="headerlink" title="(1)实际开发中，数据是变化的，为了提高程序的灵活性，我们加入键盘录入数据。"></a>(1)实际开发中，数据是变化的，为了提高程序的灵活性，我们加入键盘录入数据。</h3><h3 id="2-如何实现呢-目前就记住"><a href="#2-如何实现呢-目前就记住" class="headerlink" title="(2)如何实现呢?目前就记住"></a>(2)如何实现呢?目前就记住</h3><pre><code>    A:导包        import java.util.Scanner;        位置：在class的上边    B:创建对象        Scanner sc = new Scanner(System.in);    C:获取数据        int x = sc.nextInt();</code></pre><h3 id="3-把三元运算符的案例加入键盘录入改进。"><a href="#3-把三元运算符的案例加入键盘录入改进。" class="headerlink" title="(3)把三元运算符的案例加入键盘录入改进。"></a>(3)把三元运算符的案例加入键盘录入改进。</h3><h2 id="3-流程控制语句"><a href="#3-流程控制语句" class="headerlink" title="3:流程控制语句"></a>3:流程控制语句</h2><h3 id="1-顺序结构-从上往下，依次执行"><a href="#1-顺序结构-从上往下，依次执行" class="headerlink" title="(1)顺序结构 从上往下，依次执行"></a>(1)顺序结构 从上往下，依次执行</h3><h3 id="2-选择结构-按照不同的选择，执行不同的代码"><a href="#2-选择结构-按照不同的选择，执行不同的代码" class="headerlink" title="(2)选择结构    按照不同的选择，执行不同的代码"></a>(2)选择结构    按照不同的选择，执行不同的代码</h3><h3 id="3-循环结构-做一些重复的代码"><a href="#3-循环结构-做一些重复的代码" class="headerlink" title="(3)循环结构 做一些重复的代码"></a>(3)循环结构 做一些重复的代码</h3><h2 id="4-if语句-掌握"><a href="#4-if语句-掌握" class="headerlink" title="4:if语句(掌握)"></a>4:if语句(掌握)</h2><h3 id="1-三种格式"><a href="#1-三种格式" class="headerlink" title="(1)三种格式"></a>(1)三种格式</h3><pre><code>    A:格式1        if(比较表达式) {            语句体;        }        执行流程：            判断比较表达式的值，看是true还是false            如果是true，就执行语句体            如果是false，就不执行语句体    B:格式2        if(比较表达式) {            语句体1;        }else {            语句体2;        }        执行流程：            判断比较表达式的值，看是true还是false            如果是true，就执行语句体1            如果是false，就执行语句体2    C:格式3        if(比较表达式1) {            语句体1;        }else if(比较表达式2){            语句体2;        }        ...        else {            语句体n+1;        }        执行流程：            判断比较表达式1的值，看是true还是false            如果是true，就执行语句体1            如果是false，就继续判断比较表达式2的值，看是true还是false            如果是true，就执行语句体2            如果是false，就继续判断比较表达式3的值，看是true还是false            ...            如果都不满足，就执行语句体n+1</code></pre><h3 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="(2)注意事项"></a>(2)注意事项</h3><pre><code>    A:比较表达式无论简单还是复杂，结果是boolean类型    B:if语句控制的语句体如果是一条语句，是可以省略大括号的；如果是多条，不能省略。        建议：永远不要省略。    C:一般来说，有左大括号，就没有分号，有分号，就没有左大括号。    D:else后面如果没有if，是不会出现比较表达式的。    E:三种if语句其实都是一个语句，只要有一个执行，其他的就不再执行。</code></pre><h3 id="3-案例："><a href="#3-案例：" class="headerlink" title="(3)案例："></a>(3)案例：</h3><pre><code>    A:比较两个数是否相等    B:获取两个数中的最大值    C:获取三个数中的最大值(if语句的嵌套)    D:根据成绩输出对应的等级    E:根据月份，输出对应的季节    F:根据x计算对应y的值并输出</code></pre><h3 id="4-三元运算符和if语句第二种格式的关系"><a href="#4-三元运算符和if语句第二种格式的关系" class="headerlink" title="(4)三元运算符和if语句第二种格式的关系"></a>(4)三元运算符和if语句第二种格式的关系</h3><pre><code>    所有的三元运算符能够实现的，if语句的第二种格式都能实现。    反之不成立。    如果if语句第二种格式控制的语句体是输出语句，就不可以。    因为三元运算符是一个运算符，必须要有一个结果返回，不能是一个输出语句。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day02</title>
      <link href="/2020/060160252.html"/>
      <url>/2020/060160252.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-关键字-掌握"><a href="#1-关键字-掌握" class="headerlink" title="1:关键字(掌握)"></a>1:关键字(掌握)</h2><h3 id="1-被Java语言赋予特定含义的单词"><a href="#1-被Java语言赋予特定含义的单词" class="headerlink" title="(1)被Java语言赋予特定含义的单词"></a>(1)被Java语言赋予特定含义的单词</h3><h3 id="2-特点："><a href="#2-特点：" class="headerlink" title="(2)特点："></a>(2)特点：</h3><pre><code>    全部小写。</code></pre><h3 id="3-注意事项："><a href="#3-注意事项：" class="headerlink" title="(3)注意事项："></a>(3)注意事项：</h3><pre><code>    A:goto和const作为保留字存在。    B:类似于Notepad++这样的高级记事本会对关键字有特殊颜色标记</code></pre><h2 id="2-标识符-掌握"><a href="#2-标识符-掌握" class="headerlink" title="2:标识符(掌握)"></a>2:标识符(掌握)</h2><h3 id="1-就是给类，接口，方法，变量等起名字的字符序列"><a href="#1-就是给类，接口，方法，变量等起名字的字符序列" class="headerlink" title="(1)就是给类，接口，方法，变量等起名字的字符序列"></a>(1)就是给类，接口，方法，变量等起名字的字符序列</h3><h3 id="2-组成规则："><a href="#2-组成规则：" class="headerlink" title="(2)组成规则："></a>(2)组成规则：</h3><pre><code>    A:英文大小写字母    B:数字    C:$和_</code></pre><h3 id="3-注意事项：-1"><a href="#3-注意事项：-1" class="headerlink" title="(3)注意事项："></a>(3)注意事项：</h3><pre><code>    A:不能以数字开头    B:不能是java中的关键字    C:区分大小写</code></pre><h3 id="4-常见的命名规则-见名知意"><a href="#4-常见的命名规则-见名知意" class="headerlink" title="(4)常见的命名规则(见名知意)"></a>(4)常见的命名规则(见名知意)</h3><pre><code>    A:包    全部小写        单级包：小写            举例：liuyi,com        多级包：小写，并用.隔开            举例：cn.itcast,com.baidu                    B:类或者接口        一个单词：首字母大写            举例：Student,Demo        多个单词：每个单词首字母大写            举例：HelloWorld,StudentName    C:方法或者变量        一个单词：首字母小写            举例：name,main        多个单词：从第二个单词开始，每个单词首字母大写            举例：studentAge,showAllNames()    D:常量        全部大写        一个单词：大写            举例：PI        多个单词：大写，并用_隔开            举例：STUDENT_MAX_AGE</code></pre><h2 id="3-注释-掌握"><a href="#3-注释-掌握" class="headerlink" title="3:注释(掌握)"></a>3:注释(掌握)</h2><h3 id="1-就是对程序进行解释说明的文字"><a href="#1-就是对程序进行解释说明的文字" class="headerlink" title="(1)就是对程序进行解释说明的文字"></a>(1)就是对程序进行解释说明的文字</h3><h3 id="2-分类："><a href="#2-分类：" class="headerlink" title="(2)分类："></a>(2)分类：</h3><pre><code>    A:单行注释    //    B:多行注释    /**/    C:文档注释(后面讲) /** */</code></pre><h3 id="3-把HelloWorld案例写了一个带注释的版本。"><a href="#3-把HelloWorld案例写了一个带注释的版本。" class="headerlink" title="(3)把HelloWorld案例写了一个带注释的版本。"></a>(3)把HelloWorld案例写了一个带注释的版本。</h3><pre><code>    后面我们要写一个程序的过程。    需求：    分析：    实现：    代码体现：</code></pre><h3 id="4-注释的作用"><a href="#4-注释的作用" class="headerlink" title="(4)注释的作用"></a>(4)注释的作用</h3><pre><code>    A:解释说明程序，提高了代码的阅读性。    B:可以帮助我们调试程序。        后面我们会讲解一个更高端的一个调试工具</code></pre><h2 id="4-常量-掌握"><a href="#4-常量-掌握" class="headerlink" title="4:常量(掌握)"></a>4:常量(掌握)</h2><h3 id="1-在程序执行的过程中，其值不发生改变的量"><a href="#1-在程序执行的过程中，其值不发生改变的量" class="headerlink" title="(1)在程序执行的过程中，其值不发生改变的量"></a>(1)在程序执行的过程中，其值不发生改变的量</h3><h3 id="2-分类：-1"><a href="#2-分类：-1" class="headerlink" title="(2)分类："></a>(2)分类：</h3><pre><code>    A:字面值常量    B:自定义常量(后面讲)</code></pre><h3 id="3-字面值常量"><a href="#3-字面值常量" class="headerlink" title="(3)字面值常量"></a>(3)字面值常量</h3><pre><code>    A:字符串常量 &quot;hello&quot;    B:整数常量    12,23    C:小数常量    12.345    D:字符常量    &#39;a&#39;,&#39;A&#39;,&#39;0&#39;    E:布尔常量    true,false    F:空常量    null(后面讲)</code></pre><h3 id="4-在Java中针对整数常量提供了四种表现形式"><a href="#4-在Java中针对整数常量提供了四种表现形式" class="headerlink" title="(4)在Java中针对整数常量提供了四种表现形式"></a>(4)在Java中针对整数常量提供了四种表现形式</h3><pre><code>    A:二进制    由0，1组成。以0b开头。    B:八进制    由0，1，...7组成。以0开头。    C:十进制    由0，1，...9组成。整数默认是十进制。    D:十六进制    由0，1，...9,a,b,c,d,e,f(大小写均可)组成。以0x开头。</code></pre><h2 id="5-进制转换-了解"><a href="#5-进制转换-了解" class="headerlink" title="5:进制转换(了解)"></a>5:进制转换(了解)</h2><h3 id="1-其他进制到十进制"><a href="#1-其他进制到十进制" class="headerlink" title="(1)其他进制到十进制"></a>(1)其他进制到十进制</h3><pre><code>    系数：就是每一个位上的数值    基数：x进制的基数就是x    权：对每一个位上的数据，从右，并且从0开始编号，对应的编号就是该数据的权。    结果：系数*基数^权次幂之和。</code></pre><h3 id="2-十进制到其他进制"><a href="#2-十进制到其他进制" class="headerlink" title="(2)十进制到其他进制"></a>(2)十进制到其他进制</h3><pre><code>    除基取余，直到商为0，余数反转。</code></pre><h3 id="3-进制转换的快速转换法"><a href="#3-进制转换的快速转换法" class="headerlink" title="(3)进制转换的快速转换法"></a>(3)进制转换的快速转换法</h3><pre><code>    A:十进制和二进制间的转换        8421码。    B:二进制到八进制，十六进制的转换</code></pre><h2 id="6-变量-掌握"><a href="#6-变量-掌握" class="headerlink" title="6:变量(掌握)"></a>6:变量(掌握)</h2><h3 id="1-在程序的执行过程中，其值在某个范围内可以发生改变的量"><a href="#1-在程序的执行过程中，其值在某个范围内可以发生改变的量" class="headerlink" title="(1)在程序的执行过程中，其值在某个范围内可以发生改变的量"></a>(1)在程序的执行过程中，其值在某个范围内可以发生改变的量</h3><h3 id="2-变量的定义格式："><a href="#2-变量的定义格式：" class="headerlink" title="(2)变量的定义格式："></a>(2)变量的定义格式：</h3><pre><code>    A:数据类型 变量名 = 初始化值;    B:数据类型 变量名;      变量名 = 初始化值;</code></pre><h2 id="7-数据类型-掌握"><a href="#7-数据类型-掌握" class="headerlink" title="7:数据类型(掌握)"></a>7:数据类型(掌握)</h2><h3 id="1-Java是一种强类型语言，针对每种数据都提供了对应的数据类型。"><a href="#1-Java是一种强类型语言，针对每种数据都提供了对应的数据类型。" class="headerlink" title="(1)Java是一种强类型语言，针对每种数据都提供了对应的数据类型。"></a>(1)Java是一种强类型语言，针对每种数据都提供了对应的数据类型。</h3><h3 id="2-分类：-2"><a href="#2-分类：-2" class="headerlink" title="(2)分类："></a>(2)分类：</h3><pre><code>    A:基本数据类型：4类8种    B:引用数据类型：类，接口，数组。</code></pre><h3 id="3-基本数据类型"><a href="#3-基本数据类型" class="headerlink" title="(3)基本数据类型"></a>(3)基本数据类型</h3><pre><code>    A:整数            占用字节数        byte            1        short            2        int             4        long            8    B:浮点数        float            4        double            8    C:字符        char            2    D:布尔        boolean            1    注意：        整数默认是int类型，浮点数默认是double。        长整数要加L或者l。        单精度的浮点数要加F或者f。</code></pre><h2 id="8-数据类型转换-掌握"><a href="#8-数据类型转换-掌握" class="headerlink" title="8:数据类型转换(掌握)"></a>8:数据类型转换(掌握)</h2><h3 id="1-boolean类型不参与转换"><a href="#1-boolean类型不参与转换" class="headerlink" title="(1)boolean类型不参与转换"></a>(1)boolean类型不参与转换</h3><h3 id="2-默认转换"><a href="#2-默认转换" class="headerlink" title="(2)默认转换"></a>(2)默认转换</h3><pre><code>    A:从小到大    B:byte,short,char -- int -- long -- float -- double    C:byte,short,char之间不相互转换，直接转成int类型参与运算。</code></pre><h3 id="3-强制转换"><a href="#3-强制转换" class="headerlink" title="(3)强制转换"></a>(3)强制转换</h3><pre><code>    A:从大到小    B:可能会有精度的损失，一般不建议这样使用。    C:格式：        目标数据类型 变量名 = (目标数据类型) (被转换的数据);</code></pre><h3 id="4-思考题和面试题："><a href="#4-思考题和面试题：" class="headerlink" title="(4)思考题和面试题："></a>(4)思考题和面试题：</h3><pre><code>    A:下面两种方式有区别吗?        float f1 = 12.345f;        float f2 = (float)12.345;    B:下面的程序有问题吗，如果有，在哪里呢?        byte b1 = 3;        byte b2 = 4;        byte b3 = b1 + b2;        byte b4 = 3 + 4;    C:下面的操作结果是什么呢?        byte b = (byte)130;    D:字符参与运算        是查找ASCII里面的值        &#39;a&#39;        97        &#39;A&#39;        65        &#39;0&#39;        48        System.out.println(&#39;a&#39;);        System.out.println(&#39;a&#39; + 1);    E:字符串参与运算        这里其实是字符串的连接        System.out.println(&quot;hello&quot;+&#39;a&#39;+1);        System.out.println(&#39;a&#39;+1+&quot;hello&quot;);        System.out.println(&quot;5+5=&quot;+5+5);        System.out.println(5+5+&quot;=5+5&quot;);  </code></pre><hr><p>1：什么是注释?注释分为几种?注释有什么作用?  </p><pre><code>就是对程序进行解释说明；分为三种，单行注释，多行注释，文档注释；解释说明，提高代码的阅读性，帮助我们调试程序。</code></pre><p>2：什么是关键字?有什么特点?  </p><pre><code>被Java语言赋予特定含义的单词；全部小写；goto和const作为保留字存在。</code></pre><p>3：什么是标识符?由哪些部分组成?常见的命名规则有哪些?  </p><pre><code>就是给类，接口，方法，变量名等其名字的字符序列；A:英文字母大小写B:数字C：$和_。</code></pre><p>4：什么是常量?常量的分类?字面值常量表现形式有哪些?    </p><pre><code>在程序执行过程中，其值不发生改变的量；A字符串B整数C小数D字符E布尔F空常量null。</code></pre><p>5：计算出十进制46对应的二进制，八进制，十六进制的值。  </p><p>至于进制的内容今天在练习一次，以后就可以不用练习了。<br>后面能听懂就OK了。不用浪费太多时间。<br>(可用计算器验证你算的是否正确)</p><p>6：什么是变量?变量的定义格式?要使用变量需要注意什么?  </p><pre><code>在程序执行过程中，其值在某个范围内可以发生改变的量；A数据类型 变量名 = 初始值；B 数据类型 变量名；变量名 = 初始化值；</code></pre><p>7：Java中的数据类型分几类?基本数据类型有哪些?  </p><pre><code>A基本数据类型：4类8种 B引用数据类型：类，接口，数组。基本数据类型：    A整数     byte short int long   1 2 4 8    B浮点数 float double   4 8    C字符 char  2    D布尔 boolean 1</code></pre><p>8：数据类型转换：  </p><pre><code>隐式转换：A从小到大 Bbyte，short，char--int--long--float--double C:byte,short,char之间不相互转换，直接转成int类型参与运算。强制转换：A:从大到小          B:可能会有精度的损失，一般不建议这样使用。          C:格式：          目标数据类型 变量名 = (目标数据类型) (被转换的数据);</code></pre><p>面试题：  </p><pre><code>    第一题：    byte b1=3,b2=4,b;    b=b1+b2;    b=3+4;    哪句是编译失败的呢？为什么呢？    第二题：    byte  by = 130;有没有问题?有问题如何解决?结果是多少呢?</code></pre><p>9：练习打字(每天十分钟,即使休息的时候，也建议练习)</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day01</title>
      <link href="/2020/053159932.html"/>
      <url>/2020/053159932.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-计算机概述-了解"><a href="#1-计算机概述-了解" class="headerlink" title="1:计算机概述(了解)"></a>1:计算机概述(了解)</h2><h3 id="1-计算机"><a href="#1-计算机" class="headerlink" title="(1)计算机"></a>(1)计算机</h3><h3 id="2-计算机硬件"><a href="#2-计算机硬件" class="headerlink" title="(2)计算机硬件"></a>(2)计算机硬件</h3><h3 id="3-计算机软件"><a href="#3-计算机软件" class="headerlink" title="(3)计算机软件"></a>(3)计算机软件</h3><pre><code>    系统软件：window,linux,mac    应用软件：qq,yy,飞秋</code></pre><h3 id="4-软件开发-理解"><a href="#4-软件开发-理解" class="headerlink" title="(4)软件开发(理解)"></a>(4)软件开发(理解)</h3><pre><code>    软件：是由数据和指令组成的。(计算器)    开发：就是把软件做出来。    如何实现软件开发呢?        就是使用开发工具和计算机语言做出东西来</code></pre><h3 id="5-语言"><a href="#5-语言" class="headerlink" title="(5)语言"></a>(5)语言</h3><pre><code>    自然语言：人与人交流沟通的    计算机语言：人与计算机交流沟通的        C,C++,C#,Java</code></pre><h3 id="6-人机交换"><a href="#6-人机交换" class="headerlink" title="(6)人机交换"></a>(6)人机交换</h3><pre><code>    图形界面：操作方便只管    DOS命令：需要记忆一些常见的命令</code></pre><h2 id="2-键盘功能键的认识和快捷键-掌握"><a href="#2-键盘功能键的认识和快捷键-掌握" class="headerlink" title="2:键盘功能键的认识和快捷键(掌握)"></a>2:键盘功能键的认识和快捷键(掌握)</h2><h3 id="1-功能键的认识"><a href="#1-功能键的认识" class="headerlink" title="(1)功能键的认识"></a>(1)功能键的认识</h3><pre><code>    tab    shift    ctrl    alt    windos    空格    上下左右    回车    截图</code></pre><h3 id="2-快捷键"><a href="#2-快捷键" class="headerlink" title="(2)快捷键"></a>(2)快捷键</h3><pre><code>    全选    Ctrl+A    复制    Ctrl+C    粘贴    Ctrl+V    剪切    Ctrl+X    撤销    Ctrl+Z    保存    Ctrl+S</code></pre><h2 id="3-常见的DOS命令-掌握"><a href="#3-常见的DOS命令-掌握" class="headerlink" title="3:常见的DOS命令(掌握)"></a>3:常见的DOS命令(掌握)</h2><h3 id="1-常见的如下"><a href="#1-常见的如下" class="headerlink" title="(1)常见的如下"></a>(1)常见的如下</h3><pre><code>    盘符的切换        d:回车    目录的进入        cd javase        cd javase\day01\code    目录的回退        cd..        cd\    清屏        cls    退出        exit</code></pre><h3 id="2-其他的几个-了解"><a href="#2-其他的几个-了解" class="headerlink" title="(2)其他的几个(了解)"></a>(2)其他的几个(了解)</h3><pre><code>    创建目录    删除目录    创建文件    删除文件    显示目录下的内容    删除带内容的目录</code></pre><h2 id="4-Java语言概述-了解"><a href="#4-Java语言概述-了解" class="headerlink" title="4:Java语言概述(了解)"></a>4:Java语言概述(了解)</h2><h3 id="1-Java语言的发展史"><a href="#1-Java语言的发展史" class="headerlink" title="(1)Java语言的发展史"></a>(1)Java语言的发展史</h3><pre><code>    Java之父    JDK1.4.2    JDK5    JDK7</code></pre><h3 id="2-Java语言的特点"><a href="#2-Java语言的特点" class="headerlink" title="(2)Java语言的特点"></a>(2)Java语言的特点</h3><pre><code>    有很多小特点，重点有两个开源，跨平台</code></pre><h3 id="3-Java语言是跨平台的，请问是如何保证的呢-理解"><a href="#3-Java语言是跨平台的，请问是如何保证的呢-理解" class="headerlink" title="(3)Java语言是跨平台的，请问是如何保证的呢?(理解)"></a>(3)Java语言是跨平台的，请问是如何保证的呢?(理解)</h3><pre><code>    我们是通过翻译的案例讲解的。    针对不同的操作系统，提高不同的jvm来实现的。</code></pre><h3 id="4-Java语言的平台"><a href="#4-Java语言的平台" class="headerlink" title="(4)Java语言的平台"></a>(4)Java语言的平台</h3><pre><code>    JavaSE    JavaME--Android    JavaEE</code></pre><h2 id="5-JDK-JRE-JVM的作用及关系-掌握"><a href="#5-JDK-JRE-JVM的作用及关系-掌握" class="headerlink" title="5:JDK,JRE,JVM的作用及关系(掌握)"></a>5:JDK,JRE,JVM的作用及关系(掌握)</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="(1)作用"></a>(1)作用</h3><pre><code>    JVM：保证Java语言跨平台    JRE：Java程序的运行环境    JDK：Java程序的开发环境</code></pre><h3 id="2-关系"><a href="#2-关系" class="headerlink" title="(2)关系"></a>(2)关系</h3><pre><code>    JDK：JRE+工具    JRE：JVM+类库</code></pre><h2 id="6-JDK的下载-安装-卸载-掌握"><a href="#6-JDK的下载-安装-卸载-掌握" class="headerlink" title="6:JDK的下载,安装,卸载(掌握)"></a>6:JDK的下载,安装,卸载(掌握)</h2><h3 id="1-下载到官网。"><a href="#1-下载到官网。" class="headerlink" title="(1)下载到官网。"></a>(1)下载到官网。</h3><pre><code>    A:也可以到百度搜索即可。    B:我给你。</code></pre><h3 id="2-安装"><a href="#2-安装" class="headerlink" title="(2)安装"></a>(2)安装</h3><pre><code>    A:绿色版    解压就可以使用    B:安装版    必须一步一步的安装，一般只要会点击下一步即可    注意：        建议所有跟开发相关的软件都不要安装在有中文或者空格的目录下。</code></pre><h3 id="3-卸载"><a href="#3-卸载" class="headerlink" title="(3)卸载"></a>(3)卸载</h3><pre><code>    A:绿色版    直接删除文件夹    B:安装版            a:控制面板 -- 添加删除程序        b:通过专业的软件卸载工具。(比如360的软件管家卸载)</code></pre><h2 id="7-第一个程序：HelloWorld案例-掌握"><a href="#7-第一个程序：HelloWorld案例-掌握" class="headerlink" title="7:第一个程序：HelloWorld案例(掌握)"></a>7:第一个程序：HelloWorld案例(掌握)</h2><pre><code>class HelloWorld {    public static void main(String[] args) {        System.out.println(&quot;HelloWorld&quot;);    }}</code></pre><h3 id="1-程序解释："><a href="#1-程序解释：" class="headerlink" title="(1)程序解释："></a>(1)程序解释：</h3><pre><code>    A:Java程序的最基本单位是类，所以我们要定义一个类。        格式：class 类名        举例：class HelloWorld    B:在类中写内容的时候，用大括号括起来。    C:Java程序要想执行，必须有main方法。        格式：public static void main(String[] args)    D:要指向那些东西呢，也用大括号括起来。    E:你要做什么呢?今天我们仅仅做了一个简单的输出        格式：System.out.println(&quot;HelloWorld&quot;);        注意：&quot;&quot;里面的内容是可以改动的。</code></pre><h3 id="2-Java程序的开发执行流程："><a href="#2-Java程序的开发执行流程：" class="headerlink" title="(2)Java程序的开发执行流程："></a>(2)Java程序的开发执行流程：</h3><pre><code>    A:编写java源程序(.java)    B:通过javac命令编译生成.class文件    C:通过java命令运行.class文件</code></pre><h2 id="8-常见的问题-掌握"><a href="#8-常见的问题-掌握" class="headerlink" title="8:常见的问题(掌握)"></a>8:常见的问题(掌握)</h2><h3 id="1-扩展名被隐藏"><a href="#1-扩展名被隐藏" class="headerlink" title="(1)扩展名被隐藏"></a>(1)扩展名被隐藏</h3><pre><code>    如何找到：工具--文件夹选项--查看--去除隐藏扩展名的那个勾勾</code></pre><h3 id="2-我要求文件名称和类名一致。"><a href="#2-我要求文件名称和类名一致。" class="headerlink" title="(2)我要求文件名称和类名一致。"></a>(2)我要求文件名称和类名一致。</h3><pre><code>    实际上不这样做也是可以的。    但是，注意：        javac后面跟的是文件名+扩展名        java后面跟的类名不带扩展名</code></pre><h3 id="3-Java语言严格区分大小写，请注意。"><a href="#3-Java语言严格区分大小写，请注意。" class="headerlink" title="(3)Java语言严格区分大小写，请注意。"></a>(3)Java语言严格区分大小写，请注意。</h3><pre><code>     还有就是单词不要写错了。</code></pre><h3 id="4-见到非法字符-65307肯定是中文问题。"><a href="#4-见到非法字符-65307肯定是中文问题。" class="headerlink" title="(4)见到非法字符: \65307肯定是中文问题。"></a>(4)见到非法字符: \65307肯定是中文问题。</h3><pre><code>    我们写程序要求标点符号必须全部是英文状态。</code></pre><h3 id="5-括号的配对问题。"><a href="#5-括号的配对问题。" class="headerlink" title="(5)括号的配对问题。"></a>(5)括号的配对问题。</h3><pre><code>    一般来说，括号都是成对出现的。</code></pre><h3 id="6-遇到"><a href="#6-遇到" class="headerlink" title="(6)遇到"></a>(6)遇到</h3><pre><code>    在类 HelloWorld 中找不到主方法, 请将主方法定义为    肯定是主方法的格式问题。</code></pre><h2 id="9-path环境变量-掌握"><a href="#9-path环境变量-掌握" class="headerlink" title="9:path环境变量(掌握)"></a>9:path环境变量(掌握)</h2><h3 id="1-path环境变量的作用"><a href="#1-path环境变量的作用" class="headerlink" title="(1)path环境变量的作用"></a>(1)path环境变量的作用</h3><pre><code>    保证javac命令可以在任意目录下运行。    同理可以配置qq等</code></pre><h3 id="2-path配置的两种方案："><a href="#2-path配置的两种方案：" class="headerlink" title="(2)path配置的两种方案："></a>(2)path配置的两种方案：</h3><pre><code>    A:方案1(了解)    B:方案2        找到环境变量的位置，在系统变量里面        新建：            变量名：JAVA_HOME            变量值：D:\develop\Java\jdk1.7.0_60        修改：            变量名：Path            变量值：%JAVA_HOME%\bin;以前的内容</code></pre><h2 id="10-classpath环境变量-理解"><a href="#10-classpath环境变量-理解" class="headerlink" title="10:classpath环境变量(理解)"></a>10:classpath环境变量(理解)</h2><h3 id="1-classpath环境变量的作用"><a href="#1-classpath环境变量的作用" class="headerlink" title="(1)classpath环境变量的作用"></a>(1)classpath环境变量的作用</h3><pre><code>    保证class文件可以在任意目录下运行</code></pre><h3 id="2-classpath环境变量的配置"><a href="#2-classpath环境变量的配置" class="headerlink" title="(2)classpath环境变量的配置"></a>(2)classpath环境变量的配置</h3><pre><code>    找到环境变量的位置，在系统变量里面    新建：        变量名：classpath        变量值：E:\JavaSE\day01\code\HelloWorld案例</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CCS5.5——快速傅里叶变换(FFT)</title>
      <link href="/2020/052749146.html"/>
      <url>/2020/052749146.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h1><p>1、离散傅里叶变换DFT的定义：将时域的采样变换成频域的周期性离散函数，频域的采样也可以变换成时域的周期性离散函数，这样的变化称为离散傅里叶变换，简称DFT。  </p><p>2、FFT是DFT的一种快速算法。由于在计算DFT是一次复数乘法需用四次实数乘法和两次实数加法；一次复数加法需要两次实数加法。每运算一个X(k)需要4N次复数乘法及 实数加法。所以整个DFT运算总共需要 次实数乘法及 次实数加法。如此，计算时乘法次数和加法次数都是和 成正比的，当N很大时，运算量是客观的，因而需要改进带DFT的算法减少运算速度。  </p><p>根据傅里叶变换的对称性和周期性，我们可以将DFT运算中有些项合并。假设序列长度为 ,L为整数。将 的序列x(n)(n=0,1,…,N-1),按N的奇偶分成两组，分解成两个N/2点的DFT，重新组合成一个如下式表达的N点DFT:<br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P05271.jpg" alt="">  </p><p>将DFT的 步运算减少为 步，极大地提高了运算的速度；  </p><p>3、    旋转因子的变化规律；  </p><p>4、    碟形运算规律；  </p><p>5、    基于2FFT算法。  </p><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P05272.jpg" alt=""></p><h1 id="2-记录实验数据"><a href="#2-记录实验数据" class="headerlink" title="2.记录实验数据"></a>2.记录实验数据</h1><p>按照图6-2，3进行输入信号时域，频域以及输出信号时域波形的设置。<br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P05273.jpg" alt=""><br>输入信号及输出信号的波形如图6-4,5,6所示：<br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P05274.jpg" alt=""><br>代码：</p><pre><code>#include&quot;math.h&quot;#define PI 3.1415926#define SAMPLENUMBER 128void InitForFFT();void MakeWave();int INPUT[SAMPLENUMBER],DATA[SAMPLENUMBER];float fWaveR[SAMPLENUMBER],fWaveI[SAMPLENUMBER],w[SAMPLENUMBER];float sin_tab[SAMPLENUMBER],cos_tab[SAMPLENUMBER];void FFT(float dataR[SAMPLENUMBER],float dataI[SAMPLENUMBER]){    int x0, x1, x2, x3, x4, x5, x6, xx;    int i, j, k, b, p, L;    float TR, TI, temp;/***************fllowing code invert sequence***************/    for( i = 0; i &lt; SAMPLENUMBER; i++)    {        x0=x1=x2=x3=x4=x5=x6=0;        x0=i&amp;0x01;x1=(i/2)&amp;0x01;x2=(i/4)&amp;0x01;x3=(i/8)&amp;0x01;x4=(i/16)&amp;0x01;x5=(i/32)&amp;0x01;x6=(i/64)&amp;0x01;        xx=x0*64+x1*32+x2*16+x3*8+x4*4+x5*2+x6;        dataI[xx]=dataR[i];    }    for( i = 0; i &lt; SAMPLENUMBER; i++)    {        dataR[i]=dataI[i];dataI[i]=0;    }/***********fllowing code FFT***************/    for( L = 1; L &lt;= 7; L++)    {        b=1;i=L-1;        while( i &gt; 0 ){            b=b*2;i--;        }/*b= 2^(L-1)*/        for( j = 0; j &lt;= b-1; j++ )        {            p=1;i=7-L;            while( i &gt; 0 ) /*p=pow(2,7-L)*j;*/            {                p=p*2;i--;            }            p=p*j;            for( k = j; k &lt; 128; k = k+2*b )            {                TR=dataR[k];TI=dataI[k];temp=dataR[k+b];                dataR[k]=dataR[k]+dataR[k+b]*cos_tab[p]+dataI[k+b]*sin_tab[p];                dataI[k]=dataI[k]-dataR[k+b]*sin_tab[p]+dataI[k+b]*cos_tab[p];                dataR[k+b]=TR-dataR[k+b]*cos_tab[p]-dataI[k+b]*sin_tab[p];                dataI[k+b]=TI+temp*sin_tab[p]-dataI[k+b]*cos_tab[p];            }        }    }    for( i = 0; i &lt; SAMPLENUMBER/2; i++)    {        w[i]=sqrt(dataR[i]*dataR[i]+dataI[i]*dataI[i]);    }}/*END FFT*/main(){    int i;    InitForFFT();    MakeWave();    for( i = 0; i &lt; SAMPLENUMBER; i++)    {        fWaveR[i]=INPUT[i];        fWaveI[i]=0.0f;        w[i]=0.0f;    }    FFT(fWaveR,fWaveI);    for(i = 0; i &lt; SAMPLENUMBER; i++)    {        DATA[i]=w[i];    }    while(1);  //break point}void InitForFFT(){    int i;    for(i = 0; i &lt; SAMPLENUMBER; i++)    {        sin_tab[i]=sin(PI*2*i/SAMPLENUMBER);        cos_tab[i]=cos(PI*2*i/SAMPLENUMBER);    }}void MakeWave(){    int i;    for( i=0; i&lt;SAMPLENUMBER; i++ )    {        INPUT[i]=sin(PI*2*i/SAMPLENUMBER*3)*1024;    }}  </code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客之备份与恢复</title>
      <link href="/2020/050127743.html"/>
      <url>/2020/050127743.html</url>
      
        <content type="html"><![CDATA[<h1 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h1><p>1、在你的博客仓库创建一个分支<code>hexo</code>（这个命名随意）；</p><p>2、设置<code>hexo</code>为默认分支（不知道怎么设的可以百度）；<br>( <font color="ff0000">第一步和第二步都在<a href="https://github.com/" target="_blank" rel="noopener">github</a>网站中操作</font>)  </p><p>3、将博客仓库<code>hexo分支</code>clone至本地，<br>在本地新建一个文件夹<code>hexo</code>，并在此文件夹中右击鼠标打开<code>git bash</code>,执行命令  </p><pre><code>git clone git@github.com:Username/Username.github.io.git  </code></pre><p>(<font color="ff0000"><code>Username</code>为你自己的名字</font>)<br>克隆完之后在<code>hexo</code>文件夹中会出现新的Username.github.io文件夹，将其中的文件全部删除，只保留<code>.git\</code>文件夹。</p><p>将之前的博客根目录文件夹中的<br><code>_config.yml</code>，<code>themes/</code>，<code>source</code>，<code>scffolds/</code>，<code>package.json</code>，<code>.gitignore</code>复制到Username.github.io文件夹；（<code>Username</code>是你自己的用户名）</p><a id="more"></a><p>4、将themes/next/(是NexT主题)中的<code>.git/</code>删除，否则无法将主题文件夹<code>push</code>；( <font color="ff0000"><code>matery</code>主题中没有这个文件夹，应该就不用删除了</font>)</p><p>5、在Username.github.io文件夹执行<code>git add .</code>，<code>git commit -m &quot;提交文件&quot;</code>，<code>git push origin hexo</code>来提交hexo网站源文件；( <font color="ff0000">命令中的<code>hexo</code>为你创建的分支的名字</font>)    </p><p>6、执行<code>hexo g -d</code>生成静态网页部署到github上。<br>这样，Username.github.io仓库就有master分支保存静态网页，hexo分支保存源文件。<br>到这里备份就完成了。  </p><h1 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h1><h2 id="此后所有的博客操作都在Username-github-io文件夹中进行"><a href="#此后所有的博客操作都在Username-github-io文件夹中进行" class="headerlink" title="( 此后所有的博客操作都在Username.github.io文件夹中进行)"></a>( <font color="ff0000">此后所有的博客操作都在Username.github.io文件夹中进行</font>)</h2><h3 id="在本地对博客修改（包括修改主题样式、发布新文章等）后在Username-github-io文件夹中依次执行命令"><a href="#在本地对博客修改（包括修改主题样式、发布新文章等）后在Username-github-io文件夹中依次执行命令" class="headerlink" title="在本地对博客修改（包括修改主题样式、发布新文章等）后在Username.github.io文件夹中依次执行命令"></a>在本地对博客修改（包括修改主题样式、发布新文章等）后在Username.github.io文件夹中依次执行命令</h3><pre><code>git add .  git commit -m &quot;提交文件  git push origin hexo  hexo g -d  </code></pre><p>即在每次修改完本地博客后重复执行5、6步来完成来提交hexo网站源文件和生成静态网页部署到github上。  </p><h1 id="恢复博客"><a href="#恢复博客" class="headerlink" title="恢复博客"></a>恢复博客</h1><p>换电脑想改博客：  </p><p>1、安装git；  </p><p>2、安装Nodejs和npm；  </p><p>3、使用克隆命令<code>git clone git@github.com:Username/Username.github.io.git</code>将仓库拷贝至本地；  </p><p>4、在文件夹内执行命令<code>npm install hexo-cli -g</code>、<code>npm install</code>、<code>npm install hexo-deployer-git</code>；</p><h2 id="添加ssh-keys"><a href="#添加ssh-keys" class="headerlink" title="添加ssh-keys"></a>添加ssh-keys</h2><p>在终端下运行：<code>ssh-keygen -t rsa -C &quot;yourname@email.com&quot;</code>，一路回车；<br>会在.ssh目录生成<code>id_rsa</code>、<code>id_rsa.pub</code>两个文件，这就是密钥对，<code>id_rsa</code>是私钥，千万不能泄漏出去；  </p><p>登录<a href="https://github.com/" target="_blank" rel="noopener">Github</a>，打开「Settings」–&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥<code>id_rsa.pub</code>文件的内容，注意不要粘贴成<code>id_rsa</code>，最后点击「Add SSH Key」。</p><blockquote><p><font color="ff0000">版权声明：本文为个人总结，欢迎转载，转载请注明出处，勿用于商业用途！</font>   </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网站搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建Hexo+Coding(最新教程)</title>
      <link href="/2020/042226283.html"/>
      <url>/2020/042226283.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-Hexo搭建"><a href="#1-Hexo搭建" class="headerlink" title="1. Hexo搭建"></a>1. Hexo搭建</h1><h2 id="1-nodejs，Git环境搭建："><a href="#1-nodejs，Git环境搭建：" class="headerlink" title="1.nodejs，Git环境搭建："></a>1.nodejs，Git环境搭建：</h2><ul><li><a href="https://blog.csdn.net/qq_43285335/article/details/90696126" target="_blank" rel="noopener">node.js搭建</a> </li><li><a href="https://www.cnblogs.com/xueweisuoyong/p/11914045.html" target="_blank" rel="noopener">git搭建</a>-<br><a href="https://www.cnblogs.com/luyuandatabase/p/12145707.html" target="_blank" rel="noopener">淘宝云配置</a> </li></ul><h2 id="2-注册github"><a href="#2-注册github" class="headerlink" title="2.注册github"></a>2.注册github</h2><ol><li>注册就不用我说了，创建仓库视频里有，然后这个也很简单，不会就百度（应该没人去百度<br>的，太简单了）</li><li>格式要求：gfyuan.github.io</li></ol><h2 id="3-快速利用hexo搭建博客："><a href="#3-快速利用hexo搭建博客：" class="headerlink" title="3.快速利用hexo搭建博客："></a>3.快速利用hexo搭建博客：</h2><p> 1.<a href="https://hexoscript.gitbook.io/hexo-script/" target="_blank" rel="noopener">Hexo脚本教程</a>  </p><p> 2.<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">主题安装及优化</a>  </p><h1 id="2-Coding创建项目"><a href="#2-Coding创建项目" class="headerlink" title="2.Coding创建项目"></a>2.Coding创建项目</h1><h3 id="1-首先，去Coding官网注册一个账号，接着，点击“-创建项目”-创建一个新项目。"><a href="#1-首先，去Coding官网注册一个账号，接着，点击“-创建项目”-创建一个新项目。" class="headerlink" title="1.首先，去Coding官网注册一个账号，接着，点击“+ 创建项目”,创建一个新项目。"></a>1.首先，去Coding<a href="coding.net">官网注册</a>一个账号，接着，点击“+ 创建项目”,创建一个新项目。</h3><ul><li>选择项目模板<br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P052211.jpg" alt=""><ul><li>创建项目<br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P052212.jpg" alt=""> <h3 id="2-同步本地hexo到coding上"><a href="#2-同步本地hexo到coding上" class="headerlink" title="2.同步本地hexo到coding上"></a>2.同步本地hexo到coding上</h3>把获取到了ssh配置在上面的<code>_config.yml</code>文件中的deploy下，<pre><code>deploy:type: gitrepo:    github: git@github.com:你的用户名/你的仓库名.github.io.git   coding: git@e.coding.net:你的用户名/你的仓库名.gitbranch: master</code></pre>如果是第一次使用coding的话，需要设置SSH公钥，生成的方法可以参考<a href="https://help.coding.net/" target="_blank" rel="noopener">coding帮助中心</a>   </li></ul></li></ul><p>当然这里直接使用之前部署github时已经生成的公钥。<br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P052213.jpg" alt="">    </p><p>添加后，在<code>git bash</code>命令输入：</p><pre><code>ssh -T git@git.coding.net</code></pre><p>如果得到下面提示就表示公钥添加成功了：</p><pre><code>Coding.net Tips : [Hello ! You&#39;ve conected to Coding.net by SSH successfully! ]</code></pre><p>最后使用部署命令就能把博客同步到coding上面：</p><pre><code>hexo g -d</code></pre><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P052214.jpg" alt=""> </p><h1 id="3-pages服务方式部署"><a href="#3-pages服务方式部署" class="headerlink" title="3.pages服务方式部署"></a>3.pages服务方式部署</h1><ul><li><p>你在你的仓库里是找不到pages页面的需要进行以下操作<br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P1.png" alt="">   </p><ul><li>勾选上持续部署和持续集成<br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P2.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P3.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P4.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P5.png" alt=""><br>然后就可通过访问地址访问自己的博客啦！</li></ul></li><li><p>如果你有自己的私人域名也可以绑定自己的域名<br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P6.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P7.png" alt="">  然后在你的域名服务台解析到你的博客访问地址即可通过域名访问博客。  </p></li></ul><blockquote><p><font color="ff0000">版权声明：本文为个人总结，欢迎转载，转载请注明出处，勿用于商业用途！</font>  </p></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1443900438&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> 网站搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你若安好，便是晴天</title>
      <link href="/2020/032134362.html"/>
      <url>/2020/032134362.html</url>
      
        <content type="html"><![CDATA[<hr><p> 晨起，窗外的阳光已是浩浩荡荡，远山苍绿如黛。夏天，就这样不慌不忙地来到身边，草木深深，风华绝代。</p><p>人生匆匆的聚散里，往事如烟，陌上花开如旧，而我们，却在凡俗的烟火里，承担岁月带给我们的浮世沧桑。青梅煮酒，一如旧时的味道，而那些走散的人，却再不会再回来。</p><p>我们都是光阴里的过客，有些人只是擦肩而过，有些人会短暂的停留，而有些人会携手白头。凡尘的烟火缭绕，我们总是在如烟的世海里丢了自己。岁月，偷换的又岂止是青春红颜，还有那些最初的情怀。</p><p>我们都只是拥挤红尘里孤独的赶路人，寂寞时，我们需要回忆相伴；迷茫时，我们需要情怀偎依取暖。</p><p>世间所有女子都曾如精灵般存在，或是柔情，或是灵动，在光阴里含笑，为一场雨动情。爱人间的莺歌燕舞，爱江南的山温水软，爱世间一切美好的东西。</p><p>世间所有女子都曾有过绝代的风华，有些人将这风华酿成一坛芬芳的酒酿，沉醉岁月；而有些，却在生活的枝头渐次苍白，一一凋落。</p><p>生活百味纷杂，尝过人情世味，看过世态炎凉，浸泡在红尘的染缸里，她们都不复当初的模样。世事如刀，所有最初的情怀、柔肠和优雅，被一点点削减。 </p><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/MoreInterests-PIC21a87bce-674a-4981-b056-60c22a7935d3.jpg" alt=""> </p><p>风景生动的城里，古城温暖的阳光里，江南水乡的石桥上，总有那怀着温润洁净情怀的女子走过；寻常的巷陌里，小镇的溪水旁，乡间的田野里，总有女子在为生活而奔忙。从她们降生在人间开始，便有万千色彩的故事等着她们去演绎。有悲欢，有离合，有酸甜，有苦辣。</p><p>不知在什么时候，便喜欢上这两个字：惜缘。佛说，前世五百次的回眸，换来今生的擦肩而过。</p><p>张爱玲也说：于千万人之中遇见你所要遇见的人, 于千万年之中, 时间的无涯的荒野里, 没有早一步, 也没有晚一步, 刚巧赶上了, 没有别的话可说, 惟有轻轻地问一声: “ 噢, 你也在这里?”</p><p>可见人与人的相遇是多么难得的缘分，所以我们应该学会珍惜，任何错过和伤害都是对缘分的蹉跎。</p><p>有时，行走在摩肩接踵的人群中，心中便会涌出莫名的感动，每一个来来去去的生命，都有他们的烟火幸福，有他们完整的故事。</p><p>邂逅一个人，只需片刻，爱上一个人，往往会是一生。</p><p>徐志摩说：一生至少该有一次,为了某个人而忘了自己,不求结果,不求同行,不求曾经拥有,甚至不求你爱我.只求在我最美的年华里,遇见你！</p><p>爱上一个人，是涅槃，亦是重生。因为爱了，所以听风含情，花柳带笑；因为爱了，所以感时花溅泪，恨别鸟惊心；因为爱了！   </p><hr><pre><code>                         初心亦在 有缘再见</code></pre>]]></content>
      
      
      <categories>
          
          <category> 美文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 情感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Github博客搭建入门</title>
      <link href="/2020/031034155.html"/>
      <url>/2020/031034155.html</url>
      
        <content type="html"><![CDATA[<h1 id="网站搭建"><a href="#网站搭建" class="headerlink" title="网站搭建"></a>网站搭建</h1><h2 id="安装需要的编辑软件"><a href="#安装需要的编辑软件" class="headerlink" title="安装需要的编辑软件"></a>安装需要的编辑软件</h2><ul><li>Typora<br>个人建议在国内的软件上下载，不要去官网，下载慢  </li><li>vs code<br>轻量级文档编辑器  </li></ul><h2 id="1-nodejs，Git环境搭建："><a href="#1-nodejs，Git环境搭建：" class="headerlink" title="1.nodejs，Git环境搭建："></a>1.nodejs，Git环境搭建：</h2><ul><li><a href="https://blog.csdn.net/qq_43285335/article/details/90696126" target="_blank" rel="noopener">node.js搭建</a> </li><li><a href="https://www.cnblogs.com/xueweisuoyong/p/11914045.html" target="_blank" rel="noopener">git搭建</a>-<br><a href="https://www.cnblogs.com/luyuandatabase/p/12145707.html" target="_blank" rel="noopener">淘宝云配置</a> </li></ul><h2 id="2-注册github"><a href="#2-注册github" class="headerlink" title="2.注册github"></a>2.注册github</h2><ol><li>注册就不用我说了，创建仓库视频里有，然后这个也很简单，不会就百度（应该没人去百度<br>的，太简单了）</li><li>格式要求：gfyuan.github.io</li></ol><h2 id="3-快速利用hexo搭建博客："><a href="#3-快速利用hexo搭建博客：" class="headerlink" title="3.快速利用hexo搭建博客："></a>3.快速利用hexo搭建博客：</h2><p> 1.<a href="https://hexoscript.gitbook.io/hexo-script/" target="_blank" rel="noopener">脚本教程</a>  </p><p> 2.<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">主题安装及优化</a> </p><p> <a href="https://www.jianshu.com/p/1e402922ee32" target="_blank" rel="noopener">Markdown入门</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客撰写教程</title>
      <link href="/2020/022054914.html"/>
      <url>/2020/022054914.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Markdown——入门指南"><a href="#1-Markdown——入门指南" class="headerlink" title="1.Markdown——入门指南"></a>1.Markdown——入门指南</h2><h1 id="导语："><a href="#导语：" class="headerlink" title="导语："></a>导语：</h1><p>Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的 HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。 </p><h2 id="Markdown-语法的简要规则"><a href="#Markdown-语法的简要规则" class="headerlink" title="Markdown 语法的简要规则"></a>Markdown 语法的简要规则</h2><ul><li><p>标题 </p><p>  #一级标题</p><p>  ##二级标题</p><p>  ###三级标题 </p></li><li><p>无序列表  </p></li></ul><p>*1<br>*2<br>*3</p><ul><li>有序列表   </li></ul><p>1.1<br>1.2<br>1.3  </p><ul><li>图片与链接<br>图片为：! [ ] ( )<br>链接为：[ ] ( )  </li><li>粗体  </li></ul><p><strong>中文本为斜体<br>**</strong>中为粗体  </p><ul><li>分割线<br>三个*为分割线  </li><li>代码框<br>一个``<br>例如：<br><code>if(a&lt;b)   {c=b;}</code>     </li><li>行内代码  <pre><code>coding: git@e.coding.net:</code></pre></li></ul><p><a href="https://www.jianshu.com/p/1e402922ee32" target="_blank" rel="noopener">文章出处</a>  </p><hr><h2 id="2-文章-Front-matter-介绍"><a href="#2-文章-Front-matter-介绍" class="headerlink" title="2.文章 Front-matter 介绍"></a>2.文章 Front-matter 介绍</h2><p>Front-matter 选项详解<br>Front-matter 选项中的所有内容均为非必填的。但我仍然建议至少填写 title 和 date 的值。</p><p>配置选项    默认值    描述<br><strong>title</strong>    Markdown 的文件标题    文章标题，强烈建议填写此选项<br><strong>date</strong>    文件创建时的日期时间    发布时间，强烈建议填写此选项，且最好保证全局唯一<br><strong>author</strong>    根 _config.yml 中的 author    文章作者<br><strong>img</strong>    featureImages 中的某个值    文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <a href="http://xxx.com/xxx.jpg" target="_blank" rel="noopener">http://xxx.com/xxx.jpg</a></p><p>  其余规则见<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">文章出处</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/021516107.html"/>
      <url>/2020/021516107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
