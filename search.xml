<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux-c  指针</title>
      <link href="/2020/071234787.html"/>
      <url>/2020/071234787.html</url>
      
        <content type="html"><![CDATA[<h2 id="地址和变量"><a href="#地址和变量" class="headerlink" title="地址和变量"></a>地址和变量</h2><ul><li>在计算机内存中，每一个字节单元，都有一个编号，称为地址</li></ul><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><ul><li>在C语言中，内存单元的地址称为指针，专门用来存放地址的变量，称为指针变量在不影响理解的情况中，有时对地址、指针和指针变量不区分，通称指针。</li><li>指针指向的内存区域中的数据称为指针的目标</li><li>如果它指向的区域是程序中的一个变量的内存空间，则这个变量称为指针的目标变量。简称为指针的目标。</li></ul><h3 id="2-指针变量的说明"><a href="#2-指针变量的说明" class="headerlink" title="2.指针变量的说明"></a>2.指针变量的说明</h3><p>  一般形式如下：</p><p>&lt;存储类型&gt;&lt;数据类型&gt;*&lt;指针变量名&gt;；*</p><p>例如，</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span>  pName；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>指针的存储类型是指针变量本身的存储类型。</li><li>指针说明时指定的数据类型不是指针变量本身的数据类型，而是指针目标的数据类型。简称为指针的数据类型。</li></ul><h3 id="3-引入指针"><a href="#3-引入指针" class="headerlink" title="3.引入指针"></a>3.引入指针</h3><p>引入指针要注意程序中的px、*px和&amp;px三种表示方法的不同意义。设px为一个指针，则：</p><ul><li>px-指针变量，它的内容是地址量</li><li>*px一指针所指向的对象，它的内容是数据 int</li><li>&amp;px-指针变量占用的存储区域的地址，是个常量</li></ul><h3 id="4-指针赋值运算"><a href="#4-指针赋值运算" class="headerlink" title="4.指针赋值运算"></a>4.指针赋值运算</h3><ul><li><p>指针的赋值运算指的是通过赋值运算符向指针变量送一个地址值</p></li><li><p>向一个指针变量赋值时，送的值必须是地址常量或指针变量，不能是普通的整数（除了赋零以外）</p><h4 id="指针赋值运算常见的有以下几种形式："><a href="#指针赋值运算常见的有以下几种形式：" class="headerlink" title="指针赋值运算常见的有以下几种形式："></a>指针赋值运算常见的有以下几种形式：</h4></li></ul><p>把一个普通变量的地址赋给一个具有相同数据类型的指针</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">double</span> x<span class="token operator">=</span><span class="token number">15</span>，<span class="token operator">*</span>px；px<span class="token operator">=</span><span class="token operator">&amp;</span>x<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>把一个已有地址值的指针变量赋给具有相同数据类型的另一个指针变量例如：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">float</span> a，<span class="token operator">*</span> px，<span class="token operator">*</span> py；px<span class="token operator">=</span><span class="token operator">&amp;</span>a；py<span class="token operator">=</span>px；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把一个数组的地址赋给具有相同数据类型的指针。例如：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span>，<span class="token operator">*</span>pa；pa<span class="token operator">=</span>a；<span class="token operator">/</span>等价pa<span class="token operator">=</span><span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="4-指针运算"><a href="#4-指针运算" class="headerlink" title="4.指针运算"></a>4.指针运算</h3><ul><li>指针运算是以指针变量所存放的地址量作为运算量而进行的运算</li><li>指针运算的实质就是地址的计算</li><li>指针运算的种类是有限的，它只能进行赋值运算、算术运算和关系运算</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P0712.png" alt=""></p><h3 id="5-指针与数组"><a href="#5-指针与数组" class="headerlink" title="5.指针与数组"></a>5.指针与数组</h3><ul><li><p>在C语言中，数组的指针是指数组在内存中的起始地址，数组元素的地址是指数组元素在内存中的起始地址</p></li><li><p>一维数组的数组名为一维数组的指针（起始地址）例如</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">double</span> ×<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span>；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>  因此，x为x数组的起始地址</p><ul><li><p>设指针变量px的地址值等于数组指针x（即指针变量px指向数组的首元数），则：</p><pre class="line-numbers language-c"><code class="language-c">x<span class="token punctuation">[</span>i<span class="token punctuation">]</span>、 <span class="token operator">*</span> （px<span class="token operator">+</span>i）、<span class="token operator">*</span>（x<span class="token operator">+</span>i）和 px<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>具有完全相同的功能：访问数组第i+1个数组元素。</p></li></ul><h4 id="p-i-lt-gt-p-i"><a href="#p-i-lt-gt-p-i" class="headerlink" title="p[ i ] &lt;=&gt; *(p + i)"></a>p[ i ] &lt;=&gt; *(p + i)</h4><h3 id="6-指针与二维数组"><a href="#6-指针与二维数组" class="headerlink" title="6.指针与二维数组"></a>6.指针与二维数组</h3><ul><li>多维数组就是具有两个或两个以上下标的数组</li><li>在C语言中，二维数组的元素连续存储，按行优先存</li></ul><h4 id="行指针（数组指针）"><a href="#行指针（数组指针）" class="headerlink" title="行指针（数组指针）"></a>行指针（数组指针）</h4><ul><li>存储行地址的指针变量，叫做行指针变量。形式如下：·<ul><li>&lt;存储类型&gt;&lt;数据类型&gt;（ * &lt;指针变量名&gt;）[表达式]；<br>·例如，int a [ 2 ] [ 3 ]；int（*p）[ 3 ]；</li></ul></li><li>方括号中的常量表达式表示指针加1，移动几个数据。</li><li>当用行指针操作二维数组时，表达式一般写成1行的元素个数，即列数。</li></ul><h3 id="7-字符指针与字符串"><a href="#7-字符指针与字符串" class="headerlink" title="7.字符指针与字符串"></a>7.字符指针与字符串</h3><ul><li>C语言通过使用字符数组来处理字符串</li><li>通常，我们把char数据类型的指针变量称为字符指针变量。字符指针变量与字符数组有着密切关系，它也被用来处理拿符串。</li></ul><h3 id="8-指针数组"><a href="#8-指针数组" class="headerlink" title="8.指针数组"></a>8.指针数组</h3><p>所谓指针数组是指由若干个具有相同存储类型和数据类型的指针变量构成的集合</p><p>指针数组的一般说明形式：</p><ul><li>&lt;存储类型&gt;&lt;数据类型&gt;*&lt;指针数组名&gt;[&lt;大小&gt;]；</li><li>指针数组名表示该指针数组的起始地址</li></ul><h3 id="9-多级指针"><a href="#9-多级指针" class="headerlink" title="9.多级指针"></a>9.多级指针</h3><ul><li>多级指针和指针数组</li><li>指针数组也可以用另外一个指针来处理。例如：有一个一维字符指针数组ps[5]，char*ps[5]={“Beijing city”，<br>“London city”}；</li></ul><h3 id="10-void指针"><a href="#10-void指针" class="headerlink" title="10.void指针"></a>10.void指针</h3><ul><li><p>void指针是一种不确定数据类型的指针变量，它可以通过强制类型转换让该变量指向任何数据类型的变量一般形式为：</p><p>void*&lt;指针变量名称&gt;；</p></li><li><p>对于void指针，在没有强制类型转换之前，不能进行任何指针的算术运算</p></li></ul><h3 id="11-const修饰指针"><a href="#11-const修饰指针" class="headerlink" title="11.const修饰指针"></a>11.const修饰指针</h3><ul><li><p>常量化指针目标表达式<br>一般说明形式如下：</p><p>const&lt;数据类型&gt;*&lt;指针变量名称&gt;[=&lt;指针运算表达式&gt;]；</p></li><li><p>常量化指针目标是限制通过指针改变其目标的数值，但&lt;指针变量&gt;存储的地址值可以修改</p></li></ul><ul><li><p>常量化指针变量<br>一般说明形式如下：</p><p>&lt;数据类型&gt;*const&lt;指针变量名称&gt;[=&lt;指针运算表达式&gt;];</p></li></ul><ul><li><p>常量化指针变量及其目标表达式<br>一般说明形式如下：</p></li><li><p>const&lt;数据类型&gt; * const&lt;指针变量名&gt;=&lt;指针运算表达式&gt;；</p><p>常量化指针变量及其目标表达式，使得既不可以修改&lt;指针变量&gt;的地址，也不可以通过*&lt;指针变量名称&gt;修改指针所指向变量的值</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git-实战</title>
      <link href="/2020/070253724.html"/>
      <url>/2020/070253724.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git实战"><a href="#Git实战" class="headerlink" title="Git实战"></a>Git实战</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用普通用户登录到虚拟机</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">sudo</span> apt <span class="token function">install</span> <span class="token function">git</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Git在使用之前需要配置用户名和电子邮箱地址，否则不能提交代码。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 配置用户名</span><span class="token function">git</span> config --global user.name <span class="token string">"刘煜"</span><span class="token comment" spellcheck="true"># 配置email</span><span class="token function">git</span> config --global user.email <span class="token string">"liuy_xa@hqyj.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>–global 表示全局配置，对当前用户的所有代码库生效。</p><p>查看配置</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> config --list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>工作目录（working directory）：放代码的目录，在此目录下编辑代码。</p><p>代码库（repository）：保存代码的版本数据库。</p><p>提交（commit）：将工作目录中的代码保存到代码库。</p><p>检出（checkout）：将代码从代码库恢复到工作目录中。</p><p>暂存区（staging area）：相当于购物车，因为一次提交的内容必须是完整的，涉及一个问题或特性修改的所有文件，可以将修改的文件先保存到暂存区，然后统一提交到代码库。</p><h2 id="保存代码"><a href="#保存代码" class="headerlink" title="保存代码"></a>保存代码</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建工作目录</span><span class="token function">mkdir</span> smart_speaker<span class="token comment" spellcheck="true"># 进入工作目录</span><span class="token function">cd</span> smart_speaker<span class="token comment" spellcheck="true"># 创建本地代码库</span><span class="token function">git</span> init<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>工作目录中的<code>.git</code>目录就是本地代码库。</p><p>注意：Linux中以句点开头的目录或文件是隐藏的，需要用<code>ls -a</code>显示。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看工作区状态</span><span class="token function">git</span> status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>未跟踪文件：工作目录中没有保存到代码库的文件。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 将文件修改保存到暂存区</span><span class="token function">git</span> add 文件名/目录名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>注意：空目录不能添加到暂存区。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 将暂存区的修改提交到代码库</span><span class="token function">git</span> commit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>git commit命令会调用GNU Nano文本编辑器，用户需要在编辑器中填写提交日志，否则不能提交。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 不打开文本编辑器，通过git命令行指定提交日志</span><span class="token function">git</span> commit -m <span class="token string">"提交日志"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>提交日志中一般写问题或新特性的编号和名称。</p><h2 id="比较差异"><a href="#比较差异" class="headerlink" title="比较差异"></a>比较差异</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看提交历史记录</span><span class="token function">git</span> log<span class="token comment" spellcheck="true"># 比较版本之间的差异</span><span class="token function">git</span> <span class="token function">diff</span> 提交ID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>提交ID可以使用HEAD别名代替，也可以使用ID的前7字符代替。</p><p>HEAD表示代码库中的最新版本</p><p>HEAD^ 表示最新版本的上一个版本</p><p>HEAD^2 表示最新版本的上2个版本</p><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 将工作目录中的文件恢复为代码库中的最新版本</span><span class="token function">git</span> checkout HEAD <span class="token keyword">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>句点表示要恢复所有文件，如果只恢复一个文件可以把句点换成要恢复的文件名。</p><h2 id="文件重命名和删除"><a href="#文件重命名和删除" class="headerlink" title="文件重命名和删除"></a>文件重命名和删除</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 重命名工作目录中的文件</span><span class="token function">git</span> <span class="token function">mv</span> 原文件名 新文件名<span class="token function">git</span> commit -m <span class="token string">"提交日志"</span><span class="token comment" spellcheck="true"># 删除工作目录中的文件</span><span class="token function">git</span> <span class="token function">rm</span> 文件名<span class="token function">git</span> commit -m <span class="token string">"提交日志"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="远程代码库"><a href="#远程代码库" class="headerlink" title="远程代码库"></a>远程代码库</h2><p>注册码云账号：<a href="https://gitee.com" target="_blank" rel="noopener">https://gitee.com</a></p><h2 id="下载远程代码库"><a href="#下载远程代码库" class="headerlink" title="下载远程代码库"></a>下载远程代码库</h2><p>进入码云的代码库主页，点击<code>克隆/下载</code>按钮，复制远程代码库地址。</p><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/PInkedimage-20200630145414459_LI.jpg" alt=""></p><p>使用<code>git clone</code>命令下载代码库到本地，会在当前目录下创建同名工作目录和本地代码库。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> clone https://gitee.com/hqyjxa/XPU-SmartSpeaker-Lab2020.6.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：PuTTY中选中文本即复制，鼠标右键粘贴。</p><h2 id="同步本地代码库到远程"><a href="#同步本地代码库到远程" class="headerlink" title="同步本地代码库到远程"></a>同步本地代码库到远程</h2><p>在本地工作目录中执行</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> push<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="同步远程代码库到本地"><a href="#同步远程代码库到本地" class="headerlink" title="同步远程代码库到本地"></a>同步远程代码库到本地</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> pull<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="关注和点赞"><a href="#关注和点赞" class="headerlink" title="关注和点赞"></a>关注和点赞</h2><p>用户可以关注某个代码库（点击代码库主页上的watch按钮），对此代码库的所有修改会通知此用户。</p><p>用户可以给代码库点赞（点击代码库主页上的star按钮），此代码库地址会记录到用户的收藏夹中。</p><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/PInkedimage-20200630151130034_LI.jpg" alt=""></p><h2 id="提交PR（Pull-Request）"><a href="#提交PR（Pull-Request）" class="headerlink" title="提交PR（Pull Request）"></a>提交PR（Pull Request）</h2><p>Git代码库一般使用Fork-PR流程实现团队开发。</p><ol><li>点击代码库库主页上的Fork按钮，复制远程代码库到自己的账号。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/Pimage-20200630151712465.png" alt=""></p><ol start="2"><li>用户修改副本代码库中的内容。<ol><li>克隆副本代码库到本地（git clone）</li><li>修改工作目录中的文件</li><li>将工作目录中的修改提交到本地代码库（git add/git commit）</li><li>将本地代码库的修改同步到远程副本代码库中（git push），注意需要输入码云的账号和密码，密码不会回显。</li></ol></li><li>创建PR（Pull Request）</li></ol><p>相当于给主代码库的管理员发送邮件，请求将自己的修改合并到主代码库中。</p><p><img src="F:/%E4%B9%A6%E7%B1%8D/%E4%B8%93%E4%B8%9A/%E7%94%9F%E4%BA%A7%E5%AE%9E%E4%B9%A0/%E5%8D%8E%E6%B8%85%E8%BF%9C%E8%A7%81%E5%AE%9E%E4%B9%A0%E6%97%A5%E5%BF%97/XPU-SmartSpeaker-Lab2020.6/notes/Git%E5%AE%9E%E6%88%98.assets/image-20200630152843700.png" alt="image-20200630152843700"></p><p>填写PR的标题，描述，然后点击<code>创建</code>按钮。</p><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/Pimage-20200630153329594.png" alt=""></p><p>PR创建后，可以在主代码库的PR列表中看到。</p><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/PInkedimage-20200630153834708_LI.jpg" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/PInkedimage-20200630153926248_LI.jpg" alt=""></p><ol start="4"><li>主代码库管理员，点击<code>合并</code>按钮后，就可以将副本代码库中的修改合并到主代码库中。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/Pimage-20200630154126462.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 仓库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-大厂面试</title>
      <link href="/2020/063047634.html"/>
      <url>/2020/063047634.html</url>
      
        <content type="html"><![CDATA[<hr><h2 id="0625"><a href="#0625" class="headerlink" title="0625"></a>0625</h2><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P0625.jpg" alt=""></h2><h2 id="0626"><a href="#0626" class="headerlink" title="0626"></a>0626</h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P0626.jpg" alt=""></h2><h2 id="0627"><a href="#0627" class="headerlink" title="0627"></a>0627</h2><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P0627.jpg" alt=""></h2><h2 id="0628"><a href="#0628" class="headerlink" title="0628"></a>0628</h2><h2 id="-3"><a href="#-3" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P0628.jpg" alt=""></h2><h2 id="0629"><a href="#0629" class="headerlink" title="0629"></a>0629</h2><h2 id="-4"><a href="#-4" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P0629.jpg" alt=""></h2><h2 id="0701"><a href="#0701" class="headerlink" title="0701"></a>0701</h2><h2 id="-5"><a href="#-5" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P0701.jpg" alt=""></h2><h2 id="0702"><a href="#0702" class="headerlink" title="0702"></a>0702</h2><h2 id="-6"><a href="#-6" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P0702.jpg" alt=""></h2>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-踩雷</title>
      <link href="/2020/062964318.html"/>
      <url>/2020/062964318.html</url>
      
        <content type="html"><![CDATA[<h2 id="下面程序执行的结果是？（-C）"><a href="#下面程序执行的结果是？（-C）" class="headerlink" title="下面程序执行的结果是？（ C）"></a>下面程序执行的结果是？（ C）</h2><pre><code>        boolean b=true;        if(b=false)  //雷区        {            System.out.println(&quot;a&quot;);        }        else if(b)        {            System.out.println(b);            }        else if(!b)        {            System.out.println(&quot;c&quot;);        }        else            System.out.println(&quot;d&quot;); </code></pre><p>A.    a<br>B.true<br>C.    c<br>D.d</p><h3 id="注：’b-false’不是逻辑判断，而是把false赋值给b"><a href="#注：’b-false’不是逻辑判断，而是把false赋值给b" class="headerlink" title="注：’b=false’不是逻辑判断，而是把false赋值给b"></a>注：’b=false’不是逻辑判断，而是把false赋值给b</h3><h2 id="下面程序执行的结果是？（D）"><a href="#下面程序执行的结果是？（D）" class="headerlink" title="下面程序执行的结果是？（D）"></a>下面程序执行的结果是？（D）</h2><pre><code>    int x=2,y=3;    switch(x)    {        default:        y++;        case 3:        y++;        case 4:        y++;    }    System.out.println(&quot;y=&quot;+y);</code></pre><p>A.  3  </p><p>B.  4  </p><p>C.  5  </p><p>D.  6</p><h3 id="注：没有break，顺序执行"><a href="#注：没有break，顺序执行" class="headerlink" title="注：没有break，顺序执行"></a>注：没有break，顺序执行</h3>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day27</title>
      <link href="/2020/062834973.html"/>
      <url>/2020/062834973.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-反射-理解"><a href="#1-反射-理解" class="headerlink" title="1:反射(理解)"></a>1:反射(理解)</h2><h3 id="1-类的加载及类加载器"><a href="#1-类的加载及类加载器" class="headerlink" title="(1)类的加载及类加载器"></a>(1)类的加载及类加载器</h3><h3 id="2-反射："><a href="#2-反射：" class="headerlink" title="(2)反射："></a>(2)反射：</h3><pre><code>    通过字节码文件对象，去使用成员变量，构造方法，成员方法</code></pre><h3 id="3-反射的使用"><a href="#3-反射的使用" class="headerlink" title="(3)反射的使用"></a>(3)反射的使用</h3><pre><code>    A:通过反射获取构造方法并使用    B:通过反射获取成员变量并使用    C:通过反射获取成员方法并使用</code></pre><h3 id="4-反射案例"><a href="#4-反射案例" class="headerlink" title="(4)反射案例"></a>(4)反射案例</h3><pre><code>    A:通过反射运行配置文件的内容    B:通过反射越过泛型检查    C:通过反射给任意的一个对象的任意的属性赋值为指定的值</code></pre><h3 id="5-动态代理"><a href="#5-动态代理" class="headerlink" title="(5)动态代理"></a>(5)动态代理</h3><h2 id="2-设计模式"><a href="#2-设计模式" class="headerlink" title="2:设计模式"></a>2:设计模式</h2><h3 id="1-装饰设计模式"><a href="#1-装饰设计模式" class="headerlink" title="(1)装饰设计模式"></a>(1)装饰设计模式</h3><pre><code>    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));    Scanner sc = new Scanner(System.in);</code></pre><h3 id="2-模版设计模式"><a href="#2-模版设计模式" class="headerlink" title="(2)模版设计模式"></a>(2)模版设计模式</h3><h2 id="3-JDK新特性"><a href="#3-JDK新特性" class="headerlink" title="3:JDK新特性"></a>3:JDK新特性</h2><h3 id="1-JDK5-掌握"><a href="#1-JDK5-掌握" class="headerlink" title="(1)JDK5(掌握)"></a>(1)JDK5(掌握)</h3><pre><code>    装箱和拆箱    泛型    增强for    静态导入    可变参数    枚举</code></pre><h3 id="2-JDK6-了解"><a href="#2-JDK6-了解" class="headerlink" title="(2)JDK6(了解)"></a>(2)JDK6(了解)</h3><h3 id="3-JDK7-理解"><a href="#3-JDK7-理解" class="headerlink" title="(3)JDK7(理解)"></a>(3)JDK7(理解)</h3><pre><code>    二进制的表现形式    用_分隔数据    switch语句可是用字符串    泛型推断(菱形泛型)    多catch的使用    自动释放资源的用法</code></pre><h3 id="4-JDK8-了解"><a href="#4-JDK8-了解" class="headerlink" title="(4)JDK8(了解)"></a>(4)JDK8(了解)</h3><pre><code>    可以去网上了解资料</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-异常处理</title>
      <link href="/2020/062858003.html"/>
      <url>/2020/062858003.html</url>
      
        <content type="html"><![CDATA[<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>很多事件并非总是按照人们自己设计意愿顺利发展<br>的， 而是有能够出现这样那样的异常情况。 例如：<br>你计划周末郊游， 你的计划会安排满满的， 你计划<br>可能是这样的： 从家里出发→到达目的→游泳→烧<br>烤→回家。 但天有不测风云， 当前你准备烧烤时候<br>天降大雨， 你只能终止郊游提前回家。 “天降大<br>雨”是一种异常情况， 你的计划应该考虑到这样情<br>况， 并且应该有处理这种异常的预案。<br>为增强程序的健壮性， 计算机程序的编写也需要考<br>虑处理这些异常情况， Java语言提供了异常处理功<br>能， 本章介绍Java异常处理机制。   </p><h2 id="从一个问题开始"><a href="#从一个问题开始" class="headerlink" title="从一个问题开始"></a>从一个问题开始</h2><p>为了学习Java异常处理机制， 首先看看下面程序。</p><pre><code>//HelloWorld.java文件package com.a51work6;public class HelloWorld {    public static void main(String[] args) {    int a = 0;    System.out.println(5 / a);    }} </code></pre><p>这个程序没有编译错误， 但会发生如下的运行时错误：</p><pre><code>Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zeat com.a51work6.HelloWorld.main(HelloWorld.java:9)</code></pre><p>在数学上除数不能为0， 所以程序运行时表达式（5 / a） 会抛出ArithmeticException异常，ArithmeticException是数学计算异常， 凡是发生数<br>学计算错误都会抛出该异常。程序运行过程中难免会发生异常， 发生异常并不可<br>怕， 程序员应该考虑到有可能发生这些异常， 编程<br>时应该捕获并进行处理异常， 不能让程序发生终<br>止， 这就是健壮的程序。    </p><hr><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P%E5%BC%82%E5%B8%B8%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%B1%82%E6%AC%A1.jpg" alt="异常类继承层次">    </p><p>（Java从小白到大牛 509）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day26</title>
      <link href="/2020/062718524.html"/>
      <url>/2020/062718524.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-网络编程-理解"><a href="#1-网络编程-理解" class="headerlink" title="1:网络编程(理解)"></a>1:网络编程(理解)</h2><h3 id="1-网络编程：用Java语言实现计算机间数据的信息传递和资源共享"><a href="#1-网络编程：用Java语言实现计算机间数据的信息传递和资源共享" class="headerlink" title="(1)网络编程：用Java语言实现计算机间数据的信息传递和资源共享"></a>(1)网络编程：用Java语言实现计算机间数据的信息传递和资源共享</h3><h3 id="2-网络编程模型"><a href="#2-网络编程模型" class="headerlink" title="(2)网络编程模型"></a>(2)网络编程模型</h3><h3 id="3-网络编程的三要素"><a href="#3-网络编程的三要素" class="headerlink" title="(3)网络编程的三要素"></a>(3)网络编程的三要素</h3><h4 id="A-IP地址"><a href="#A-IP地址" class="headerlink" title="A:IP地址"></a>A:IP地址</h4><pre><code>        a:点分十进制        b:IP地址的组成        c:IP地址的分类        d:dos命令        e:InetAddress</code></pre><h4 id="B-端口"><a href="#B-端口" class="headerlink" title="B:端口"></a>B:端口</h4><pre><code>        是应用程序的标识。范围：0-65535。其中0-1024不建议使用。</code></pre><h4 id="C-协议"><a href="#C-协议" class="headerlink" title="C:协议"></a>C:协议</h4><pre><code>        UDP:数据打包,有限制,不连接,效率高,不可靠        TCP:建立数据通道,无限制,效率低,可靠</code></pre><h3 id="3-Socket机制"><a href="#3-Socket机制" class="headerlink" title="(3)Socket机制"></a>(3)Socket机制</h3><h4 id="A-通信两端都应该有Socket对象"><a href="#A-通信两端都应该有Socket对象" class="headerlink" title="A:通信两端都应该有Socket对象"></a>A:通信两端都应该有Socket对象</h4><h4 id="B-所有的通信都是通过Socket间的IO进行操作的"><a href="#B-所有的通信都是通过Socket间的IO进行操作的" class="headerlink" title="B:所有的通信都是通过Socket间的IO进行操作的"></a>B:所有的通信都是通过Socket间的IO进行操作的</h4><h3 id="4-UDP协议发送和接收数据-掌握-自己补齐代码"><a href="#4-UDP协议发送和接收数据-掌握-自己补齐代码" class="headerlink" title="(4)UDP协议发送和接收数据(掌握 自己补齐代码)"></a>(4)UDP协议发送和接收数据(掌握 自己补齐代码)</h3><h4 id="发送："><a href="#发送：" class="headerlink" title="发送："></a>发送：</h4><p>/*</p><ul><li><p>UDP协议发送数据：</p></li><li><p>A:创建发送端Socket对象</p></li><li><p>B:创建数据，并把数据打包</p></li><li><p>C:调用Socket对象的发送方法发送数据包</p></li><li><p>D:释放资源</p></li><li><p>/  </p><pre><code>  // 创建发送端Socket对象  // DatagramSocket()  DatagramSocket ds = new DatagramSocket();  // 创建数据，并把数据打包  // DatagramPacket(byte[] buf, int length, InetAddress address, int port)  // 创建数据  byte[] bys = &quot;hello,udp,我来了&quot;.getBytes();  // 长度  int length = bys.length;  // IP地址对象  InetAddress address = InetAddress.getByName(&quot;192.168.12.92&quot;);  // 端口  int port = 10086;  DatagramPacket dp = new DatagramPacket(bys, length, address, port);  // 调用Socket对象的发送方法发送数据包  // public void send(DatagramPacket p)  ds.send(dp);  // 释放资源  ds.close();</code></pre></li></ul><h4 id="接收："><a href="#接收：" class="headerlink" title="接收："></a>接收：</h4><p>/*</p><ul><li><p>UDP协议接收数据：</p></li><li><p>A:创建接收端Socket对象</p></li><li><p>B:创建一个数据包(接收容器)</p></li><li><p>C:调用Socket对象的接收方法接收数据</p></li><li><p>D:解析数据包，并显示在控制台</p></li><li><p>E:释放资源</p></li><li><p>/  </p><pre><code>  // 创建接收端Socket对象  // DatagramSocket(int port)  DatagramSocket ds = new DatagramSocket(10086);  // 创建一个数据包(接收容器)  // DatagramPacket(byte[] buf, int length)  byte[] bys = new byte[1024];  int length = bys.length;  DatagramPacket dp = new DatagramPacket(bys, length);  // 调用Socket对象的接收方法接收数据  // public void receive(DatagramPacket p)  ds.receive(dp); // 阻塞式  // 解析数据包，并显示在控制台  // 获取对方的ip  // public InetAddress getAddress()  InetAddress address = dp.getAddress();  String ip = address.getHostAddress();  // public byte[] getData():获取数据缓冲区  // public int getLength():获取数据的实际长度  byte[] bys2 = dp.getData();  int len = dp.getLength();  String s = new String(bys2, 0, len);  System.out.println(ip + &quot;传递的数据是:&quot; + s);  // 释放资源  ds.close();</code></pre><h3 id="5-TCP协议发送和接收数据-掌握-自己补齐代码"><a href="#5-TCP协议发送和接收数据-掌握-自己补齐代码" class="headerlink" title="(5)TCP协议发送和接收数据(掌握 自己补齐代码)"></a>(5)TCP协议发送和接收数据(掌握 自己补齐代码)</h3><h4 id="发送：-1"><a href="#发送：-1" class="headerlink" title="发送："></a>发送：</h4><p>/*</p></li><li><p>TCP协议发送数据：</p></li><li><p>A:创建发送端的Socket对象</p></li><li><p>这一步如果成功，就说明连接已经建立成功了。</p></li><li><p>B:获取输出流，写数据</p></li><li><p>C:释放资源</p></li><li></li><li><p>连接被拒绝。TCP协议一定要先看服务器。</p></li><li><p>java.net.ConnectException: Connection refused: connect</p></li><li><p>/  </p><pre><code>  // 创建发送端的Socket对象  // Socket(InetAddress address, int port)  // Socket(String host, int port)  // Socket s = new Socket(InetAddress.getByName(&quot;192.168.12.92&quot;), 8888);  Socket s = new Socket(&quot;192.168.12.92&quot;, 8888);  // 获取输出流，写数据  // public OutputStream getOutputStream()  OutputStream os = s.getOutputStream();  os.write(&quot;hello,tcp,我来了&quot;.getBytes());  // 释放资源  s.close();</code></pre></li></ul><h4 id="接收：-1"><a href="#接收：-1" class="headerlink" title="接收："></a>接收：</h4><p>/*</p><ul><li><p>TCP协议接收数据：</p></li><li><p>A:创建接收端的Socket对象</p></li><li><p>B:监听客户端连接。返回一个对应的Socket对象</p></li><li><p>C:获取输入流，读取数据显示在控制台</p></li><li><p>D:释放资源</p></li><li><p>/  </p><pre><code>  // 创建接收端的Socket对象  // ServerSocket(int port)  ServerSocket ss = new ServerSocket(8888);  // 监听客户端连接。返回一个对应的Socket对象  // public Socket accept()  Socket s = ss.accept(); // 侦听并接受到此套接字的连接。此方法在连接传入之前一直阻塞。  // 获取输入流，读取数据显示在控制台  InputStream is = s.getInputStream();  byte[] bys = new byte[1024];  int len = is.read(bys); // 阻塞式方法  String str = new String(bys, 0, len);  String ip = s.getInetAddress().getHostAddress();  System.out.println(ip + &quot;---&quot; + str);  // 释放资源  s.close();  // ss.close(); //这个不应该关闭 </code></pre><h3 id="6-案例："><a href="#6-案例：" class="headerlink" title="(6)案例："></a>(6)案例：</h3><h4 id="A-UDP"><a href="#A-UDP" class="headerlink" title="A:UDP"></a>A:UDP</h4><pre><code>      a:最基本的UDP协议发送和接收数据      b:把发送数据改进为键盘录入      c:一个简易聊天小程序并用多线程改进</code></pre><h4 id="B-TCP"><a href="#B-TCP" class="headerlink" title="B:TCP"></a>B:TCP</h4><pre><code>      a:最基本的TCP协议发送和接收数据      b:服务器给出反馈      c:客户端键盘录入服务器控制台输出      d:客户端键盘录入服务器写到文本文件      e:客户端读取文本文件服务器控制台输出      f:客户端读取文本文件服务器写到文本文件      g:上传图片      h:多线程改进上传文件</code></pre><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/PUDP%E5%8D%8F%E8%AE%AE%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A7%A3.bmp" alt="UDP协议发送和接收数据图解"></p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/PTCP%E5%8D%8F%E8%AE%AE%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A7%A3.bmp" alt="TCP协议发送和接收数据图解"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day25</title>
      <link href="/2020/062618716.html"/>
      <url>/2020/062618716.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-如何让Netbeans的东西Eclipse能访问。"><a href="#1-如何让Netbeans的东西Eclipse能访问。" class="headerlink" title="1:如何让Netbeans的东西Eclipse能访问。"></a>1:如何让Netbeans的东西Eclipse能访问。</h2><pre><code>在Eclipse中创建项目，把Netbeans项目的src下的东西给拿过来即可。注意：修改项目编码为UTF-8</code></pre><h2 id="2-GUI-了解"><a href="#2-GUI-了解" class="headerlink" title="2:GUI(了解)"></a>2:GUI(了解)</h2><h3 id="1-用户图形界面"><a href="#1-用户图形界面" class="headerlink" title="(1)用户图形界面"></a>(1)用户图形界面</h3><pre><code>    GUI:方便直观    CLI:需要记忆一下命令，麻烦</code></pre><h3 id="2-两个包："><a href="#2-两个包：" class="headerlink" title="(2)两个包："></a>(2)两个包：</h3><pre><code>    java.awt:和系统关联较强    javax.swing:纯Java编写</code></pre><h3 id="3-GUI的继承体系"><a href="#3-GUI的继承体系" class="headerlink" title="(3)GUI的继承体系"></a>(3)GUI的继承体系</h3><pre><code>    组件：组件就是对象        容器组件：是可以存储基本组件和容器组件的组件。        基本组件：是可以使用的组件，但是必须依赖容器。</code></pre><h3 id="4-事件监听机制-理解"><a href="#4-事件监听机制-理解" class="headerlink" title="(4)事件监听机制(理解)"></a>(4)事件监听机制(理解)</h3><h4 id="A-事件源"><a href="#A-事件源" class="headerlink" title="A:事件源"></a>A:事件源</h4><h4 id="B-事件"><a href="#B-事件" class="headerlink" title="B:事件"></a>B:事件</h4><h4 id="C-事件处理"><a href="#C-事件处理" class="headerlink" title="C:事件处理"></a>C:事件处理</h4><h4 id="D-事件监听"><a href="#D-事件监听" class="headerlink" title="D:事件监听"></a>D:事件监听</h4><h3 id="5-适配器模式-理解"><a href="#5-适配器模式-理解" class="headerlink" title="(5)适配器模式(理解)"></a>(5)适配器模式(理解)</h3><h4 id="A-接口"><a href="#A-接口" class="headerlink" title="A:接口"></a>A:接口</h4><h4 id="B-抽象适配器类"><a href="#B-抽象适配器类" class="headerlink" title="B:抽象适配器类"></a>B:抽象适配器类</h4><h4 id="C-实现类"><a href="#C-实现类" class="headerlink" title="C:实现类"></a>C:实现类</h4><h3 id="6-案例："><a href="#6-案例：" class="headerlink" title="(6)案例："></a>(6)案例：</h3><h4 id="A-创建窗体案例"><a href="#A-创建窗体案例" class="headerlink" title="A:创建窗体案例"></a>A:创建窗体案例</h4><h4 id="B-窗体关闭案例"><a href="#B-窗体关闭案例" class="headerlink" title="B:窗体关闭案例"></a>B:窗体关闭案例</h4><h4 id="C-窗体添加按钮并对按钮添加事件案例。"><a href="#C-窗体添加按钮并对按钮添加事件案例。" class="headerlink" title="C:窗体添加按钮并对按钮添加事件案例。"></a>C:窗体添加按钮并对按钮添加事件案例。</h4><pre><code>        界面中的组件布局。</code></pre><h4 id="D-把文本框里面的数据转移到文本域"><a href="#D-把文本框里面的数据转移到文本域" class="headerlink" title="D:把文本框里面的数据转移到文本域"></a>D:把文本框里面的数据转移到文本域</h4><h4 id="E-更改背景色"><a href="#E-更改背景色" class="headerlink" title="E:更改背景色"></a>E:更改背景色</h4><h4 id="F-设置文本框里面不能输入非数字字符"><a href="#F-设置文本框里面不能输入非数字字符" class="headerlink" title="F:设置文本框里面不能输入非数字字符"></a>F:设置文本框里面不能输入非数字字符</h4><h4 id="G-一级菜单"><a href="#G-一级菜单" class="headerlink" title="G:一级菜单"></a>G:一级菜单</h4><h4 id="H-多级菜单"><a href="#H-多级菜单" class="headerlink" title="H:多级菜单"></a>H:多级菜单</h4><h3 id="7-Netbeans的概述和使用"><a href="#7-Netbeans的概述和使用" class="headerlink" title="(7)Netbeans的概述和使用"></a>(7)Netbeans的概述和使用</h3><h4 id="A-是可以做Java开发的另一个IDE工具。"><a href="#A-是可以做Java开发的另一个IDE工具。" class="headerlink" title="A:是可以做Java开发的另一个IDE工具。"></a>A:是可以做Java开发的另一个IDE工具。</h4><h4 id="B-使用"><a href="#B-使用" class="headerlink" title="B:使用"></a>B:使用</h4><pre><code>        A:四则运算            a:修改图标            b:设置皮肤            c:设置居中            d:数据校验</code></pre><h4 id="B-登录注册"><a href="#B-登录注册" class="headerlink" title="B:登录注册"></a>B:登录注册</h4>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day24</title>
      <link href="/2020/062535293.html"/>
      <url>/2020/062535293.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-多线程-理解"><a href="#1-多线程-理解" class="headerlink" title="1:多线程(理解)"></a>1:多线程(理解)</h2><h3 id="1-JDK5以后的针对线程的锁定操作和释放操作"><a href="#1-JDK5以后的针对线程的锁定操作和释放操作" class="headerlink" title="(1)JDK5以后的针对线程的锁定操作和释放操作"></a>(1)JDK5以后的针对线程的锁定操作和释放操作</h3><pre><code>    Lock锁</code></pre><h3 id="2-死锁问题的描述和代码体现"><a href="#2-死锁问题的描述和代码体现" class="headerlink" title="(2)死锁问题的描述和代码体现"></a>(2)死锁问题的描述和代码体现</h3><h3 id="3-生产者和消费者多线程体现-线程间通信问题"><a href="#3-生产者和消费者多线程体现-线程间通信问题" class="headerlink" title="(3)生产者和消费者多线程体现(线程间通信问题)"></a>(3)生产者和消费者多线程体现(线程间通信问题)</h3><pre><code>    以学生作为资源来实现的    资源类：Student    设置数据类：SetThread(生产者)    获取数据类：GetThread(消费者)    测试类：StudentDemo    代码：        A:最基本的版本，只有一个数据。        B:改进版本，给出了不同的数据，并加入了同步机制        C:等待唤醒机制改进该程序，让数据能够实现依次的出现            wait()            notify()            notifyAll() (多生产多消费)        D:等待唤醒机制的代码优化。把数据及操作都写在了资源类中</code></pre><h3 id="4-线程组"><a href="#4-线程组" class="headerlink" title="(4)线程组"></a>(4)线程组</h3><h3 id="5-线程池"><a href="#5-线程池" class="headerlink" title="(5)线程池"></a>(5)线程池</h3><h3 id="6-多线程实现的第三种方案"><a href="#6-多线程实现的第三种方案" class="headerlink" title="(6)多线程实现的第三种方案"></a>(6)多线程实现的第三种方案</h3><h3 id="7-多线程的面试题"><a href="#7-多线程的面试题" class="headerlink" title="(7)多线程的面试题"></a>(7)多线程的面试题</h3><h2 id="2-设计模式-理解"><a href="#2-设计模式-理解" class="headerlink" title="2:设计模式(理解)"></a>2:设计模式(理解)</h2><h3 id="1-面试对象的常见设计原则"><a href="#1-面试对象的常见设计原则" class="headerlink" title="(1)面试对象的常见设计原则"></a>(1)面试对象的常见设计原则</h3><pre><code>    单一    开闭    里氏    依赖注入    接口    迪米特</code></pre><h3 id="2-设计模式概述和分类"><a href="#2-设计模式概述和分类" class="headerlink" title="(2)设计模式概述和分类"></a>(2)设计模式概述和分类</h3><h4 id="A-经验的总结"><a href="#A-经验的总结" class="headerlink" title="A:经验的总结"></a>A:经验的总结</h4><h4 id="B-三类"><a href="#B-三类" class="headerlink" title="B:三类"></a>B:三类</h4><pre><code>        创建型        结构型        行为型</code></pre><h3 id="3-改进的设计模式"><a href="#3-改进的设计模式" class="headerlink" title="(3)改进的设计模式"></a>(3)改进的设计模式</h3><h4 id="A-简单工厂模式"><a href="#A-简单工厂模式" class="headerlink" title="A:简单工厂模式"></a>A:简单工厂模式</h4><h4 id="B-工厂方法模式"><a href="#B-工厂方法模式" class="headerlink" title="B:工厂方法模式"></a>B:工厂方法模式</h4><h4 id="C-单例模式-掌握"><a href="#C-单例模式-掌握" class="headerlink" title="C:单例模式(掌握)"></a>C:单例模式(掌握)</h4><pre><code>        a:饿汉式        b:懒汉式</code></pre><h3 id="4-Runtime"><a href="#4-Runtime" class="headerlink" title="(4)Runtime"></a>(4)Runtime</h3><pre><code>    JDK提供的一个单例模式应用的类。    还可以调用dos命令。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day23</title>
      <link href="/2020/062419356.html"/>
      <url>/2020/062419356.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-多线程-理解"><a href="#1-多线程-理解" class="headerlink" title="1:多线程(理解)"></a>1:多线程(理解)</h2><h3 id="1-多线程：一个应用程序有多条执行路径"><a href="#1-多线程：一个应用程序有多条执行路径" class="headerlink" title="(1)多线程：一个应用程序有多条执行路径"></a>(1)多线程：一个应用程序有多条执行路径</h3><pre><code>    进程：正在执行的应用程序    线程：进程的执行单元，执行路径    单线程：一个应用程序只有一条执行路径    多线程：一个应用程序有多条执行路径    多进程的意义?        提高CPU的使用率    多线程的意义?        提高应用程序的使用率</code></pre><h3 id="2-Java程序的运行原理及JVM的启动是多线程的吗"><a href="#2-Java程序的运行原理及JVM的启动是多线程的吗" class="headerlink" title="(2)Java程序的运行原理及JVM的启动是多线程的吗?"></a>(2)Java程序的运行原理及JVM的启动是多线程的吗?</h3><pre><code>    A:Java命令去启动JVM，JVM会启动一个进程，该进程会启动一个主线程。    B:JVM的启动是多线程的，因为它最低有两个线程启动了，主线程和垃圾回收线程。</code></pre><h3 id="3-多线程的实现方案-自己补齐步骤及代码-掌握"><a href="#3-多线程的实现方案-自己补齐步骤及代码-掌握" class="headerlink" title="(3)多线程的实现方案(自己补齐步骤及代码    掌握)"></a>(3)多线程的实现方案(自己补齐步骤及代码    掌握)</h3><h4 id="A-继承Thread类"><a href="#A-继承Thread类" class="headerlink" title="A:继承Thread类"></a>A:继承Thread类</h4><h4 id="B-实现Runnable接口"><a href="#B-实现Runnable接口" class="headerlink" title="B:实现Runnable接口"></a>B:实现Runnable接口</h4><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E5%9B%BE%E8%A7%A3%E6%AF%94%E8%BE%83%E5%8F%8A%E5%8C%BA%E5%88%AB.bmp" alt=""></p><h3 id="4-线程的调度和优先级问题"><a href="#4-线程的调度和优先级问题" class="headerlink" title="(4)线程的调度和优先级问题"></a>(4)线程的调度和优先级问题</h3><h4 id="A-线程的调度"><a href="#A-线程的调度" class="headerlink" title="A:线程的调度"></a>A:线程的调度</h4><pre><code>        a:分时调度        b:抢占式调度 (Java采用的是该调度方式)</code></pre><h4 id="B-获取和设置线程优先级"><a href="#B-获取和设置线程优先级" class="headerlink" title="B:获取和设置线程优先级"></a>B:获取和设置线程优先级</h4><pre><code>        a:默认是5        b:范围是1-10</code></pre><h3 id="5-线程的控制-常见方法"><a href="#5-线程的控制-常见方法" class="headerlink" title="(5)线程的控制(常见方法)"></a>(5)线程的控制(常见方法)</h3><h4 id="A-休眠线程"><a href="#A-休眠线程" class="headerlink" title="A:休眠线程"></a>A:休眠线程</h4><h4 id="B-加入线程"><a href="#B-加入线程" class="headerlink" title="B:加入线程"></a>B:加入线程</h4><h4 id="C-礼让线程"><a href="#C-礼让线程" class="headerlink" title="C:礼让线程"></a>C:礼让线程</h4><h4 id="D-后台线程"><a href="#D-后台线程" class="headerlink" title="D:后台线程"></a>D:后台线程</h4><h4 id="E-终止线程-掌握"><a href="#E-终止线程-掌握" class="headerlink" title="E:终止线程(掌握)"></a>E:终止线程(掌握)</h4><h3 id="6-线程的生命周期-参照-线程生命周期图解-bmp"><a href="#6-线程的生命周期-参照-线程生命周期图解-bmp" class="headerlink" title="(6)线程的生命周期(参照    线程生命周期图解.bmp)"></a>(6)线程的生命周期(参照    线程生命周期图解.bmp)</h3><h4 id="A-新建"><a href="#A-新建" class="headerlink" title="A:新建"></a>A:新建</h4><h4 id="B-就绪"><a href="#B-就绪" class="headerlink" title="B:就绪"></a>B:就绪</h4><h4 id="C-运行"><a href="#C-运行" class="headerlink" title="C:运行"></a>C:运行</h4><h4 id="D-阻塞"><a href="#D-阻塞" class="headerlink" title="D:阻塞"></a>D:阻塞</h4><h4 id="E-死亡"><a href="#E-死亡" class="headerlink" title="E:死亡"></a>E:死亡</h4><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E8%A7%A3.bmp" alt=""></p><h3 id="7-电影院卖票程序的实现"><a href="#7-电影院卖票程序的实现" class="headerlink" title="(7)电影院卖票程序的实现"></a>(7)电影院卖票程序的实现</h3><h4 id="A-继承Thread类-1"><a href="#A-继承Thread类-1" class="headerlink" title="A:继承Thread类"></a>A:继承Thread类</h4><h4 id="B-实现Runnable接口-1"><a href="#B-实现Runnable接口-1" class="headerlink" title="B:实现Runnable接口"></a>B:实现Runnable接口</h4><h3 id="8-电影院卖票程序出问题"><a href="#8-电影院卖票程序出问题" class="headerlink" title="(8)电影院卖票程序出问题"></a>(8)电影院卖票程序出问题</h3><pre><code>    A:为了更符合真实的场景，加入了休眠100毫秒。    B:卖票问题        a:同票多次        b:负数票</code></pre><h3 id="9-多线程安全问题的原因-也是我们以后判断一个程序是否有线程安全问题的依据"><a href="#9-多线程安全问题的原因-也是我们以后判断一个程序是否有线程安全问题的依据" class="headerlink" title="(9)多线程安全问题的原因(也是我们以后判断一个程序是否有线程安全问题的依据)"></a>(9)多线程安全问题的原因(也是我们以后判断一个程序是否有线程安全问题的依据)</h3><h4 id="A-是否有多线程环境"><a href="#A-是否有多线程环境" class="headerlink" title="A:是否有多线程环境"></a>A:是否有多线程环境</h4><h4 id="B-是否有共享数据"><a href="#B-是否有共享数据" class="headerlink" title="B:是否有共享数据"></a>B:是否有共享数据</h4><h4 id="C-是否有多条语句操作共享数据"><a href="#C-是否有多条语句操作共享数据" class="headerlink" title="C:是否有多条语句操作共享数据"></a>C:是否有多条语句操作共享数据</h4><h3 id="10-同步解决线程安全问题"><a href="#10-同步解决线程安全问题" class="headerlink" title="(10)同步解决线程安全问题"></a>(10)同步解决线程安全问题</h3><h4 id="A-同步代码块"><a href="#A-同步代码块" class="headerlink" title="A:同步代码块"></a>A:同步代码块</h4><pre><code>        synchronized(对象) {            需要被同步的代码;        }        这里的锁对象可以是任意对象。</code></pre><h4 id="B-同步方法"><a href="#B-同步方法" class="headerlink" title="B:同步方法"></a>B:同步方法</h4><pre><code>        把同步加在方法上。        这里的锁对象是this</code></pre><h4 id="C-静态同步方法"><a href="#C-静态同步方法" class="headerlink" title="C:静态同步方法"></a>C:静态同步方法</h4><pre><code>        把同步加在方法上。        这里的锁对象是当前类的字节码文件对象(反射再讲字节码文件对象)</code></pre><h3 id="11-回顾以前的线程安全的类"><a href="#11-回顾以前的线程安全的类" class="headerlink" title="(11)回顾以前的线程安全的类"></a>(11)回顾以前的线程安全的类</h3><h4 id="A-StringBuffer"><a href="#A-StringBuffer" class="headerlink" title="A:StringBuffer"></a>A:StringBuffer</h4><h4 id="B-Vector"><a href="#B-Vector" class="headerlink" title="B:Vector"></a>B:Vector</h4><h4 id="C-Hashtable"><a href="#C-Hashtable" class="headerlink" title="C:Hashtable"></a>C:Hashtable</h4><h4 id="D-如何把一个线程不安全的集合类变成一个线程安全的集合类"><a href="#D-如何把一个线程不安全的集合类变成一个线程安全的集合类" class="headerlink" title="D:如何把一个线程不安全的集合类变成一个线程安全的集合类"></a>D:如何把一个线程不安全的集合类变成一个线程安全的集合类</h4><pre><code>        用Collections工具类的方法即可。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day22</title>
      <link href="/2020/062335677.html"/>
      <url>/2020/062335677.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-登录注册IO版本案例-掌握"><a href="#1-登录注册IO版本案例-掌握" class="headerlink" title="1:登录注册IO版本案例(掌握)"></a>1:登录注册IO版本案例(掌握)</h2><pre><code>要求，对着写一遍。cn.itcast.pojo Usercn.itcast.dao UserDaocn.itcast.dao.impl UserDaoImpl(实现我不管)cn.itcast.game GuessNumbercn.itcast.test    UserTest</code></pre><h2 id="2-数据操作流-操作基本类型数据的流-理解"><a href="#2-数据操作流-操作基本类型数据的流-理解" class="headerlink" title="2:数据操作流(操作基本类型数据的流)(理解)"></a>2:数据操作流(操作基本类型数据的流)(理解)</h2><h3 id="1-可以操作基本类型的数据"><a href="#1-可以操作基本类型的数据" class="headerlink" title="(1)可以操作基本类型的数据"></a>(1)可以操作基本类型的数据</h3><p>333    (2)流对象名称<br>        DataInputStream<br>        DataOutputStream</p><h2 id="3-内存操作流-理解"><a href="#3-内存操作流-理解" class="headerlink" title="3:内存操作流(理解)"></a>3:内存操作流(理解)</h2><h3 id="1-有些时候我们操作完毕后，未必需要产生一个文件，就可以使用内存操作流。"><a href="#1-有些时候我们操作完毕后，未必需要产生一个文件，就可以使用内存操作流。" class="headerlink" title="(1)有些时候我们操作完毕后，未必需要产生一个文件，就可以使用内存操作流。"></a>(1)有些时候我们操作完毕后，未必需要产生一个文件，就可以使用内存操作流。</h3><h3 id="2-三种"><a href="#2-三种" class="headerlink" title="(2)三种"></a>(2)三种</h3><pre><code>    A:ByteArrayInputStream,ByteArrayOutputStream    B:CharArrayReader,CharArrayWriter    C:StringReader,StringWriter</code></pre><h2 id="4-打印流-掌握"><a href="#4-打印流-掌握" class="headerlink" title="4:打印流(掌握)"></a>4:打印流(掌握)</h2><h3 id="1-字节打印流，字符打印流"><a href="#1-字节打印流，字符打印流" class="headerlink" title="(1)字节打印流，字符打印流"></a>(1)字节打印流，字符打印流</h3><h3 id="2-特点："><a href="#2-特点：" class="headerlink" title="(2)特点："></a>(2)特点：</h3><h4 id="A-只操作目的地-不操作数据源"><a href="#A-只操作目的地-不操作数据源" class="headerlink" title="A:只操作目的地,不操作数据源"></a>A:只操作目的地,不操作数据源</h4><h4 id="B-可以操作任意类型的数据"><a href="#B-可以操作任意类型的数据" class="headerlink" title="B:可以操作任意类型的数据"></a>B:可以操作任意类型的数据</h4><h4 id="C-如果启用了自动刷新，在调用println-方法的时候，能够换行并刷新"><a href="#C-如果启用了自动刷新，在调用println-方法的时候，能够换行并刷新" class="headerlink" title="C:如果启用了自动刷新，在调用println()方法的时候，能够换行并刷新"></a>C:如果启用了自动刷新，在调用println()方法的时候，能够换行并刷新</h4><h4 id="D-可以直接操作文件"><a href="#D-可以直接操作文件" class="headerlink" title="D:可以直接操作文件"></a>D:可以直接操作文件</h4><pre><code>        问题：哪些流可以直接操作文件呢?        看API，如果其构造方法能够同时接收File和String类型的参数，一般都是可以直接操作文件的</code></pre><h3 id="3-复制文本文件"><a href="#3-复制文本文件" class="headerlink" title="(3)复制文本文件"></a>(3)复制文本文件</h3><pre><code>    BufferedReader br = new BufferedReader(new FileReader(&quot;a.txt&quot;));    PrintWriter pw = new PrintWriter(new FileWriter(&quot;b.txt&quot;),true);    String line = null;    while((line=br.readLine())!=null) {        pw.println(line);    }    pw.close();    br.close();</code></pre><h2 id="5-标准输入输出流-理解"><a href="#5-标准输入输出流-理解" class="headerlink" title="5:标准输入输出流(理解)"></a>5:标准输入输出流(理解)</h2><h3 id="1-System类下面有这样的两个字段"><a href="#1-System类下面有这样的两个字段" class="headerlink" title="(1)System类下面有这样的两个字段"></a>(1)System类下面有这样的两个字段</h3><pre><code>    in 标准输入流    out 标准输出流</code></pre><h3 id="2-三种键盘录入方式"><a href="#2-三种键盘录入方式" class="headerlink" title="(2)三种键盘录入方式"></a>(2)三种键盘录入方式</h3><h4 id="A-main方法的args接收参数"><a href="#A-main方法的args接收参数" class="headerlink" title="A:main方法的args接收参数"></a>A:main方法的args接收参数</h4><h4 id="B-System-in通过BufferedReader进行包装"><a href="#B-System-in通过BufferedReader进行包装" class="headerlink" title="B:System.in通过BufferedReader进行包装"></a>B:System.in通过BufferedReader进行包装</h4><pre><code>        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));</code></pre><h4 id="C-Scanner"><a href="#C-Scanner" class="headerlink" title="C:Scanner"></a>C:Scanner</h4><pre><code>        Scanner sc = new Scanner(System.in);</code></pre><h3 id="3-输出语句的原理和如何使用字符流输出数据"><a href="#3-输出语句的原理和如何使用字符流输出数据" class="headerlink" title="(3)输出语句的原理和如何使用字符流输出数据"></a>(3)输出语句的原理和如何使用字符流输出数据</h3><h4 id="A-原理"><a href="#A-原理" class="headerlink" title="A:原理"></a>A:原理</h4><pre><code>        System.out.println(&quot;helloworld&quot;);        PrintStream ps = System.out;        ps.println(&quot;helloworld&quot;);</code></pre><h4 id="B-把System-out用字符缓冲流包装一下使用"><a href="#B-把System-out用字符缓冲流包装一下使用" class="headerlink" title="B:把System.out用字符缓冲流包装一下使用"></a>B:把System.out用字符缓冲流包装一下使用</h4><pre><code>        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));</code></pre><h2 id="6-随机访问流-理解"><a href="#6-随机访问流-理解" class="headerlink" title="6:随机访问流(理解)"></a>6:随机访问流(理解)</h2><h3 id="1-可以按照文件指针的位置写数据和读数据。"><a href="#1-可以按照文件指针的位置写数据和读数据。" class="headerlink" title="(1)可以按照文件指针的位置写数据和读数据。"></a>(1)可以按照文件指针的位置写数据和读数据。</h3><h3 id="2-案例："><a href="#2-案例：" class="headerlink" title="(2)案例："></a>(2)案例：</h3><h4 id="A-写数据"><a href="#A-写数据" class="headerlink" title="A:写数据"></a>A:写数据</h4><h4 id="B-读数据"><a href="#B-读数据" class="headerlink" title="B:读数据"></a>B:读数据</h4><h4 id="C-获取和改变文件指针的位置"><a href="#C-获取和改变文件指针的位置" class="headerlink" title="C:获取和改变文件指针的位置"></a>C:获取和改变文件指针的位置</h4><h2 id="7-合并流-理解"><a href="#7-合并流-理解" class="headerlink" title="7:合并流(理解)"></a>7:合并流(理解)</h2><h3 id="1-把多个输入流的数据写到一个输出流中。"><a href="#1-把多个输入流的数据写到一个输出流中。" class="headerlink" title="(1)把多个输入流的数据写到一个输出流中。"></a>(1)把多个输入流的数据写到一个输出流中。</h3><h3 id="2-构造方法："><a href="#2-构造方法：" class="headerlink" title="(2)构造方法："></a>(2)构造方法：</h3><pre><code>    A:SequenceInputStream(InputStream s1, InputStream s2)     B:SequenceInputStream(Enumeration&lt;? extends InputStream&gt; e) </code></pre><h2 id="8-序列化流-理解"><a href="#8-序列化流-理解" class="headerlink" title="8:序列化流(理解)"></a>8:序列化流(理解)</h2><h3 id="1-可以把对象写入文本文件或者在网络中传输"><a href="#1-可以把对象写入文本文件或者在网络中传输" class="headerlink" title="(1)可以把对象写入文本文件或者在网络中传输"></a>(1)可以把对象写入文本文件或者在网络中传输</h3><h3 id="2-如何实现序列化呢"><a href="#2-如何实现序列化呢" class="headerlink" title="(2)如何实现序列化呢?"></a>(2)如何实现序列化呢?</h3><pre><code>    让被序列化的对象所属类实现序列化接口。    该接口是一个标记接口。没有功能需要实现。</code></pre><h3 id="3-注意问题："><a href="#3-注意问题：" class="headerlink" title="(3)注意问题："></a>(3)注意问题：</h3><pre><code>    把数据写到文件后，在去修改类会产生一个问题。    如何解决该问题呢?        在类文件中，给出一个固定的序列化id值。        而且，这样也可以解决黄色警告线问题</code></pre><h3 id="4-面试题："><a href="#4-面试题：" class="headerlink" title="(4)面试题："></a>(4)面试题：</h3><pre><code>    什么时候序列化?    如何实现序列化?    什么是反序列化?</code></pre><h2 id="9-Properties-理解"><a href="#9-Properties-理解" class="headerlink" title="9:Properties(理解)"></a>9:Properties(理解)</h2><h3 id="1-是一个集合类，Hashtable的子类"><a href="#1-是一个集合类，Hashtable的子类" class="headerlink" title="(1)是一个集合类，Hashtable的子类"></a>(1)是一个集合类，Hashtable的子类</h3><h3 id="2-特有功能"><a href="#2-特有功能" class="headerlink" title="(2)特有功能"></a>(2)特有功能</h3><pre><code>    A:public Object setProperty(String key,String value)    B:public String getProperty(String key)    C:public Set&lt;String&gt; stringPropertyNames()</code></pre><h3 id="3-和IO流结合的方法"><a href="#3-和IO流结合的方法" class="headerlink" title="(3)和IO流结合的方法"></a>(3)和IO流结合的方法</h3><pre><code>    把键值对形式的文本文件内容加载到集合中    public void load(Reader reader)    public void load(InputStream inStream)    把集合中的数据存储到文本文件中    public void store(Writer writer,String comments)    public void store(OutputStream out,String comments)</code></pre><h3 id="4-案例："><a href="#4-案例：" class="headerlink" title="(4)案例："></a>(4)案例：</h3><pre><code>    A:根据给定的文件判断是否有键为&quot;lisi&quot;的，如果有就修改其值为100    B:写一个程序实现控制猜数字小游戏程序不能玩超过5次</code></pre><h2 id="10-NIO-了解"><a href="#10-NIO-了解" class="headerlink" title="10:NIO(了解)"></a>10:NIO(了解)</h2><h3 id="1-JDK4出现的NIO，对以前的IO操作进行了优化，提供了效率。但是大部分我们看到的还是以前的IO"><a href="#1-JDK4出现的NIO，对以前的IO操作进行了优化，提供了效率。但是大部分我们看到的还是以前的IO" class="headerlink" title="(1)JDK4出现的NIO，对以前的IO操作进行了优化，提供了效率。但是大部分我们看到的还是以前的IO"></a>(1)JDK4出现的NIO，对以前的IO操作进行了优化，提供了效率。但是大部分我们看到的还是以前的IO</h3><h3 id="2-JDK7的NIO的使用"><a href="#2-JDK7的NIO的使用" class="headerlink" title="(2)JDK7的NIO的使用"></a>(2)JDK7的NIO的使用</h3><pre><code>    Path:路径    Paths:通过静态方法返回一个路径    Files:提供了常见的功能        复制文本文件        把集合中的数据写到文本文件</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day21</title>
      <link href="/2020/062235357.html"/>
      <url>/2020/062235357.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-字符流-掌握"><a href="#1-字符流-掌握" class="headerlink" title="1:字符流(掌握)"></a>1:字符流(掌握)</h2><h3 id="1-字节流操作中文数据不是特别的方便，所以就出现了转换流。"><a href="#1-字节流操作中文数据不是特别的方便，所以就出现了转换流。" class="headerlink" title="(1)字节流操作中文数据不是特别的方便，所以就出现了转换流。"></a>(1)字节流操作中文数据不是特别的方便，所以就出现了转换流。</h3><pre><code>   转换流的作用就是把字节流转换字符流来使用。</code></pre><h3 id="2-转换流其实是一个字符流"><a href="#2-转换流其实是一个字符流" class="headerlink" title="(2)转换流其实是一个字符流"></a>(2)转换流其实是一个字符流</h3><pre><code>    字符流 = 字节流 + 编码表</code></pre><h3 id="3-编码表"><a href="#3-编码表" class="headerlink" title="(3)编码表"></a>(3)编码表</h3><h4 id="A-就是由字符和对应的数值组成的一张表"><a href="#A-就是由字符和对应的数值组成的一张表" class="headerlink" title="A:就是由字符和对应的数值组成的一张表"></a>A:就是由字符和对应的数值组成的一张表</h4><h4 id="B-常见的编码表"><a href="#B-常见的编码表" class="headerlink" title="B:常见的编码表"></a>B:常见的编码表</h4><pre><code>        ASCII        ISO-8859-1        GB2312        GBK        GB18030        UTF-8</code></pre><h4 id="C-字符串中的编码问题"><a href="#C-字符串中的编码问题" class="headerlink" title="C:字符串中的编码问题"></a>C:字符串中的编码问题</h4><pre><code>        编码            String -- byte[]        解码            byte[] -- String</code></pre><h3 id="4-IO流中的编码问题"><a href="#4-IO流中的编码问题" class="headerlink" title="(4)IO流中的编码问题"></a>(4)IO流中的编码问题</h3><h4 id="A-OutputStreamWriter"><a href="#A-OutputStreamWriter" class="headerlink" title="A:OutputStreamWriter"></a>A:OutputStreamWriter</h4><pre><code>        OutputStreamWriter(OutputStream os):默认编码，GBK        OutputStreamWriter(OutputStream os,String charsetName):指定编码。</code></pre><h4 id="B-InputStreamReader"><a href="#B-InputStreamReader" class="headerlink" title="B:InputStreamReader"></a>B:InputStreamReader</h4><pre><code>        InputStreamReader(InputStream is):默认编码，GBK        InputStreamReader(InputStream is,String charsetName):指定编码</code></pre><h4 id="C-编码问题其实很简单"><a href="#C-编码问题其实很简单" class="headerlink" title="C:编码问题其实很简单"></a>C:编码问题其实很简单</h4><pre><code>        编码只要一致即可</code></pre><h3 id="5-字符流"><a href="#5-字符流" class="headerlink" title="(5)字符流"></a>(5)字符流</h3><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><pre><code>        |--InputStreamReader            |--FileReader        |--BufferedReader</code></pre><h4 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h4><pre><code>        |--OutputStreamWriter            |--FileWriter        |--BufferedWriter</code></pre><h3 id="6-复制文本文件-5种方式"><a href="#6-复制文本文件-5种方式" class="headerlink" title="(6)复制文本文件(5种方式)"></a>(6)复制文本文件(5种方式)</h3><h2 id="2-IO流小结-掌握"><a href="#2-IO流小结-掌握" class="headerlink" title="2:IO流小结(掌握)"></a>2:IO流小结(掌握)</h2><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><h4 id="–字节流"><a href="#–字节流" class="headerlink" title="|–字节流"></a>|–字节流</h4><pre><code>        |--字节输入流            InputStream                int read():一次读取一个字节                int read(byte[] bys):一次读取一个字节数组                |--FileInputStream                |--BufferedInputStream        |--字节输出流            OutputStream                void write(int by):一次写一个字节                void write(byte[] bys,int index,int len):一次写一个字节数组的一部分                |--FileOutputStream                |--BufferedOutputStream</code></pre><h4 id="–字符流"><a href="#–字符流" class="headerlink" title="|–字符流"></a>|–字符流</h4><pre><code>        |--字符输入流            Reader                int read():一次读取一个字符                int read(char[] chs):一次读取一个字符数组                |--InputStreamReader                    |--FileReader                |--BufferedReader                    String readLine():一次读取一个字符串        |--字符输出流            Writer                void write(int ch):一次写一个字符                void write(char[] chs,int index,int len):一次写一个字符数组的一部分                |--OutputStreamWriter                    |--FileWriter                |--BufferedWriter                    void newLine():写一个换行符                    void write(String line):一次写一个字符串</code></pre><h2 id="3-案例-理解-练习一遍"><a href="#3-案例-理解-练习一遍" class="headerlink" title="3:案例(理解 练习一遍)"></a>3:案例(理解 练习一遍)</h2><pre><code>A:复制文本文件 5种方式(掌握)B:复制图片(二进制流数据) 4种方式(掌握)C:把集合中的数据存储到文本文件D:把文本文件中的数据读取到集合并遍历集合E:复制单级文件夹F:复制单级文件夹中指定的文件并修改名称    回顾一下批量修改名称G:复制多级文件夹H:键盘录入学生信息按照总分从高到低存储到文本文件I:把某个文件中的字符串排序后输出到另一个文本文件中J:用Reader模拟BufferedReader的特有功能K:模拟LineNumberReader的特有功能</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day20</title>
      <link href="/2020/062119164.html"/>
      <url>/2020/062119164.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-递归-理解"><a href="#1-递归-理解" class="headerlink" title="1:递归(理解)"></a>1:递归(理解)</h2><h3 id="1-方法定义中调用方法本身的现象"><a href="#1-方法定义中调用方法本身的现象" class="headerlink" title="(1)方法定义中调用方法本身的现象"></a>(1)方法定义中调用方法本身的现象</h3><pre><code>    举例：老和尚给小和尚讲故事，我们学编程</code></pre><h3 id="2-递归的注意事项；"><a href="#2-递归的注意事项；" class="headerlink" title="(2)递归的注意事项；"></a>(2)递归的注意事项；</h3><h4 id="A-要有出口，否则就是死递归"><a href="#A-要有出口，否则就是死递归" class="headerlink" title="A:要有出口，否则就是死递归"></a>A:要有出口，否则就是死递归</h4><h4 id="B-次数不能过多，否则内存溢出"><a href="#B-次数不能过多，否则内存溢出" class="headerlink" title="B:次数不能过多，否则内存溢出"></a>B:次数不能过多，否则内存溢出</h4><h4 id="C-构造方法不能递归使用"><a href="#C-构造方法不能递归使用" class="headerlink" title="C:构造方法不能递归使用"></a>C:构造方法不能递归使用</h4><h3 id="3-递归的案例："><a href="#3-递归的案例：" class="headerlink" title="(3)递归的案例："></a>(3)递归的案例：</h3><h4 id="A-递归求阶乘"><a href="#A-递归求阶乘" class="headerlink" title="A:递归求阶乘"></a>A:递归求阶乘</h4><h4 id="B-兔子问题"><a href="#B-兔子问题" class="headerlink" title="B:兔子问题"></a>B:兔子问题</h4><h4 id="C-递归输出指定目录下所有指定后缀名的文件绝对路径"><a href="#C-递归输出指定目录下所有指定后缀名的文件绝对路径" class="headerlink" title="C:递归输出指定目录下所有指定后缀名的文件绝对路径"></a>C:递归输出指定目录下所有指定后缀名的文件绝对路径</h4><h4 id="D-递归删除带内容的目录-小心使用"><a href="#D-递归删除带内容的目录-小心使用" class="headerlink" title="D:递归删除带内容的目录(小心使用)"></a>D:递归删除带内容的目录(小心使用)</h4><h2 id="2-IO流-掌握"><a href="#2-IO流-掌握" class="headerlink" title="2:IO流(掌握)"></a>2:IO流(掌握)</h2><h3 id="1-IO用于在设备间进行数据传输的操作"><a href="#1-IO用于在设备间进行数据传输的操作" class="headerlink" title="(1)IO用于在设备间进行数据传输的操作"></a>(1)IO用于在设备间进行数据传输的操作</h3><h3 id="2-分类："><a href="#2-分类：" class="headerlink" title="(2)分类："></a>(2)分类：</h3><h4 id="A-流向"><a href="#A-流向" class="headerlink" title="A:流向"></a>A:流向</h4><pre><code>        输入流    读取数据        输出流    写出数据</code></pre><h4 id="B-数据类型"><a href="#B-数据类型" class="headerlink" title="B:数据类型"></a>B:数据类型</h4><pre><code>        字节流                    字节输入流                字节输出流        字符流                字符输入流                字符输出流</code></pre><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><pre><code>        a:如果我们没有明确说明按照什么分，默认按照数据类型分。        b:除非文件用windows自带的记事本打开我们能够读懂，才采用字符流，否则建议使用字节流。</code></pre><h3 id="3-FileOutputStream写出数据"><a href="#3-FileOutputStream写出数据" class="headerlink" title="(3)FileOutputStream写出数据"></a>(3)FileOutputStream写出数据</h3><h4 id="A-操作步骤"><a href="#A-操作步骤" class="headerlink" title="A:操作步骤"></a>A:操作步骤</h4><pre><code>        a:创建字节输出流对象        b:调用write()方法        c:释放资源</code></pre><h4 id="B-代码体现："><a href="#B-代码体现：" class="headerlink" title="B:代码体现："></a>B:代码体现：</h4><pre><code>        FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);        fos.write(&quot;hello&quot;.getBytes());        fos.close();</code></pre><h4 id="C-要注意的问题"><a href="#C-要注意的问题" class="headerlink" title="C:要注意的问题?"></a>C:要注意的问题?</h4><pre><code>        a:创建字节输出流对象做了几件事情?        b:为什么要close()?        c:如何实现数据的换行?        d:如何实现数据的追加写入?</code></pre><h3 id="4-FileInputStream读取数据"><a href="#4-FileInputStream读取数据" class="headerlink" title="(4)FileInputStream读取数据"></a>(4)FileInputStream读取数据</h3><h4 id="A-操作步骤-1"><a href="#A-操作步骤-1" class="headerlink" title="A:操作步骤"></a>A:操作步骤</h4><pre><code>        a:创建字节输入流对象        b:调用read()方法        c:释放资源</code></pre><h4 id="B-代码体现：-1"><a href="#B-代码体现：-1" class="headerlink" title="B:代码体现："></a>B:代码体现：</h4><pre><code>        FileInputStream fis = new FileInputStream(&quot;fos.txt&quot;);        //方式1        int by = 0;        while((by=fis.read())!=-1) {            System.out.print((char)by);        }        //方式2        byte[] bys = new byte[1024];        int len = 0;        while((len=fis.read(bys))!=-1) {            System.out.print(new String(bys,0,len));        }        fis.close();</code></pre><h3 id="5-案例：2种实现"><a href="#5-案例：2种实现" class="headerlink" title="(5)案例：2种实现"></a>(5)案例：2种实现</h3><h4 id="A-复制文本文件"><a href="#A-复制文本文件" class="headerlink" title="A:复制文本文件"></a>A:复制文本文件</h4><h4 id="B-复制图片"><a href="#B-复制图片" class="headerlink" title="B:复制图片"></a>B:复制图片</h4><h4 id="C-复制视频"><a href="#C-复制视频" class="headerlink" title="C:复制视频"></a>C:复制视频</h4><h3 id="6-字节缓冲区流"><a href="#6-字节缓冲区流" class="headerlink" title="(6)字节缓冲区流"></a>(6)字节缓冲区流</h3><h4 id="A-BufferedOutputStream"><a href="#A-BufferedOutputStream" class="headerlink" title="A:BufferedOutputStream"></a>A:BufferedOutputStream</h4><h4 id="B-BufferedInputStream"><a href="#B-BufferedInputStream" class="headerlink" title="B:BufferedInputStream"></a>B:BufferedInputStream</h4><h3 id="7-案例：4种实现"><a href="#7-案例：4种实现" class="headerlink" title="(7)案例：4种实现"></a>(7)案例：4种实现</h3><h4 id="A-复制文本文件-1"><a href="#A-复制文本文件-1" class="headerlink" title="A:复制文本文件"></a>A:复制文本文件</h4><h4 id="B-复制图片-1"><a href="#B-复制图片-1" class="headerlink" title="B:复制图片"></a>B:复制图片</h4><h4 id="C-复制视频-1"><a href="#C-复制视频-1" class="headerlink" title="C:复制视频"></a>C:复制视频</h4><h2 id="3-自学字符流"><a href="#3-自学字符流" class="headerlink" title="3:自学字符流"></a>3:自学字符流</h2><h3 id="IO流分类"><a href="#IO流分类" class="headerlink" title="IO流分类"></a>IO流分类</h3><h4 id="字节流："><a href="#字节流：" class="headerlink" title="字节流："></a>字节流：</h4><pre><code>        InputStream            FileInputStream            BufferedInputStream        OutputStream            FileOutputStream            BufferedOutputStream</code></pre><h4 id="字符流："><a href="#字符流：" class="headerlink" title="字符流："></a>字符流：</h4><pre><code>        Reader            FileReader            BufferedReader        Writer            FileWriter            BufferedWriter</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day19</title>
      <link href="/2020/062048156.html"/>
      <url>/2020/062048156.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-异常-理解"><a href="#1-异常-理解" class="headerlink" title="1:异常(理解)"></a>1:异常(理解)</h2><h3 id="1-程序出现的不正常的情况。"><a href="#1-程序出现的不正常的情况。" class="headerlink" title="(1)程序出现的不正常的情况。"></a>(1)程序出现的不正常的情况。</h3><h3 id="2-异常的体系"><a href="#2-异常的体系" class="headerlink" title="(2)异常的体系"></a>(2)异常的体系</h3><pre><code>    Throwable        |--Error    严重问题，我们不处理。        |--Exception            |--RuntimeException    运行期异常，我们需要修正代码            |--非RuntimeException 编译期异常，必须处理的，否则程序编译不通过</code></pre><h3 id="3-异常的处理："><a href="#3-异常的处理：" class="headerlink" title="(3)异常的处理："></a>(3)异常的处理：</h3><h4 id="A-JVM的默认处理"><a href="#A-JVM的默认处理" class="headerlink" title="A:JVM的默认处理"></a>A:JVM的默认处理</h4><pre><code>        把异常的名称,原因,位置等信息输出在控制台，但是呢程序不能继续执行了。</code></pre><h4 id="B-自己处理"><a href="#B-自己处理" class="headerlink" title="B:自己处理"></a>B:自己处理</h4><pre><code>        a:try...catch...finally            自己编写处理代码,后面的程序可以继续执行        b:throws            把自己处理不了的，在方法上声明，告诉调用者，这里有问题</code></pre><h3 id="4-面试题"><a href="#4-面试题" class="headerlink" title="(4)面试题"></a>(4)面试题</h3><h4 id="A-编译期异常和运行期异常的区别"><a href="#A-编译期异常和运行期异常的区别" class="headerlink" title="A:编译期异常和运行期异常的区别?"></a>A:编译期异常和运行期异常的区别?</h4><pre><code>        编译期异常 必须要处理的，否则编译不通过        运行期异常 可以不处理，也可以处理</code></pre><h4 id="B-throw和throws是的区别"><a href="#B-throw和throws是的区别" class="headerlink" title="B:throw和throws是的区别"></a>B:throw和throws是的区别</h4><pre><code>        throw:            在方法体中,后面跟的是异常对象名,并且只能是一个            throw抛出的是一个异常对象，说明这里肯定有一个异常产生了        throws:            在方法声明上,后面跟的是异常的类名,可以是多个            throws是声明方法有异常，是一种可能性，这个异常并不一定会产生</code></pre><h3 id="5-finally关键字及其面试题"><a href="#5-finally关键字及其面试题" class="headerlink" title="(5)finally关键字及其面试题"></a>(5)finally关键字及其面试题</h3><h4 id="A-finally用于释放资源，它的代码永远会执行。特殊情况：在执行到finally之前jvm退出了"><a href="#A-finally用于释放资源，它的代码永远会执行。特殊情况：在执行到finally之前jvm退出了" class="headerlink" title="A:finally用于释放资源，它的代码永远会执行。特殊情况：在执行到finally之前jvm退出了"></a>A:finally用于释放资源，它的代码永远会执行。特殊情况：在执行到finally之前jvm退出了</h4><h4 id="B-面试题"><a href="#B-面试题" class="headerlink" title="B:面试题"></a>B:面试题</h4><pre><code>        a:final,finally,finalize的区别?        b:如果在catch里面有return,请问finally还执行吗?如果执行,在return前还是后            会，前。            实际上在中间。这个上课我们讲过</code></pre><h4 id="C-异常处理的变形"><a href="#C-异常处理的变形" class="headerlink" title="C:异常处理的变形"></a>C:异常处理的变形</h4><pre><code>        try...catch...finally        try...catch...        try...catch...catch...        try...catch...catch...fianlly        try...finally</code></pre><h3 id="6-自定义异常"><a href="#6-自定义异常" class="headerlink" title="(6)自定义异常"></a>(6)自定义异常</h3><pre><code>    继承自Exception或者RuntimeException,只需要提供无参构造和一个带参构造即可</code></pre><h3 id="7-异常的注意实现"><a href="#7-异常的注意实现" class="headerlink" title="(7)异常的注意实现"></a>(7)异常的注意实现</h3><pre><code>    A:父的方法有异常抛出,子的重写方法在抛出异常的时候必须要小于等于父的异常     B:父的方法没有异常抛出,子的重写方法不能有异常抛出    C:父的方法抛出多个异常,子的重写方法必须比父少或者小</code></pre><h2 id="2-File-掌握"><a href="#2-File-掌握" class="headerlink" title="2:File(掌握)"></a>2:File(掌握)</h2><h3 id="1-IO流操作中大部分都是对文件的操作，所以Java就提供了File类供我们来操作文件"><a href="#1-IO流操作中大部分都是对文件的操作，所以Java就提供了File类供我们来操作文件" class="headerlink" title="(1)IO流操作中大部分都是对文件的操作，所以Java就提供了File类供我们来操作文件"></a>(1)IO流操作中大部分都是对文件的操作，所以Java就提供了File类供我们来操作文件</h3><h3 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="(2)构造方法"></a>(2)构造方法</h3><pre><code>    A:File file = new File(&quot;e:\\demo\\a.txt&quot;);    B:File file = new File(&quot;e:\\demo&quot;,&quot;a.txt&quot;);    C:File file = new File(&quot;e:\\demo&quot;);      File file2 = new File(file,&quot;a.txt&quot;);</code></pre><h3 id="3-File类的功能-自己补齐"><a href="#3-File类的功能-自己补齐" class="headerlink" title="(3)File类的功能(自己补齐)"></a>(3)File类的功能(自己补齐)</h3><h4 id="A-创建功能"><a href="#A-创建功能" class="headerlink" title="A:创建功能"></a>A:创建功能</h4><pre><code>    public boolean createNewFile():创建文件 如果存在这样的文件，就不创建了    public boolean mkdir():创建文件夹 如果存在这样的文件夹，就不创建了    public boolean mkdirs():创建文件夹,如果父文件夹不存在，会帮你创建出来</code></pre><ul><li><p>骑白马的不一定是王子，可能是班长。  </p></li><li><p>注意：你到底要创建文件还是文件夹，你最清楚，方法不要调错了。</p><h4 id="B-删除功能"><a href="#B-删除功能" class="headerlink" title="B:删除功能"></a>B:删除功能</h4><pre><code> public boolean delete()</code></pre></li><li></li><li><p>注意：</p></li><li><p>A:如果你创建文件或者文件夹忘了写盘符路径，那么，默认在项目路径下。</p></li><li><p>B:Java中的删除不走回收站。</p></li><li><p>C:要删除一个文件夹，请注意该文件夹内不能包含文件或者文件夹</p></li></ul><h4 id="C-重命名功能"><a href="#C-重命名功能" class="headerlink" title="C:重命名功能"></a>C:重命名功能</h4><pre><code>    public boolean renameTo(File dest)</code></pre><ul><li>如果路径名相同，就是改名。</li><li>如果路径名不同，就是改名并剪切。</li><li></li><li>路径以盘符开始：绝对路径    c:\a.txt</li><li>路径不以盘符开始：相对路径    a.txt</li></ul><h4 id="D-判断功能"><a href="#D-判断功能" class="headerlink" title="D:判断功能"></a>D:判断功能</h4><pre><code>public boolean isDirectory():判断是否是目录public boolean isFile():判断是否是文件public boolean exists():判断是否存在public boolean canRead():判断是否可读public boolean canWrite():判断是否可写public boolean isHidden():判断是否隐藏</code></pre><h4 id="E-获取功能"><a href="#E-获取功能" class="headerlink" title="E:获取功能"></a>E:获取功能</h4><pre><code>public String[] list():获取指定目录下的所有文件或者文件夹的名称数组public File[] listFiles():获取指定目录下的所有文件或者文件夹的File数组</code></pre><h4 id="F-高级获取功能"><a href="#F-高级获取功能" class="headerlink" title="F:高级获取功能"></a>F:高级获取功能</h4><h4 id="G-过滤器功能"><a href="#G-过滤器功能" class="headerlink" title="G:过滤器功能"></a>G:过滤器功能</h4><h3 id="4-案例："><a href="#4-案例：" class="headerlink" title="(4)案例："></a>(4)案例：</h3><h4 id="A-输出指定目录下指定后缀名的文件名称"><a href="#A-输出指定目录下指定后缀名的文件名称" class="headerlink" title="A:输出指定目录下指定后缀名的文件名称"></a>A:输出指定目录下指定后缀名的文件名称</h4><pre><code>        a:先获取所有的，在遍历的时候判断，再输出        b:先判断，再获取，最后直接遍历输出即可</code></pre><h4 id="B-批量修改文件名称"><a href="#B-批量修改文件名称" class="headerlink" title="B:批量修改文件名称"></a>B:批量修改文件名称</h4>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day18</title>
      <link href="/2020/061931965.html"/>
      <url>/2020/061931965.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Map-掌握"><a href="#1-Map-掌握" class="headerlink" title="1:Map(掌握)"></a>1:Map(掌握)</h2><h3 id="1-将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。"><a href="#1-将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。" class="headerlink" title="(1)将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。"></a>(1)将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。</h3><h3 id="2-Map和Collection的区别"><a href="#2-Map和Collection的区别" class="headerlink" title="(2)Map和Collection的区别?"></a>(2)Map和Collection的区别?</h3><pre><code>    A:Map 存储的是键值对形式的元素，键唯一，值可以重复。夫妻对    B:Collection 存储的是单独出现的元素，子接口Set元素唯一，子接口List元素可重复。光棍</code></pre><h3 id="3-Map接口功能概述-自己补齐"><a href="#3-Map接口功能概述-自己补齐" class="headerlink" title="(3)Map接口功能概述(自己补齐)"></a>(3)Map接口功能概述(自己补齐)</h3><h4 id="A-添加功能"><a href="#A-添加功能" class="headerlink" title="A:添加功能"></a>A:添加功能</h4><pre><code>    V put(K key,V value):添加元素。这个其实还有另一个功能?先不告诉你，等会讲         如果键是第一次存储，就直接存储元素，返回null         如果键不是第一次存在，就用值把以前的值替换掉，返回以前的值</code></pre><h4 id="B-删除功能"><a href="#B-删除功能" class="headerlink" title="B:删除功能"></a>B:删除功能</h4><pre><code>     void clear():移除所有的键值对元素     V remove(Object key)：根据键删除键值对元素，并把值返回</code></pre><h4 id="C-判断功能"><a href="#C-判断功能" class="headerlink" title="C:判断功能"></a>C:判断功能</h4><pre><code>     boolean containsKey(Object key)：判断集合是否包含指定的键      boolean containsValue(Object value):判断集合是否包含指定的值      boolean isEmpty()：判断集合是否为空</code></pre><h4 id="D-获取功能"><a href="#D-获取功能" class="headerlink" title="D:获取功能"></a>D:获取功能</h4><pre><code>     Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet():???     V get(Object key):根据键获取值     Set&lt;K&gt; keySet():获取集合中所有键的集合     Collection&lt;V&gt; values():获取集合中所有值的集合</code></pre><h4 id="E-长度功能"><a href="#E-长度功能" class="headerlink" title="E:长度功能"></a>E:长度功能</h4><pre><code>    int size()：返回集合中的键值对的对数</code></pre><h3 id="4-Map集合的遍历"><a href="#4-Map集合的遍历" class="headerlink" title="(4)Map集合的遍历"></a>(4)Map集合的遍历</h3><h4 id="A-键找值"><a href="#A-键找值" class="headerlink" title="A:键找值"></a>A:键找值</h4><pre><code>        a:获取所有键的集合        b:遍历键的集合,得到每一个键        c:根据键到集合中去找值</code></pre><h4 id="B-键值对对象找键和值"><a href="#B-键值对对象找键和值" class="headerlink" title="B:键值对对象找键和值"></a>B:键值对对象找键和值</h4><pre><code>        a:获取所有的键值对对象的集合        b:遍历键值对对象的集合，获取每一个键值对对象        c:根据键值对对象去获取键和值    代码体现：        Map&lt;String,String&gt; hm = new HashMap&lt;String,String&gt;();        hm.put(&quot;it002&quot;,&quot;hello&quot;);        hm.put(&quot;it003&quot;,&quot;world&quot;);        hm.put(&quot;it001&quot;,&quot;java&quot;);        //方式1 键找值        Set&lt;String&gt; set = hm.keySet();        for(String key : set) {            String value = hm.get(key);            System.out.println(key+&quot;---&quot;+value);        }        //方式2 键值对对象找键和值        Set&lt;Map.Entry&lt;String,String&gt;&gt; set2 = hm.entrySet();        for(Map.Entry&lt;String,String&gt; me : set2) {            String key = me.getKey();            String value = me.getValue();            System.out.println(key+&quot;---&quot;+value);        }</code></pre><h3 id="5-HashMap集合的练习"><a href="#5-HashMap集合的练习" class="headerlink" title="(5)HashMap集合的练习"></a>(5)HashMap集合的练习</h3><pre><code>    A:HashMap&lt;String,String&gt;    B:HashMap&lt;Integer,String&gt;    C:HashMap&lt;String,Student&gt;    D:HashMap&lt;Student,String&gt;</code></pre><h3 id="6-TreeMap集合的练习"><a href="#6-TreeMap集合的练习" class="headerlink" title="(6)TreeMap集合的练习"></a>(6)TreeMap集合的练习</h3><pre><code>    A:TreeMap&lt;String,String&gt;    B:TreeMap&lt;Student,String&gt;</code></pre><h3 id="7-案例"><a href="#7-案例" class="headerlink" title="(7)案例"></a>(7)案例</h3><pre><code>    A:统计一个字符串中每个字符出现的次数    B:集合的嵌套遍历        a:HashMap嵌套HashMap        b:HashMap嵌套ArrayList        c:ArrayList嵌套HashMap        d:多层嵌套</code></pre><h2 id="2-Collections-理解"><a href="#2-Collections-理解" class="headerlink" title="2:Collections(理解)"></a>2:Collections(理解)</h2><h3 id="1-是针对集合进行操作的工具类"><a href="#1-是针对集合进行操作的工具类" class="headerlink" title="(1)是针对集合进行操作的工具类"></a>(1)是针对集合进行操作的工具类</h3><h3 id="2-面试题：Collection和Collections的区别"><a href="#2-面试题：Collection和Collections的区别" class="headerlink" title="(2)面试题：Collection和Collections的区别"></a>(2)面试题：Collection和Collections的区别</h3><pre><code>    A:Collection 是单列集合的顶层接口，有两个子接口List和Set    B:Collections 是针对集合进行操作的工具类，可以对集合进行排序和查找等</code></pre><h3 id="3-常见的几个小方法："><a href="#3-常见的几个小方法：" class="headerlink" title="(3)常见的几个小方法："></a>(3)常见的几个小方法：</h3><pre><code>    A:public static &lt;T&gt; void sort(List&lt;T&gt; list)    B:public static &lt;T&gt; int binarySearch(List&lt;?&gt; list,T key)    C:public static &lt;T&gt; T max(Collection&lt;?&gt; coll)    D:public static void reverse(List&lt;?&gt; list)    E:public static void shuffle(List&lt;?&gt; list)</code></pre><h3 id="4-案例"><a href="#4-案例" class="headerlink" title="(4)案例"></a>(4)案例</h3><pre><code>    A:ArrayList集合存储自定义对象的排序    B:模拟斗地主洗牌和发牌    C:模拟斗地主洗牌和发牌并对牌进行排序</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day17</title>
      <link href="/2020/061830877.html"/>
      <url>/2020/061830877.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-登录注册案例-理解"><a href="#1-登录注册案例-理解" class="headerlink" title="1:登录注册案例(理解)"></a>1:登录注册案例(理解)</h2><h2 id="2-Set集合-理解"><a href="#2-Set集合-理解" class="headerlink" title="2:Set集合(理解)"></a>2:Set集合(理解)</h2><h3 id="1-Set集合的特点"><a href="#1-Set集合的特点" class="headerlink" title="(1)Set集合的特点"></a>(1)Set集合的特点</h3><pre><code>    无序,唯一</code></pre><h3 id="2-HashSet集合-掌握"><a href="#2-HashSet集合-掌握" class="headerlink" title="(2)HashSet集合(掌握)"></a>(2)HashSet集合(掌握)</h3><h4 id="A-底层数据结构是哈希表-是一个元素为链表的数组"><a href="#A-底层数据结构是哈希表-是一个元素为链表的数组" class="headerlink" title="A:底层数据结构是哈希表(是一个元素为链表的数组)"></a>A:底层数据结构是哈希表(是一个元素为链表的数组)</h4><h4 id="B-哈希表底层依赖两个方法：hashCode-和equals"><a href="#B-哈希表底层依赖两个方法：hashCode-和equals" class="headerlink" title="B:哈希表底层依赖两个方法：hashCode()和equals()"></a>B:哈希表底层依赖两个方法：hashCode()和equals()</h4><pre><code>      执行顺序：        首先比较哈希值是否相同            相同：继续执行equals()方法                返回true：元素重复了，不添加                返回false：直接把元素添加到集合            不同：就直接把元素添加到集合</code></pre><h4 id="C-如何保证元素唯一性的呢"><a href="#C-如何保证元素唯一性的呢" class="headerlink" title="C:如何保证元素唯一性的呢?"></a>C:如何保证元素唯一性的呢?</h4><pre><code>        由hashCode()和equals()保证的</code></pre><h4 id="D-开发的时候，代码非常的简单，自动生成即可。"><a href="#D-开发的时候，代码非常的简单，自动生成即可。" class="headerlink" title="D:开发的时候，代码非常的简单，自动生成即可。"></a>D:开发的时候，代码非常的简单，自动生成即可。</h4><h4 id="E-HashSet存储字符串并遍历"><a href="#E-HashSet存储字符串并遍历" class="headerlink" title="E:HashSet存储字符串并遍历"></a>E:HashSet存储字符串并遍历</h4><h4 id="F-HashSet存储自定义对象并遍历-对象的成员变量值相同即为同一个元素"><a href="#F-HashSet存储自定义对象并遍历-对象的成员变量值相同即为同一个元素" class="headerlink" title="F:HashSet存储自定义对象并遍历(对象的成员变量值相同即为同一个元素)"></a>F:HashSet存储自定义对象并遍历(对象的成员变量值相同即为同一个元素)</h4><h3 id="3-TreeSet集合"><a href="#3-TreeSet集合" class="headerlink" title="(3)TreeSet集合"></a>(3)TreeSet集合</h3><h4 id="A-底层数据结构是红黑树-是一个自平衡的二叉树"><a href="#A-底层数据结构是红黑树-是一个自平衡的二叉树" class="headerlink" title="A:底层数据结构是红黑树(是一个自平衡的二叉树)"></a>A:底层数据结构是红黑树(是一个自平衡的二叉树)</h4><h4 id="B-保证元素的排序方式"><a href="#B-保证元素的排序方式" class="headerlink" title="B:保证元素的排序方式"></a>B:保证元素的排序方式</h4><pre><code>        a:自然排序(元素具备比较性)            让元素所属的类实现Comparable接口        b:比较器排序(集合具备比较性)            让集合构造方法接收Comparator的实现类对象</code></pre><h4 id="C-把我们讲过的代码看一遍即可"><a href="#C-把我们讲过的代码看一遍即可" class="headerlink" title="C:把我们讲过的代码看一遍即可"></a>C:把我们讲过的代码看一遍即可</h4><h3 id="4-案例："><a href="#4-案例：" class="headerlink" title="(4)案例："></a>(4)案例：</h3><h4 id="A-获取无重复的随机数"><a href="#A-获取无重复的随机数" class="headerlink" title="A:获取无重复的随机数"></a>A:获取无重复的随机数</h4><h4 id="B-键盘录入学生按照总分从高到底输出"><a href="#B-键盘录入学生按照总分从高到底输出" class="headerlink" title="B:键盘录入学生按照总分从高到底输出"></a>B:键盘录入学生按照总分从高到底输出</h4><h2 id="3-Collection集合总结-掌握"><a href="#3-Collection集合总结-掌握" class="headerlink" title="3:Collection集合总结(掌握)"></a>3:Collection集合总结(掌握)</h2><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><h4 id="–List-有序-可重复"><a href="#–List-有序-可重复" class="headerlink" title="|–List    有序,可重复"></a>|–List    有序,可重复</h4><pre><code>        |--ArrayList            底层数据结构是数组，查询快，增删慢。            线程不安全，效率高            |--Vector            底层数据结构是数组，查询快，增删慢。            线程安全，效率低        |--LinkedList            底层数据结构是链表，查询慢，增删快。            线程不安全，效率高</code></pre><h4 id="–Set-无序-唯一"><a href="#–Set-无序-唯一" class="headerlink" title="|–Set    无序,唯一"></a>|–Set    无序,唯一</h4><pre><code>        |--HashSet            底层数据结构是哈希表。            如何保证元素唯一性的呢?                依赖两个方法：hashCode()和equals()                开发中自动生成这两个方法即可            |--LinkedHashSet                底层数据结构是链表和哈希表                由链表保证元素有序                由哈希表保证元素唯一        |--TreeSet            底层数据结构是红黑树。            如何保证元素排序的呢?                自然排序                比较器排序            如何保证元素唯一性的呢?                根据比较的返回值是否是0来决定</code></pre><h2 id="4-针对Collection集合我们到底使用谁呢-掌握"><a href="#4-针对Collection集合我们到底使用谁呢-掌握" class="headerlink" title="4:针对Collection集合我们到底使用谁呢?(掌握)"></a>4:针对Collection集合我们到底使用谁呢?(掌握)</h2><pre><code>唯一吗?    是：Set        排序吗?            是：TreeSet            否：HashSet    如果你知道是Set，但是不知道是哪个Set，就用HashSet。    否：List        要安全吗?            是：Vector            否：ArrayList或者LinkedList                查询多：ArrayList                增删多：LinkedList    如果你知道是List，但是不知道是哪个List，就用ArrayList。如果你知道是Collection集合，但是不知道使用谁，就用ArrayList。如果你知道用集合，就用ArrayList。</code></pre><h2 id="5-在集合中常见的数据结构-掌握"><a href="#5-在集合中常见的数据结构-掌握" class="headerlink" title="5:在集合中常见的数据结构(掌握)"></a>5:在集合中常见的数据结构(掌握)</h2><pre><code>ArrayXxx:底层数据结构是数组，查询快，增删慢LinkedXxx:底层数据结构是链表，查询慢，增删快HashXxx:底层数据结构是哈希表。依赖两个方法：hashCode()和equals()TreeXxx:底层数据结构是二叉树。两种方式排序：自然排序和比较器排序</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day16</title>
      <link href="/2020/061747196.html"/>
      <url>/2020/061747196.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-List的子类-掌握"><a href="#1-List的子类-掌握" class="headerlink" title="1:List的子类(掌握)"></a>1:List的子类(掌握)</h2><h3 id="1-List的子类特点"><a href="#1-List的子类特点" class="headerlink" title="(1)List的子类特点"></a>(1)List的子类特点</h3><pre><code>    ArrayList:        底层数据结构是数组，查询快，增删慢        线程不安全，效率高    Vector:        底层数据结构是数组，查询快，增删慢        线程安全，效率低    LinkedList:        底层数据结构是链表，查询慢，增删快        线程不安全，效率高</code></pre><h3 id="2-ArrayList"><a href="#2-ArrayList" class="headerlink" title="(2)ArrayList"></a>(2)ArrayList</h3><pre><code>    A:没有特有功能需要学习    B:案例        a:ArrayList存储字符串并遍历        b:ArrayList存储自定义对象并遍历</code></pre><h3 id="3-Vector"><a href="#3-Vector" class="headerlink" title="(3)Vector"></a>(3)Vector</h3><h4 id="A-有特有功能"><a href="#A-有特有功能" class="headerlink" title="A:有特有功能"></a>A:有特有功能</h4><pre><code>        a:添加            public void addElement(E obj)        --    add()        b:获取            public E elementAt(int index)        --    get()            public Enumeration&lt;E&gt; elements()    --  iterator()</code></pre><h4 id="B-案例"><a href="#B-案例" class="headerlink" title="B:案例"></a>B:案例</h4><pre><code>        a:Vector存储字符串并遍历        b:Vector存储自定义对象并遍历</code></pre><h3 id="4-LinkedList"><a href="#4-LinkedList" class="headerlink" title="(4)LinkedList"></a>(4)LinkedList</h3><h4 id="A-有特有功能-1"><a href="#A-有特有功能-1" class="headerlink" title="A:有特有功能"></a>A:有特有功能</h4><pre><code>        a:添加            addFirst()            addLast()        b:删除            removeFirst()            removeLast()        c:获取            getFirst()            getLast()</code></pre><h4 id="B-案例-1"><a href="#B-案例-1" class="headerlink" title="B:案例"></a>B:案例</h4><pre><code>        a:LinkedList存储字符串并遍历        b:LinkedList存储自定义对象并遍历</code></pre><h3 id="5-案例："><a href="#5-案例：" class="headerlink" title="(5)案例："></a>(5)案例：</h3><h4 id="A-去除集合中的多个字符串的重复元素"><a href="#A-去除集合中的多个字符串的重复元素" class="headerlink" title="A:去除集合中的多个字符串的重复元素"></a>A:去除集合中的多个字符串的重复元素</h4><pre><code>        如果字符串的内容相同，即为重复元素</code></pre><h4 id="B-去除集合中的多个自定义对象的重复元素"><a href="#B-去除集合中的多个自定义对象的重复元素" class="headerlink" title="B:去除集合中的多个自定义对象的重复元素"></a>B:去除集合中的多个自定义对象的重复元素</h4><pre><code>        如果自定义对象的成员变量值都相同，即为重复元素</code></pre><h4 id="C-用LinkedList模拟一个栈数据结构的集合类，并测试。"><a href="#C-用LinkedList模拟一个栈数据结构的集合类，并测试。" class="headerlink" title="C:用LinkedList模拟一个栈数据结构的集合类，并测试。"></a>C:用LinkedList模拟一个栈数据结构的集合类，并测试。</h4><pre><code>        你要定义一个集合类，只不过内部可以使用LinkedList来实现。</code></pre><h2 id="2-泛型-掌握"><a href="#2-泛型-掌握" class="headerlink" title="2:泛型(掌握)"></a>2:泛型(掌握)</h2><h3 id="1-泛型概述"><a href="#1-泛型概述" class="headerlink" title="(1)泛型概述"></a>(1)泛型概述</h3><pre><code>    是一种把明确类型的工作推迟到创建对象或者调用方法的时候才去明确的特殊的类型。</code></pre><h3 id="2-格式："><a href="#2-格式：" class="headerlink" title="(2)格式："></a>(2)格式：</h3><pre><code>    &lt;数据类型&gt;    注意：该数据类型只能是引用类型。</code></pre><h3 id="3-好处："><a href="#3-好处：" class="headerlink" title="(3)好处："></a>(3)好处：</h3><pre><code>    A:把运行时期的问题提前到了编译期间    B:避免了强制类型转换    C:优化了程序设计，解决了黄色警告线问题，让程序更安全</code></pre><h3 id="4-泛型的前世今生"><a href="#4-泛型的前世今生" class="headerlink" title="(4)泛型的前世今生"></a>(4)泛型的前世今生</h3><pre><code>    A:泛型的由来        Object类型作为任意类型的时候，在向下转型的时候，会隐含一个转型问题    B:泛型类    C:泛型方法    D:泛型接口    E:泛型高级通配符        ?        ? extends E        ? super E</code></pre><h3 id="5-我们在哪里使用呢"><a href="#5-我们在哪里使用呢" class="headerlink" title="(5)我们在哪里使用呢?"></a>(5)我们在哪里使用呢?</h3><pre><code>    一般是在集合中使用。</code></pre><h2 id="3-增强for循环-掌握"><a href="#3-增强for循环-掌握" class="headerlink" title="3:增强for循环(掌握)"></a>3:增强for循环(掌握)</h2><h3 id="1-是for循环的一种"><a href="#1-是for循环的一种" class="headerlink" title="(1)是for循环的一种"></a>(1)是for循环的一种</h3><h3 id="2-格式：-1"><a href="#2-格式：-1" class="headerlink" title="(2)格式："></a>(2)格式：</h3><pre><code>    for(元素的数据类型 变量名 : 数组或者Collection集合的对象) {        使用该变量即可，该变量其实就是数组或者集合中的元素。    }</code></pre><h3 id="3-好处：-1"><a href="#3-好处：-1" class="headerlink" title="(3)好处："></a>(3)好处：</h3><pre><code>    简化了数组和集合的遍历</code></pre><h3 id="4-弊端"><a href="#4-弊端" class="headerlink" title="(4)弊端"></a>(4)弊端</h3><pre><code>    增强for循环的目标不能为null。建议在使用前，先判断是否为null。</code></pre><h2 id="4-静态导入-了解"><a href="#4-静态导入-了解" class="headerlink" title="4:静态导入(了解)"></a>4:静态导入(了解)</h2><h3 id="1-可以导入到方法级别的导入"><a href="#1-可以导入到方法级别的导入" class="headerlink" title="(1)可以导入到方法级别的导入"></a>(1)可以导入到方法级别的导入</h3><h3 id="2-格式：-2"><a href="#2-格式：-2" class="headerlink" title="(2)格式："></a>(2)格式：</h3><pre><code>    import static 包名....类名.方法名;</code></pre><h3 id="3-注意事项："><a href="#3-注意事项：" class="headerlink" title="(3)注意事项："></a>(3)注意事项：</h3><pre><code>    A:方法必须是静态的    B:如果多个类下有同名的方法，就不好区分了，还得加上前缀。        所以一般我们并不使用静态导入，但是一定要能够看懂。</code></pre><h2 id="5-可变参数-掌握"><a href="#5-可变参数-掌握" class="headerlink" title="5:可变参数(掌握)"></a>5:可变参数(掌握)</h2><h3 id="1-如果我们在写方法的时候，参数个数不明确，就应该定义可变参数。"><a href="#1-如果我们在写方法的时候，参数个数不明确，就应该定义可变参数。" class="headerlink" title="(1)如果我们在写方法的时候，参数个数不明确，就应该定义可变参数。"></a>(1)如果我们在写方法的时候，参数个数不明确，就应该定义可变参数。</h3><h3 id="2-格式：-3"><a href="#2-格式：-3" class="headerlink" title="(2)格式："></a>(2)格式：</h3><pre><code>    修饰符 返回值类型 方法名(数据类型... 变量) {}    注意：        A:该变量其实是一个数组名        B:如果一个方法有多个参数，并且有可变参数，可变参数必须在最后</code></pre><h3 id="3-Arrays工具类的一个方法"><a href="#3-Arrays工具类的一个方法" class="headerlink" title="(3)Arrays工具类的一个方法"></a>(3)Arrays工具类的一个方法</h3><pre><code>    asList()把数组转成集合。    注意：这个集合的长度不能改变。</code></pre><h2 id="6-练习-掌握"><a href="#6-练习-掌握" class="headerlink" title="6:练习(掌握)"></a>6:练习(掌握)</h2><h3 id="A-集合的嵌套遍历"><a href="#A-集合的嵌套遍历" class="headerlink" title="A:集合的嵌套遍历"></a>A:集合的嵌套遍历</h3><h3 id="B-产生10个1-20之间的随机数，要求随机数不能重复"><a href="#B-产生10个1-20之间的随机数，要求随机数不能重复" class="headerlink" title="B:产生10个1-20之间的随机数，要求随机数不能重复"></a>B:产生10个1-20之间的随机数，要求随机数不能重复</h3><h3 id="C-键盘录入多个数据，以0结束，并在控制台输出最大值"><a href="#C-键盘录入多个数据，以0结束，并在控制台输出最大值" class="headerlink" title="C:键盘录入多个数据，以0结束，并在控制台输出最大值"></a>C:键盘录入多个数据，以0结束，并在控制台输出最大值</h3><h2 id="7-要掌握的代码"><a href="#7-要掌握的代码" class="headerlink" title="7:要掌握的代码"></a>7:要掌握的代码</h2><pre><code>集合存储元素，加入泛型，并可以使用增强for遍历。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day15</title>
      <link href="/2020/061647388.html"/>
      <url>/2020/061647388.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-对象数组-掌握"><a href="#1-对象数组-掌握" class="headerlink" title="1:对象数组(掌握)"></a>1:对象数组(掌握)</h2><h3 id="1-数组既可以存储基本数据类型，也可以存储引用类型。它存储引用类型的时候的数组就叫对象数组。"><a href="#1-数组既可以存储基本数据类型，也可以存储引用类型。它存储引用类型的时候的数组就叫对象数组。" class="headerlink" title="(1)数组既可以存储基本数据类型，也可以存储引用类型。它存储引用类型的时候的数组就叫对象数组。"></a>(1)数组既可以存储基本数据类型，也可以存储引用类型。它存储引用类型的时候的数组就叫对象数组。</h3><h3 id="2-案例："><a href="#2-案例：" class="headerlink" title="(2)案例："></a>(2)案例：</h3><pre><code>    用数组存储5个学生对象，并遍历数组。</code></pre><h2 id="2-集合-Collection-掌握"><a href="#2-集合-Collection-掌握" class="headerlink" title="2:集合(Collection)(掌握)"></a>2:集合(Collection)(掌握)</h2><h3 id="1-集合的由来"><a href="#1-集合的由来" class="headerlink" title="(1)集合的由来?"></a>(1)集合的由来?</h3><pre><code>    我们学习的是Java -- 面向对象 -- 操作很多对象 -- 存储 -- 容器(数组和StringBuffer) -- 数组    而数组的长度固定，所以不适合做变化的需求，Java就提供了集合供我们使用。</code></pre><h3 id="2-集合和数组的区别"><a href="#2-集合和数组的区别" class="headerlink" title="(2)集合和数组的区别?"></a>(2)集合和数组的区别?</h3><h4 id="A-长度区别"><a href="#A-长度区别" class="headerlink" title="A:长度区别"></a>A:长度区别</h4><pre><code>        数组固定        集合可变</code></pre><h4 id="B-内容区别"><a href="#B-内容区别" class="headerlink" title="B:内容区别"></a>B:内容区别</h4><pre><code>        数组可以是基本类型，也可以是引用类型        集合只能是引用类型</code></pre><h4 id="C-元素内容"><a href="#C-元素内容" class="headerlink" title="C:元素内容"></a>C:元素内容</h4><pre><code>        数组只能存储同一种类型        集合可以存储不同类型(其实集合一般存储的也是同一种类型)</code></pre><h3 id="3-集合的继承体系结构"><a href="#3-集合的继承体系结构" class="headerlink" title="(3)集合的继承体系结构?"></a>(3)集合的继承体系结构?</h3><pre><code>    由于需求不同，Java就提供了不同的集合类。这多个集合类的数据结构不同，但是它们都是要提供存储和遍历功能的，    我们把它们的共性不断的向上提取，最终就形成了集合的继承体系结构图。    Collection        |--List            |--ArrayList            |--Vector            |--LinkedList        |--Set            |--HashSet            |--TreeSet</code></pre><h3 id="4-Collection的功能概述-自己补齐"><a href="#4-Collection的功能概述-自己补齐" class="headerlink" title="(4)Collection的功能概述(自己补齐)"></a>(4)Collection的功能概述(自己补齐)</h3><h4 id="A-添加功能"><a href="#A-添加功能" class="headerlink" title="A:添加功能"></a>A:添加功能</h4><ul><li>boolean add(Object obj):添加一个元素</li><li>boolean addAll(Collection c):添加一个集合的元素<h4 id="B-删除功能"><a href="#B-删除功能" class="headerlink" title="B:删除功能"></a>B:删除功能</h4></li><li>void clear():移除所有元素</li><li>boolean remove(Object o):移除一个元素</li><li>boolean removeAll(Collection c):移除一个集合的元素(是一个还是所有)<h4 id="C-判断功能"><a href="#C-判断功能" class="headerlink" title="C:判断功能"></a>C:判断功能</h4></li><li>boolean contains(Object o)：判断集合中是否包含指定的元素</li><li>boolean containsAll(Collection c)：判断集合中是否包含指定的集合元素(是一个还是所有)</li><li>boolean isEmpty()：判断集合是否为空<h4 id="D-获取功能"><a href="#D-获取功能" class="headerlink" title="D:获取功能"></a>D:获取功能</h4></li><li>Iterator<E> iterator()(重点)<h4 id="E-长度功能"><a href="#E-长度功能" class="headerlink" title="E:长度功能"></a>E:长度功能</h4></li><li>int size():元素的个数</li><li>面试题：数组有没有length()方法呢?字符串有没有length()方法呢?集合有没有length()方法呢?</li></ul><h4 id="F-交集-了解"><a href="#F-交集-了解" class="headerlink" title="F:交集(了解)"></a>F:交集(了解)</h4><ul><li>boolean retainAll(Collection c):两个集合都有的元素?思考元素去哪了，返回的boolean又是什么意思呢?</li></ul><h4 id="G-把集合转数组-了解"><a href="#G-把集合转数组-了解" class="headerlink" title="G:把集合转数组(了解)"></a>G:把集合转数组(了解)</h4><ul><li>Object[] toArray()</li></ul><h3 id="5-Collection集合的遍历"><a href="#5-Collection集合的遍历" class="headerlink" title="(5)Collection集合的遍历"></a>(5)Collection集合的遍历</h3><h4 id="A-把集合转数组-了解"><a href="#A-把集合转数组-了解" class="headerlink" title="A:把集合转数组(了解)"></a>A:把集合转数组(了解)</h4><h4 id="B-迭代器-集合专用方式"><a href="#B-迭代器-集合专用方式" class="headerlink" title="B:迭代器(集合专用方式)"></a>B:迭代器(集合专用方式)</h4><h3 id="6-迭代器"><a href="#6-迭代器" class="headerlink" title="(6)迭代器"></a>(6)迭代器</h3><h4 id="A-是集合的获取元素的方式。"><a href="#A-是集合的获取元素的方式。" class="headerlink" title="A:是集合的获取元素的方式。"></a>A:是集合的获取元素的方式。</h4><h4 id="B-是依赖于集合而存在的。"><a href="#B-是依赖于集合而存在的。" class="headerlink" title="B:是依赖于集合而存在的。"></a>B:是依赖于集合而存在的。</h4><h4 id="C-迭代器的原理和源码。"><a href="#C-迭代器的原理和源码。" class="headerlink" title="C:迭代器的原理和源码。"></a>C:迭代器的原理和源码。</h4><pre><code>        a:为什么定义为了一个接口而不是实现类?        b:看了看迭代器的内部类实现。</code></pre><h3 id="7-Collection集合的案例-遍历方式-迭代器"><a href="#7-Collection集合的案例-遍历方式-迭代器" class="headerlink" title="(7)Collection集合的案例(遍历方式 迭代器)"></a>(7)Collection集合的案例(遍历方式 迭代器)</h3><pre><code>    集合的操作步骤：        A:创建集合对象        B:创建元素对象        C:把元素添加到集合        D:遍历集合</code></pre><h4 id="A-存储字符串并遍历"><a href="#A-存储字符串并遍历" class="headerlink" title="A:存储字符串并遍历"></a>A:存储字符串并遍历</h4><pre><code>        import java.util.Collection;        import java.util.ArrayList;        import java.util.Iterator;        public class CollectionDemo {            public static void main(String[] args) {                //创建集合对象                Collection c = new ArrayList();                //创建并添加元素                c.add(&quot;hello&quot;);                c.add(&quot;world&quot;);                c.add(&quot;java&quot;);                //遍历集合                Iterator it = c.iterator();                while(it.hasNext()) {                    String s =(String) it.next();                    System.out.println(s);                }            }        }</code></pre><h4 id="B-存储自定义对象并遍历"><a href="#B-存储自定义对象并遍历" class="headerlink" title="B:存储自定义对象并遍历"></a>B:存储自定义对象并遍历</h4><pre><code>        public class Student {            private String name;            private int age;            public Student(){}            public Student(String name,int age) {                this.name = name;                this.age = age;            }            //getXxx()/setXxx()        }        import java.util.Collection;        import java.util.ArrayList;        import java.util.Iterator;        public class StudentDemo {            public static void main(String[] args) {                //创建集合对象                Collection c = new ArrayList();                //创建学生对象                Student s1 = new Student(&quot;林青霞&quot;,27);                Student s2 = new Student(&quot;风清扬&quot;,30);                Student s3 = new Student(&quot;刘意&quot;,30);                Student s4 = new Student(&quot;武鑫&quot;,25);                Student s5 = new Student(&quot;刘晓曲&quot;,16);                //添加元素                c.add(s1);                c.add(s2);                c.add(s3);                c.add(s4);                c.add(s5);                //遍历集合                Iterator it = c.iterator();                while(it.hasNext()) {                    Student s = (Student)it.next();                    System.out.println(s.getName()+&quot;---&quot;+s.getAge());                }            }        }</code></pre><h2 id="3-集合-List-掌握"><a href="#3-集合-List-掌握" class="headerlink" title="3:集合(List)(掌握)"></a>3:集合(List)(掌握)</h2><h3 id="1-List是Collection的子接口"><a href="#1-List是Collection的子接口" class="headerlink" title="(1)List是Collection的子接口"></a>(1)List是Collection的子接口</h3><pre><code>    特点：有序(存储顺序和取出顺序一致)，可重复。</code></pre><h3 id="2-List的特有功能：-自己补齐"><a href="#2-List的特有功能：-自己补齐" class="headerlink" title="(2)List的特有功能：(自己补齐)"></a>(2)List的特有功能：(自己补齐)</h3><h4 id="A-添加功能-1"><a href="#A-添加功能-1" class="headerlink" title="A:添加功能"></a>A:添加功能</h4><ul><li>void add(int index,Object element):在指定位置添加元素</li></ul><h4 id="B-删除功能-1"><a href="#B-删除功能-1" class="headerlink" title="B:删除功能"></a>B:删除功能</h4><ul><li>Object remove(int index)：根据索引删除元素,返回被删除的元素</li></ul><h4 id="C-获取功能"><a href="#C-获取功能" class="headerlink" title="C:获取功能"></a>C:获取功能</h4><ul><li>Object get(int index):获取指定位置的元素</li></ul><h4 id="D-迭代器功能"><a href="#D-迭代器功能" class="headerlink" title="D:迭代器功能"></a>D:迭代器功能</h4><ul><li>ListIterator listIterator()：List集合特有的迭代器</li></ul><h4 id="E-修改功能"><a href="#E-修改功能" class="headerlink" title="E:修改功能"></a>E:修改功能</h4><ul><li>Object set(int index,Object element):根据索引修改元素，返回被修饰的元素</li></ul><h3 id="3-List集合的特有遍历功能"><a href="#3-List集合的特有遍历功能" class="headerlink" title="(3)List集合的特有遍历功能"></a>(3)List集合的特有遍历功能</h3><h4 id="A-由size-和get-结合。"><a href="#A-由size-和get-结合。" class="headerlink" title="A:由size()和get()结合。"></a>A:由size()和get()结合。</h4><h4 id="B-代码演示"><a href="#B-代码演示" class="headerlink" title="B:代码演示"></a>B:代码演示</h4><pre><code>                //创建集合对象                List list = new ArrayList();                //创建并添加元素                list.add(&quot;hello&quot;);                list.add(&quot;world&quot;);                list.add(&quot;java&quot;);                //遍历集合                Iterator it = list.iterator();                while(it.hasNext()) {                    String s =(String) it.next();                    System.out.println(s);                }                System.out.println(&quot;----------&quot;);                for(int x=0; x&lt;list.size(); x++) {                    String s =(String) list.get(x);                    System.out.println(s);                }</code></pre><h3 id="4-列表迭代器的特有功能；-了解"><a href="#4-列表迭代器的特有功能；-了解" class="headerlink" title="(4)列表迭代器的特有功能；(了解)"></a>(4)列表迭代器的特有功能；(了解)</h3><pre><code>    可以逆向遍历，但是要先正向遍历，所以无意义，基本不使用。</code></pre><h3 id="5-并发修改异常"><a href="#5-并发修改异常" class="headerlink" title="(5)并发修改异常"></a>(5)并发修改异常</h3><h4 id="A-出现的现象"><a href="#A-出现的现象" class="headerlink" title="A:出现的现象"></a>A:出现的现象</h4><pre><code>        迭代器遍历集合，集合修改集合元素</code></pre><h4 id="B-原因"><a href="#B-原因" class="headerlink" title="B:原因"></a>B:原因</h4><pre><code>        迭代器是依赖于集合的，而集合的改变迭代器并不知道。</code></pre><h4 id="C-解决方案"><a href="#C-解决方案" class="headerlink" title="C:解决方案"></a>C:解决方案</h4><pre><code>        a:迭代器遍历，迭代器修改(ListIterator)            元素添加在刚才迭代的位置        b:集合遍历，集合修改(size()和get())            元素添加在集合的末尾</code></pre><h3 id="6-常见数据结构"><a href="#6-常见数据结构" class="headerlink" title="(6)常见数据结构"></a>(6)常见数据结构</h3><h4 id="A-栈-先进后出"><a href="#A-栈-先进后出" class="headerlink" title="A:栈 先进后出"></a>A:栈 先进后出</h4><h4 id="B-队列-先进先出"><a href="#B-队列-先进先出" class="headerlink" title="B:队列 先进先出"></a>B:队列 先进先出</h4><h4 id="C-数组-查询快，增删慢"><a href="#C-数组-查询快，增删慢" class="headerlink" title="C:数组 查询快，增删慢"></a>C:数组 查询快，增删慢</h4><h4 id="D-链表-查询慢，增删快"><a href="#D-链表-查询慢，增删快" class="headerlink" title="D:链表 查询慢，增删快"></a>D:链表 查询慢，增删快</h4><h3 id="7-List的子类特点-面试题"><a href="#7-List的子类特点-面试题" class="headerlink" title="(7)List的子类特点(面试题)"></a>(7)List的子类特点(面试题)</h3><pre><code>    ArrayList        底层数据结构是数组，查询快，增删慢。        线程不安全，效率高。    Vector        底层数据结构是数组，查询快，增删慢。        线程安全，效率低。    LinkedList        底层数据结构是链表，查询慢，增删快。        线程不安全，效率高。    到底使用谁呢?看需求?    分析：        要安全吗?            要：Vector(即使要，也不使用这个，后面再说)            不要：ArrayList或者LinkedList                查询多；ArrayList                增删多：LinkedList    什么都不知道，就用ArrayList。</code></pre><h3 id="8-List集合的案例-遍历方式-迭代器和普通for"><a href="#8-List集合的案例-遍历方式-迭代器和普通for" class="headerlink" title="(8)List集合的案例(遍历方式 迭代器和普通for)"></a>(8)List集合的案例(遍历方式 迭代器和普通for)</h3><pre><code>    A:存储字符串并遍历    B:存储自定义对象并遍历</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day14</title>
      <link href="/2020/061431197.html"/>
      <url>/2020/061431197.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-正则表达式-理解"><a href="#1-正则表达式-理解" class="headerlink" title="1:正则表达式(理解)"></a>1:正则表达式(理解)</h2><h3 id="1-就是符合一定规则的字符串"><a href="#1-就是符合一定规则的字符串" class="headerlink" title="(1)就是符合一定规则的字符串"></a>(1)就是符合一定规则的字符串</h3><h3 id="2-常见规则"><a href="#2-常见规则" class="headerlink" title="(2)常见规则"></a>(2)常见规则</h3><h4 id="A-字符"><a href="#A-字符" class="headerlink" title="A:字符"></a>A:字符</h4><pre><code>        x 字符 x。举例：&#39;a&#39;表示字符a        \\ 反斜线字符。        \n 新行（换行）符 (&#39;\u000A&#39;)         \r 回车符 (&#39;\u000D&#39;)</code></pre><h4 id="B-字符类"><a href="#B-字符类" class="headerlink" title="B:字符类"></a>B:字符类</h4><pre><code>        [abc] a、b 或 c（简单类）         [^abc] 任何字符，除了 a、b 或 c（否定）         [a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内（范围）         [0-9] 0到9的字符都包括</code></pre><h4 id="C-预定义字符类"><a href="#C-预定义字符类" class="headerlink" title="C:预定义字符类"></a>C:预定义字符类</h4><pre><code>        . 任何字符。我的就是.字符本身，怎么表示呢? \.        \d 数字：[0-9]        \w 单词字符：[a-zA-Z_0-9]            在正则表达式里面组成单词的东西必须有这些东西组成</code></pre><h4 id="D-边界匹配器"><a href="#D-边界匹配器" class="headerlink" title="D:边界匹配器"></a>D:边界匹配器</h4><pre><code>        ^ 行的开头         $ 行的结尾         \b 单词边界            就是不是单词字符的地方。            举例：hello world?haha;xixi</code></pre><h4 id="E-Greedy-数量词"><a href="#E-Greedy-数量词" class="headerlink" title="E:Greedy 数量词"></a>E:Greedy 数量词</h4><pre><code>        X? X，一次或一次也没有        X* X，零次或多次        X+ X，一次或多次        X{n} X，恰好 n 次         X{n,} X，至少 n 次         X{n,m} X，至少 n 次，但是不超过 m 次 </code></pre><h3 id="3-常见功能：-分别用的是谁呢"><a href="#3-常见功能：-分别用的是谁呢" class="headerlink" title="(3)常见功能：(分别用的是谁呢?)"></a>(3)常见功能：(分别用的是谁呢?)</h3><h4 id="A-判断功能"><a href="#A-判断功能" class="headerlink" title="A:判断功能"></a>A:判断功能</h4><pre><code>        String类的public boolean matches(String regex)</code></pre><h4 id="B-分割功能"><a href="#B-分割功能" class="headerlink" title="B:分割功能"></a>B:分割功能</h4><pre><code>        String类的public String[] split(String regex)</code></pre><h4 id="C-替换功能"><a href="#C-替换功能" class="headerlink" title="C:替换功能"></a>C:替换功能</h4><pre><code>        String类的public String replaceAll(String regex,String replacement)</code></pre><h4 id="D-获取功能"><a href="#D-获取功能" class="headerlink" title="D:获取功能"></a>D:获取功能</h4><pre><code>        Pattern和Matcher            Pattern p = Pattern.compile(&quot;a*b&quot;);            Matcher m = p.matcher(&quot;aaaaab&quot;);            find():查找存不存在            group():获取刚才查找过的数据</code></pre><h3 id="4-案例"><a href="#4-案例" class="headerlink" title="(4)案例"></a>(4)案例</h3><pre><code>    A:判断电话号码和邮箱    B:按照不同的规则分割数据    C:把论坛中的数字替换为*    D:获取字符串中由3个字符组成的单词</code></pre><h2 id="2-Math-掌握"><a href="#2-Math-掌握" class="headerlink" title="2:Math(掌握)"></a>2:Math(掌握)</h2><h3 id="1-针对数学运算进行操作的类"><a href="#1-针对数学运算进行操作的类" class="headerlink" title="(1)针对数学运算进行操作的类"></a>(1)针对数学运算进行操作的类</h3><h3 id="2-常见方法-自己补齐"><a href="#2-常见方法-自己补齐" class="headerlink" title="(2)常见方法(自己补齐)"></a>(2)常见方法(自己补齐)</h3><h4 id="A-绝对值"><a href="#A-绝对值" class="headerlink" title="A:绝对值"></a>A:绝对值</h4><pre><code>    public static int abs(int a)：绝对值    </code></pre><h4 id="B-向上取整"><a href="#B-向上取整" class="headerlink" title="B:向上取整"></a>B:向上取整</h4><pre><code>    public static double ceil(double a):向上取整</code></pre><h4 id="C-向下取整"><a href="#C-向下取整" class="headerlink" title="C:向下取整"></a>C:向下取整</h4><pre><code>    public static double floor(double a):向下取整</code></pre><h4 id="D-两个数据中的大值"><a href="#D-两个数据中的大值" class="headerlink" title="D:两个数据中的大值"></a>D:两个数据中的大值</h4><pre><code>    public static int max(int a,int b):最大值 (min自学)</code></pre><h4 id="E-a的b次幂"><a href="#E-a的b次幂" class="headerlink" title="E:a的b次幂"></a>E:a的b次幂</h4><pre><code>    public static double pow(double a,double b):a的b次幂</code></pre><h4 id="F-随机数"><a href="#F-随机数" class="headerlink" title="F:随机数"></a>F:随机数</h4><pre><code>    public static double random():随机数 [0.0,1.0)</code></pre><h4 id="G-四舍五入"><a href="#G-四舍五入" class="headerlink" title="G:四舍五入"></a>G:四舍五入</h4><pre><code>    public static int round(float a) 四舍五入(参数为double的自学)</code></pre><h4 id="H-正平方根"><a href="#H-正平方根" class="headerlink" title="H:正平方根"></a>H:正平方根</h4><pre><code>    public static double sqrt(double a):正平方根</code></pre><h3 id="3-案例："><a href="#3-案例：" class="headerlink" title="(3)案例："></a>(3)案例：</h3><pre><code>    A:猜数字小游戏    B:获取任意范围的随机数</code></pre><h2 id="3-Random-理解"><a href="#3-Random-理解" class="headerlink" title="3:Random(理解)"></a>3:Random(理解)</h2><h3 id="1-用于产生随机数的类"><a href="#1-用于产生随机数的类" class="headerlink" title="(1)用于产生随机数的类"></a>(1)用于产生随机数的类</h3><h3 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="(2)构造方法:"></a>(2)构造方法:</h3><pre><code>    A:Random() 默认种子，每次产生的随机数不同    B:Random(long seed) 指定种子，每次种子相同，随机数就相同</code></pre><h3 id="3-成员方法"><a href="#3-成员方法" class="headerlink" title="(3)成员方法:"></a>(3)成员方法:</h3><pre><code>    A:int nextInt() 返回int范围内的随机数    B:int nextInt(int n) 返回[0,n)范围内的随机数</code></pre><h2 id="4-System-掌握"><a href="#4-System-掌握" class="headerlink" title="4:System(掌握)"></a>4:System(掌握)</h2><h3 id="1-系统类-提供了一些有用的字段和方法"><a href="#1-系统类-提供了一些有用的字段和方法" class="headerlink" title="(1)系统类,提供了一些有用的字段和方法"></a>(1)系统类,提供了一些有用的字段和方法</h3><h3 id="2-成员方法-自己补齐"><a href="#2-成员方法-自己补齐" class="headerlink" title="(2)成员方法(自己补齐)"></a>(2)成员方法(自己补齐)</h3><h4 id="A-运行垃圾回收器"><a href="#A-运行垃圾回收器" class="headerlink" title="A:运行垃圾回收器"></a>A:运行垃圾回收器</h4><pre><code>    public static void gc()：运行垃圾回收器。     </code></pre><h4 id="B-退出jvm"><a href="#B-退出jvm" class="headerlink" title="B:退出jvm"></a>B:退出jvm</h4><pre><code>    public static void exit(int status):终止当前正在运行的 Java 虚拟机。参数用作状态码；根据惯例，非 0 的状态码表示异常终止。</code></pre><h4 id="C-获取当前时间的毫秒值"><a href="#C-获取当前时间的毫秒值" class="headerlink" title="C:获取当前时间的毫秒值"></a>C:获取当前时间的毫秒值</h4><pre><code>    public static long currentTimeMillis():返回以毫秒为单位的当前时间</code></pre><h4 id="D-数组复制"><a href="#D-数组复制" class="headerlink" title="D:数组复制"></a>D:数组复制</h4><pre><code>    public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length)     从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。</code></pre><h2 id="5-BigInteger-理解"><a href="#5-BigInteger-理解" class="headerlink" title="5:BigInteger(理解)"></a>5:BigInteger(理解)</h2><h3 id="1-针对大整数的运算"><a href="#1-针对大整数的运算" class="headerlink" title="(1)针对大整数的运算"></a>(1)针对大整数的运算</h3><h3 id="2-构造方法-1"><a href="#2-构造方法-1" class="headerlink" title="(2)构造方法"></a>(2)构造方法</h3><pre><code>    A:BigInteger(String s)</code></pre><h3 id="3-成员方法-自己补齐"><a href="#3-成员方法-自己补齐" class="headerlink" title="(3)成员方法(自己补齐)"></a>(3)成员方法(自己补齐)</h3><pre><code>    A:加    B:减    C:乘    D:除    E:商和余数</code></pre><h2 id="6-BigDecimal-理解"><a href="#6-BigDecimal-理解" class="headerlink" title="6:BigDecimal(理解)"></a>6:BigDecimal(理解)</h2><h3 id="1-浮点数据做运算，会丢失精度。所以，针对浮点数据的操作建议采用BigDecimal。-金融相关的项目"><a href="#1-浮点数据做运算，会丢失精度。所以，针对浮点数据的操作建议采用BigDecimal。-金融相关的项目" class="headerlink" title="(1)浮点数据做运算，会丢失精度。所以，针对浮点数据的操作建议采用BigDecimal。(金融相关的项目)"></a>(1)浮点数据做运算，会丢失精度。所以，针对浮点数据的操作建议采用BigDecimal。(金融相关的项目)</h3><h3 id="2-构造方法-2"><a href="#2-构造方法-2" class="headerlink" title="(2)构造方法"></a>(2)构造方法</h3><pre><code>    A:BigDecimal(String s)</code></pre><h3 id="3-成员方法："><a href="#3-成员方法：" class="headerlink" title="(3)成员方法："></a>(3)成员方法：</h3><h4 id="A-加"><a href="#A-加" class="headerlink" title="A:加"></a>A:加</h4><pre><code>    public BigInteger add(BigInteger val):加</code></pre><h4 id="B-减"><a href="#B-减" class="headerlink" title="B:减"></a>B:减</h4><pre><code>    public BigInteger subtract(BigInteger val):减</code></pre><h4 id="C-乘"><a href="#C-乘" class="headerlink" title="C:乘"></a>C:乘</h4><pre><code>    public BigInteger multiply(BigInteger val):乘</code></pre><h4 id="D-除"><a href="#D-除" class="headerlink" title="D:除"></a>D:除</h4><pre><code>    public BigInteger divide(BigInteger val):除</code></pre><h4 id="E-自己保留小数几位"><a href="#E-自己保留小数几位" class="headerlink" title="E:自己保留小数几位"></a>E:自己保留小数几位</h4><pre><code>    public BigInteger[] divideAndRemainder(BigInteger val):返回商和余数的数组</code></pre><h2 id="7-Date-DateFormat-掌握"><a href="#7-Date-DateFormat-掌握" class="headerlink" title="7:Date/DateFormat(掌握)"></a>7:Date/DateFormat(掌握)</h2><h3 id="1-Date是日期类，可以精确到毫秒。"><a href="#1-Date是日期类，可以精确到毫秒。" class="headerlink" title="(1)Date是日期类，可以精确到毫秒。"></a>(1)Date是日期类，可以精确到毫秒。</h3><h4 id="A-构造方法"><a href="#A-构造方法" class="headerlink" title="A:构造方法"></a>A:构造方法</h4><pre><code>        Date()        Date(long time)</code></pre><h4 id="B-成员方法"><a href="#B-成员方法" class="headerlink" title="B:成员方法"></a>B:成员方法</h4><pre><code>        getTime()        setTime(long time)</code></pre><h4 id="C-日期和毫秒值的相互转换"><a href="#C-日期和毫秒值的相互转换" class="headerlink" title="C:日期和毫秒值的相互转换"></a>C:日期和毫秒值的相互转换</h4><pre><code>    案例：你来到这个世界多少天了?</code></pre><h3 id="2-DateFormat针对日期进行格式化和针对字符串进行解析的类，但是是抽象类，所以使用其子类SimpleDateFormat"><a href="#2-DateFormat针对日期进行格式化和针对字符串进行解析的类，但是是抽象类，所以使用其子类SimpleDateFormat" class="headerlink" title="(2)DateFormat针对日期进行格式化和针对字符串进行解析的类，但是是抽象类，所以使用其子类SimpleDateFormat"></a>(2)DateFormat针对日期进行格式化和针对字符串进行解析的类，但是是抽象类，所以使用其子类SimpleDateFormat</h3><pre><code>    A:SimpleDateFormat(String pattern) 给定模式        yyyy-MM-dd HH:mm:ss    B:日期和字符串的转换        a:Date -- String            format()        b:String -- Date            parse()    C:案例：        制作了一个针对日期操作的工具类。</code></pre><h2 id="8-Calendar-掌握"><a href="#8-Calendar-掌握" class="headerlink" title="8:Calendar(掌握)"></a>8:Calendar(掌握)</h2><h3 id="1-日历类，封装了所有的日历字段值，通过统一的方法根据传入不同的日历字段可以获取值。"><a href="#1-日历类，封装了所有的日历字段值，通过统一的方法根据传入不同的日历字段可以获取值。" class="headerlink" title="(1)日历类，封装了所有的日历字段值，通过统一的方法根据传入不同的日历字段可以获取值。"></a>(1)日历类，封装了所有的日历字段值，通过统一的方法根据传入不同的日历字段可以获取值。</h3><h3 id="2-如何得到一个日历对象呢"><a href="#2-如何得到一个日历对象呢" class="headerlink" title="(2)如何得到一个日历对象呢?"></a>(2)如何得到一个日历对象呢?</h3><pre><code>    Calendar rightNow = Calendar.getInstance();    本质返回的是子类对象</code></pre><h3 id="3-成员方法-1"><a href="#3-成员方法-1" class="headerlink" title="(3)成员方法"></a>(3)成员方法</h3><pre><code>    A:根据日历字段得到对应的值    B:根据日历字段和一个正负数确定是添加还是减去对应日历字段的值    C:设置日历对象的年月日</code></pre><h3 id="4-案例："><a href="#4-案例：" class="headerlink" title="(4)案例："></a>(4)案例：</h3><pre><code>    计算任意一年的2月份有多少天?</code></pre><hr><p>看看下面的类，是否都熟悉，简要说明每个类主要是干什么呢?  </p><pre><code>Object类     Object 是类层次结构的根类。  每个类都使用 Object 作为超类。  所有对象（包括数组）都实现这个类的方法。 Scanner        一个可以使用正则表达式来解析基本类型和字符串的简单文本扫描器。 String        String 类代表字符串。Java 程序中的所有字符串字面值（如 &quot;abc&quot; ）都作为此类的实例实现。 StringBuffer/StringBuilder        线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。  虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。Arrays        此类包含用来操作数组（比如排序和搜索）的各种方法。  此类还包含一个允许将数组作为列表来查看的静态工厂。 Integer        Integer 类在对象中包装了一个基本类型 int 的值。  Integer 类型的对象包含一个 int 类型的字段。 Character        Character 类在对象中包装一个基本类型 char 的值。  Character 类型的对象包含类型为 char 的单个字段。 Pattern        正则表达式的编译表示形式。指定为字符串的正则表达式必须首先被编译为此类的实例。  然后，可将得到的模式用于创建 Matcher 对象，依照正则表达式，该对象可以与任意字符序列匹配。  执行匹配所涉及的所有状态都驻留在匹配器中，所以多个匹配器可以共享同一模式。Matcher        通过解释 Pattern 对 character sequence 执行匹配操作的引擎。  通过调用模式的 matcher 方法从模式创建匹配器。Math        Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。 Random        此类的实例用于生成伪随机数流。此类使用 48 位的种子，使用线性同余公式 (linear congruential form) 对其进行了修改（请参阅 Donald Knuth 的The Art of Computer Programming, Volume 3，第 3.2.1 节）。 System        System 类包含一些有用的类字段和方法。它不能被实例化。   在 System 类提供的设施中，有标准输入、标准输出和错误输出流；对外部定义的属性和环境变量的访问；   加载文件和库的方法；还有快速复制数组的一部分的实用方法。 BigInteger        不可变的任意精度的整数。所有操作中，都以二进制补码形式表示 BigInteger（如 Java 的基本整数类型）。BigDecimal        不可变的、任意精度的有符号十进制数。BigDecimal 由任意精度的整数非标度值 和 32 位的整数标度 (scale) 组成。  如果为零或正数，则标度是小数点后的位数。如果为负数，则将该数的非标度值乘以 10 的负 scale 次幂。  因此，BigDecimal 表示的数值是 (unscaledValue × 10-scale)。 Date        类 Date 表示特定的瞬间，精确到毫秒。 DateFormat        DateFormat 是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。  日期/时间格式化子类（如 SimpleDateFormat）允许进行格式化（也就是日期 -&gt; 文本）、解析（文本-&gt; 日期）和标准化。  将日期表示为 Date 对象，或者表示为从 GMT（格林尼治标准时间）1970 年 1 月 1 日 00:00:00 这一刻开始的毫秒数。Calendar        Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等 日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。  瞬间可用毫秒值来表示，它是距历元（即格林威治标准时间 1970 年 1 月 1 日的 00:00:00.000，格里高利历）的偏移量。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day13</title>
      <link href="/2020/061348028.html"/>
      <url>/2020/061348028.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-StringBuffer-掌握"><a href="#1-StringBuffer-掌握" class="headerlink" title="1:StringBuffer(掌握)"></a>1:StringBuffer(掌握)</h2><h3 id="1-用字符串做拼接，比较耗时并且也耗内存，而这种拼接操作又是比较常见的，为了解决这个问题，Java就提供了"><a href="#1-用字符串做拼接，比较耗时并且也耗内存，而这种拼接操作又是比较常见的，为了解决这个问题，Java就提供了" class="headerlink" title="(1)用字符串做拼接，比较耗时并且也耗内存，而这种拼接操作又是比较常见的，为了解决这个问题，Java就提供了"></a>(1)用字符串做拼接，比较耗时并且也耗内存，而这种拼接操作又是比较常见的，为了解决这个问题，Java就提供了</h3><pre><code>   一个字符串缓冲区类。StringBuffer供我们使用。</code></pre><h3 id="2-StringBuffer的构造方法"><a href="#2-StringBuffer的构造方法" class="headerlink" title="(2)StringBuffer的构造方法"></a>(2)StringBuffer的构造方法</h3><pre><code>    A:StringBuffer()    B:StringBuffer(int size)    C:StringBuffer(String str)</code></pre><h3 id="3-StringBuffer的常见功能-自己补齐方法的声明和方法的解释"><a href="#3-StringBuffer的常见功能-自己补齐方法的声明和方法的解释" class="headerlink" title="(3)StringBuffer的常见功能(自己补齐方法的声明和方法的解释)"></a>(3)StringBuffer的常见功能(自己补齐方法的声明和方法的解释)</h3><h4 id="A-添加功能"><a href="#A-添加功能" class="headerlink" title="A:添加功能"></a>A:添加功能</h4><pre><code>        public StringBuffer append(String str):可以把任意类型数据添加到字符串缓冲区里面,并返回字符串缓冲区本身        public StringBuffer insert(int offset,String str):在指定位置把任意类型的数据插入到字符串缓冲区里面,并返回字符串缓冲区本身</code></pre><h4 id="B-删除功能"><a href="#B-删除功能" class="headerlink" title="B:删除功能"></a>B:删除功能</h4><pre><code>         public StringBuffer deleteCharAt(int index):删除指定位置的字符，并返回本身          public StringBuffer delete(int start,int end):删除从指定位置开始指定位置结束的内容，并返回本身</code></pre><h4 id="C-替换功能"><a href="#C-替换功能" class="headerlink" title="C:替换功能"></a>C:替换功能</h4><pre><code>        public StringBuffer replace(int start,int end,String str):从start开始到end用str替换</code></pre><h4 id="D-反转功能"><a href="#D-反转功能" class="headerlink" title="D:反转功能"></a>D:反转功能</h4><pre><code>        public StringBuffer reverse()</code></pre><h4 id="E-截取功能-注意这个返回值"><a href="#E-截取功能-注意这个返回值" class="headerlink" title="E:截取功能(注意这个返回值)"></a>E:截取功能(注意这个返回值)</h4><pre><code>        注意返回值类型不再是StringBuffer本身了          public String substring(int start)          public String substring(int start,int end)</code></pre><h3 id="4-StringBuffer的练习-做一遍"><a href="#4-StringBuffer的练习-做一遍" class="headerlink" title="(4)StringBuffer的练习(做一遍)"></a>(4)StringBuffer的练习(做一遍)</h3><pre><code>    A:String和StringBuffer相互转换        String -- StringBuffer            构造方法        StringBuffer -- String            toString()方法    B:字符串的拼接    C:把字符串反转    D:判断一个字符串是否对称</code></pre><h3 id="5-面试题"><a href="#5-面试题" class="headerlink" title="(5)面试题"></a>(5)面试题</h3><pre><code>    小细节：        StringBuffer：同步的，数据安全，效率低。        StringBuilder：不同步的，数据不安全，效率高。    A:String,StringBuffer,StringBuilder的区别    B:StringBuffer和数组的区别?</code></pre><h3 id="6-注意的问题："><a href="#6-注意的问题：" class="headerlink" title="(6)注意的问题："></a>(6)注意的问题：</h3><pre><code>    String作为形式参数，StringBuffer作为形式参数。</code></pre><h2 id="2-数组高级以及Arrays-掌握"><a href="#2-数组高级以及Arrays-掌握" class="headerlink" title="2:数组高级以及Arrays(掌握)"></a>2:数组高级以及Arrays(掌握)</h2><h3 id="1-排序"><a href="#1-排序" class="headerlink" title="(1)排序"></a>(1)排序</h3><h4 id="A-冒泡排序"><a href="#A-冒泡排序" class="headerlink" title="A:冒泡排序"></a>A:冒泡排序</h4><pre><code>        相邻元素两两比较，大的往后放，第一次完毕，最大值出现在了最大索引处。同理，其他的元素就可以排好。        public static void bubbleSort(int[] arr) {            for(int x=0; x&lt;arr.length-1; x++) {                for(int y=0; y&lt;arr.length-1-x; y++) {                    if(arr[y] &gt; arr[y+1]) {                        int temp = arr[y];                        arr[y] = arr[y+1];                        arr[y+1] = temp;                    }                }            }        }</code></pre><h4 id="B-选择排序"><a href="#B-选择排序" class="headerlink" title="B:选择排序"></a>B:选择排序</h4><pre><code>        把0索引的元素，和索引1以后的元素都进行比较，第一次完毕，最小值出现在了0索引。同理，其他的元素就可以排好。        public static void selectSort(int[] arr) {            for(int x=0; x&lt;arr.length-1; x++) {                for(int y=x+1; y&lt;arr.length; y++) {                    if(arr[y] &lt; arr[x]) {                        int temp = arr[x];                        arr[x] = arr[y];                        arr[y] = temp;                    }                }            }        }</code></pre><h3 id="2-查找"><a href="#2-查找" class="headerlink" title="(2)查找"></a>(2)查找</h3><h4 id="A-基本查找"><a href="#A-基本查找" class="headerlink" title="A:基本查找"></a>A:基本查找</h4><pre><code>        针对数组无序的情况        public static int getIndex(int[] arr,int value) {            int index = -1;            for(int x=0; x&lt;arr.length; x++) {                if(arr[x] == value) {                    index = x;                    break;                }            }            return index;        }</code></pre><h4 id="B-二分查找-折半查找"><a href="#B-二分查找-折半查找" class="headerlink" title="B:二分查找(折半查找)"></a>B:二分查找(折半查找)</h4><pre><code>        针对数组有序的情况(千万不要先排序，在查找)        public static int binarySearch(int[] arr,int value) {            int min = 0;            int max = arr.length-1;            int mid = (min+max)/2;            while(arr[mid] != value) {                if(arr[mid] &gt; value) {                    max = mid - 1;                }else if(arr[mid] &lt; value) {                    min = mid + 1;                }                if(min &gt; max) {                    return -1;                }                mid = (min+max)/2;            }            return mid;        }</code></pre><h3 id="3-Arrays工具类"><a href="#3-Arrays工具类" class="headerlink" title="(3)Arrays工具类"></a>(3)Arrays工具类</h3><pre><code>    A:是针对数组进行操作的工具类。包括排序和查找等功能。    B:要掌握的方法(自己补齐方法)        把数组转成字符串：        排序：        二分查找：</code></pre><h3 id="4-Arrays工具类的源码解析"><a href="#4-Arrays工具类的源码解析" class="headerlink" title="(4)Arrays工具类的源码解析"></a>(4)Arrays工具类的源码解析</h3><h3 id="5-把字符串中的字符进行排序"><a href="#5-把字符串中的字符进行排序" class="headerlink" title="(5)把字符串中的字符进行排序"></a>(5)把字符串中的字符进行排序</h3><pre><code>    举例：        &quot;edacbgf&quot;        得到结果        &quot;abcdefg&quot;</code></pre><h2 id="3-Integer-掌握"><a href="#3-Integer-掌握" class="headerlink" title="3:Integer(掌握)"></a>3:Integer(掌握)</h2><h3 id="1-为了让基本类型的数据进行更多的操作，Java就为每种基本类型提供了对应的包装类类型"><a href="#1-为了让基本类型的数据进行更多的操作，Java就为每种基本类型提供了对应的包装类类型" class="headerlink" title="(1)为了让基本类型的数据进行更多的操作，Java就为每种基本类型提供了对应的包装类类型"></a>(1)为了让基本类型的数据进行更多的操作，Java就为每种基本类型提供了对应的包装类类型</h3><pre><code>    byte         Byte    short        Short    int            Integer    long        Long    float        Float    double        Double    char        Character    boolean        Boolean</code></pre><h3 id="2-Integer的构造方法"><a href="#2-Integer的构造方法" class="headerlink" title="(2)Integer的构造方法"></a>(2)Integer的构造方法</h3><pre><code>    A:Integer i = new Integer(100);    B:Integer i = new Integer(&quot;100&quot;);        注意：这里的字符串必须是由数字字符组成</code></pre><h3 id="3-String和int的相互转换"><a href="#3-String和int的相互转换" class="headerlink" title="(3)String和int的相互转换"></a>(3)String和int的相互转换</h3><pre><code>    A:String -- int        Integer.parseInt(&quot;100&quot;);    B:int -- String        String.valueOf(100);</code></pre><h3 id="4-其他的功能-了解"><a href="#4-其他的功能-了解" class="headerlink" title="(4)其他的功能(了解)"></a>(4)其他的功能(了解)</h3><pre><code>    进制转换</code></pre><h3 id="5-JDK5的新特性"><a href="#5-JDK5的新特性" class="headerlink" title="(5)JDK5的新特性"></a>(5)JDK5的新特性</h3><pre><code>    自动装箱    基本类型--引用类型    自动拆箱    引用类型--基本类型    把下面的这个代码理解即可：        Integer i = 100;        i += 200;</code></pre><h3 id="6-面试题"><a href="#6-面试题" class="headerlink" title="(6)面试题"></a>(6)面试题</h3><pre><code>    -128到127之间的数据缓冲池问题</code></pre><h2 id="4-Character-了解"><a href="#4-Character-了解" class="headerlink" title="4:Character(了解)"></a>4:Character(了解)</h2><h3 id="1-Character构造方法"><a href="#1-Character构造方法" class="headerlink" title="(1)Character构造方法"></a>(1)Character构造方法</h3><pre><code>    Character ch = new Character(&#39;a&#39;);</code></pre><h3 id="2-要掌握的方法：-自己补齐"><a href="#2-要掌握的方法：-自己补齐" class="headerlink" title="(2)要掌握的方法：(自己补齐)"></a>(2)要掌握的方法：(自己补齐)</h3><h4 id="A-判断给定的字符是否是大写"><a href="#A-判断给定的字符是否是大写" class="headerlink" title="A:判断给定的字符是否是大写"></a>A:判断给定的字符是否是大写</h4><pre><code>    public static boolean isUpperCase(char ch):判断给定的字符是否是大写字符</code></pre><h4 id="B-判断给定的字符是否是小写"><a href="#B-判断给定的字符是否是小写" class="headerlink" title="B:判断给定的字符是否是小写"></a>B:判断给定的字符是否是小写</h4><pre><code>    public static boolean isLowerCase(char ch):判断给定的字符是否是小写字符</code></pre><h4 id="C-判断给定的字符是否是数字字符"><a href="#C-判断给定的字符是否是数字字符" class="headerlink" title="C:判断给定的字符是否是数字字符"></a>C:判断给定的字符是否是数字字符</h4><pre><code>    public static boolean isDigit(char ch):判断给定的字符是否是数字字符</code></pre><h4 id="D-把给定的字符转成大写"><a href="#D-把给定的字符转成大写" class="headerlink" title="D:把给定的字符转成大写"></a>D:把给定的字符转成大写</h4><pre><code>    public static char toUpperCase(char ch):把给定的字符转换为大写字符</code></pre><h4 id="E-把给定的字符转成小写"><a href="#E-把给定的字符转成小写" class="headerlink" title="E:把给定的字符转成小写"></a>E:把给定的字符转成小写</h4><pre><code>    public static char toLowerCase(char ch):把给定的字符转换为小写字符</code></pre><h3 id="3-案例："><a href="#3-案例：" class="headerlink" title="(3)案例："></a>(3)案例：</h3><pre><code>    统计字符串中大写，小写及数字字符出现的次数</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day12</title>
      <link href="/2020/061231581.html"/>
      <url>/2020/061231581.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Scanner的使用-了解"><a href="#1-Scanner的使用-了解" class="headerlink" title="1:Scanner的使用(了解)"></a>1:Scanner的使用(了解)</h2><h3 id="1-在JDK5以后出现的用于键盘录入数据的类。"><a href="#1-在JDK5以后出现的用于键盘录入数据的类。" class="headerlink" title="(1)在JDK5以后出现的用于键盘录入数据的类。"></a>(1)在JDK5以后出现的用于键盘录入数据的类。</h3><h3 id="2-构造方法："><a href="#2-构造方法：" class="headerlink" title="(2)构造方法："></a>(2)构造方法：</h3><h4 id="A-讲解了System-in这个东西。"><a href="#A-讲解了System-in这个东西。" class="headerlink" title="A:讲解了System.in这个东西。"></a>A:讲解了System.in这个东西。</h4><pre><code>        它其实是标准的输入流,对应于键盘录入</code></pre><h4 id="B-构造方法"><a href="#B-构造方法" class="headerlink" title="B:构造方法"></a>B:构造方法</h4><pre><code>        InputStream is = System.in;        Scanner(InputStream is)</code></pre><h4 id="C-常用的格式"><a href="#C-常用的格式" class="headerlink" title="C:常用的格式"></a>C:常用的格式</h4><pre><code>        Scanner sc = new Scanner(System.in);</code></pre><h3 id="3-基本方法格式："><a href="#3-基本方法格式：" class="headerlink" title="(3)基本方法格式："></a>(3)基本方法格式：</h3><pre><code>    A:hasNextXxx() 判断是否是某种类型的    B:nextXxx()    返回某种类型的元素</code></pre><h3 id="4-要掌握的两个方法"><a href="#4-要掌握的两个方法" class="headerlink" title="(4)要掌握的两个方法"></a>(4)要掌握的两个方法</h3><pre><code>    A:public int nextInt()    B:public String nextLine()</code></pre><h3 id="5-需要注意的小问题"><a href="#5-需要注意的小问题" class="headerlink" title="(5)需要注意的小问题"></a>(5)需要注意的小问题</h3><h4 id="A-同一个Scanner对象，先获取数值，再获取字符串会出现一个小问题。"><a href="#A-同一个Scanner对象，先获取数值，再获取字符串会出现一个小问题。" class="headerlink" title="A:同一个Scanner对象，先获取数值，再获取字符串会出现一个小问题。"></a>A:同一个Scanner对象，先获取数值，再获取字符串会出现一个小问题。</h4><h4 id="B-解决方案："><a href="#B-解决方案：" class="headerlink" title="B:解决方案："></a>B:解决方案：</h4><pre><code>        a:重新定义一个Scanner对象        b:把所有的数据都用字符串获取，然后再进行相应的转换</code></pre><h2 id="2-String类的概述和使用-掌握"><a href="#2-String类的概述和使用-掌握" class="headerlink" title="2:String类的概述和使用(掌握)"></a>2:String类的概述和使用(掌握)</h2><h3 id="1-多个字符组成的一串数据。"><a href="#1-多个字符组成的一串数据。" class="headerlink" title="(1)多个字符组成的一串数据。"></a>(1)多个字符组成的一串数据。</h3><pre><code>    其实它可以和字符数组进行相互转换。</code></pre><h3 id="2-构造方法：-1"><a href="#2-构造方法：-1" class="headerlink" title="(2)构造方法："></a>(2)构造方法：</h3><pre><code>    A:public String()    B:public String(byte[] bytes)    C:public String(byte[] bytes,int offset,int length)    D:public String(char[] value)    E:public String(char[] value,int offset,int count)    F:public String(String original)    下面的这一个虽然不是构造方法，但是结果也是一个字符串对象    G:String s = &quot;hello&quot;;</code></pre><h3 id="3-字符串的特点"><a href="#3-字符串的特点" class="headerlink" title="(3)字符串的特点"></a>(3)字符串的特点</h3><pre><code>    A:字符串一旦被赋值，就不能改变。        注意：这里指的是字符串的内容不能改变，而不是引用不能改变。    B:字面值作为字符串对象和通过构造方法创建对象的不同        String s = new String(&quot;hello&quot;);和String s = &quot;hello&quot;的区别?</code></pre><h3 id="4-字符串的面试题-看程序写结果"><a href="#4-字符串的面试题-看程序写结果" class="headerlink" title="(4)字符串的面试题(看程序写结果)"></a>(4)字符串的面试题(看程序写结果)</h3><h4 id="A-和equals"><a href="#A-和equals" class="headerlink" title="A:==和equals()"></a>A:==和equals()</h4><pre><code>        String s1 = new String(&quot;hello&quot;);        String s2 = new String(&quot;hello&quot;);        System.out.println(s1 == s2);// false        System.out.println(s1.equals(s2));// true        String s3 = new String(&quot;hello&quot;);        String s4 = &quot;hello&quot;;        System.out.println(s3 == s4);// false        System.out.println(s3.equals(s4));// true        String s5 = &quot;hello&quot;;        String s6 = &quot;hello&quot;;        System.out.println(s5 == s6);// true        System.out.println(s5.equals(s6));// true</code></pre><h4 id="B-字符串的拼接"><a href="#B-字符串的拼接" class="headerlink" title="B:字符串的拼接"></a>B:字符串的拼接</h4><pre><code>        String s1 = &quot;hello&quot;;        String s2 = &quot;world&quot;;        String s3 = &quot;helloworld&quot;;        System.out.println(s3 == s1 + s2);// false        System.out.println(s3.equals((s1 + s2)));// true        System.out.println(s3 == &quot;hello&quot; + &quot;world&quot;);// false 这个我们错了，应该是true        System.out.println(s3.equals(&quot;hello&quot; + &quot;world&quot;));// true</code></pre><h3 id="5-字符串的功能-自己补齐方法中文意思"><a href="#5-字符串的功能-自己补齐方法中文意思" class="headerlink" title="(5)字符串的功能(自己补齐方法中文意思)"></a>(5)字符串的功能(自己补齐方法中文意思)</h3><h4 id="A-判断功能"><a href="#A-判断功能" class="headerlink" title="A:判断功能"></a>A:判断功能</h4><pre><code>        boolean equals(Object obj)        boolean equalsIgnoreCase(String str)        boolean contains(String str)        boolean startsWith(String str)        boolean endsWith(String str)        boolean isEmpty()</code></pre><h4 id="B-获取功能"><a href="#B-获取功能" class="headerlink" title="B:获取功能"></a>B:获取功能</h4><pre><code>        int length()        char charAt(int index)        int indexOf(int ch)        int indexOf(String str)        int indexOf(int ch,int fromIndex)        int indexOf(String str,int fromIndex)        String substring(int start)        String substring(int start,int end)</code></pre><h4 id="C-转换功能"><a href="#C-转换功能" class="headerlink" title="C:转换功能"></a>C:转换功能</h4><pre><code>        byte[] getBytes()        char[] toCharArray()        static String valueOf(char[] chs)        static String valueOf(int i)        String toLowerCase()        String toUpperCase()        String concat(String str)</code></pre><h4 id="D-其他功能"><a href="#D-其他功能" class="headerlink" title="D:其他功能"></a>D:其他功能</h4><pre><code>        a:替换功能             String replace(char old,char new)            String replace(String old,String new)        b:去空格功能            String trim()        c:按字典比较功能            int compareTo(String str)            int compareToIgnoreCase(String str) </code></pre><h3 id="6-字符串的案例"><a href="#6-字符串的案例" class="headerlink" title="(6)字符串的案例"></a>(6)字符串的案例</h3><pre><code>    A:模拟用户登录    B:字符串遍历    C:统计字符串中大写，小写及数字字符的个数    D:把字符串的首字母转成大写，其他小写    E:把int数组拼接成一个指定格式的字符串    F:字符串反转    G:统计大串中小串出现的次数</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day11</title>
      <link href="/2020/061131261.html"/>
      <url>/2020/061131261.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Eclipse的概述使用-掌握"><a href="#1-Eclipse的概述使用-掌握" class="headerlink" title="1:Eclipse的概述使用(掌握)"></a>1:Eclipse的概述使用(掌握)</h2><pre><code>请参照ppt和课堂练习.txt</code></pre><h2 id="2-API的概述-了解"><a href="#2-API的概述-了解" class="headerlink" title="2:API的概述(了解)"></a>2:API的概述(了解)</h2><h3 id="1-应用程序编程接口。"><a href="#1-应用程序编程接口。" class="headerlink" title="(1)应用程序编程接口。"></a>(1)应用程序编程接口。</h3><h3 id="2-就是JDK提供给我们的一些提高编程效率的java类。"><a href="#2-就是JDK提供给我们的一些提高编程效率的java类。" class="headerlink" title="(2)就是JDK提供给我们的一些提高编程效率的java类。"></a>(2)就是JDK提供给我们的一些提高编程效率的java类。</h3><h2 id="3-Object类-掌握"><a href="#3-Object类-掌握" class="headerlink" title="3:Object类(掌握)"></a>3:Object类(掌握)</h2><h3 id="1-Object是类层次结构的根类，所有的类都直接或者间接的继承自Object类。"><a href="#1-Object是类层次结构的根类，所有的类都直接或者间接的继承自Object类。" class="headerlink" title="(1)Object是类层次结构的根类，所有的类都直接或者间接的继承自Object类。"></a>(1)Object是类层次结构的根类，所有的类都直接或者间接的继承自Object类。</h3><h3 id="2-Object类的构造方法有一个，并且是无参构造"><a href="#2-Object类的构造方法有一个，并且是无参构造" class="headerlink" title="(2)Object类的构造方法有一个，并且是无参构造"></a>(2)Object类的构造方法有一个，并且是无参构造</h3><pre><code>    这其实就是理解当时我们说过，子类构造方法默认访问父类的构造是无参构造</code></pre><h3 id="3-要掌握的方法："><a href="#3-要掌握的方法：" class="headerlink" title="(3)要掌握的方法："></a>(3)要掌握的方法：</h3><h4 id="A-toString"><a href="#A-toString" class="headerlink" title="A:toString()"></a>A:toString()</h4><pre><code>        返回对象的字符串表示，默认是由类的全路径+&#39;@&#39;+哈希值的十六进制表示。        这个表示其实是没有意义的，一般子类都会重写该方法。        如何重写呢?过程我也讲解过了，基本上就是要求信息简单明了。        但是最终还是自动生成。</code></pre><h4 id="B-equals"><a href="#B-equals" class="headerlink" title="B:equals()"></a>B:equals()</h4><pre><code>        比较两个对象是否相同。默认情况下，比较的是地址值是否相同。        而比较地址值是没有意义的，所以，一般子类也会重写该方法。        重写过程，我也详细的讲解和分析了。        但是最终还是自动生成。</code></pre><h3 id="4-要了解的方法："><a href="#4-要了解的方法：" class="headerlink" title="(4)要了解的方法："></a>(4)要了解的方法：</h3><h4 id="A-hashCode"><a href="#A-hashCode" class="headerlink" title="A:hashCode()"></a>A:hashCode()</h4><pre><code>        返回对象的哈希值。不是实际地址值，可以理解为地址值。</code></pre><h4 id="B-getClass"><a href="#B-getClass" class="headerlink" title="B:getClass()"></a>B:getClass()</h4><pre><code>        返回对象的字节码文件对象，反射中我们会详细讲解    </code></pre><h4 id="C-finalize"><a href="#C-finalize" class="headerlink" title="C:finalize()"></a>C:finalize()</h4><pre><code>        用于垃圾回收，在不确定的时间</code></pre><h4 id="D-clone"><a href="#D-clone" class="headerlink" title="D:clone()"></a>D:clone()</h4><pre><code>        可以实现对象的克隆，包括成员变量的数据复制，但是它和两个引用指向同一个对象是有区别的。</code></pre><h3 id="5-两个注意问题；"><a href="#5-两个注意问题；" class="headerlink" title="(5)两个注意问题；"></a>(5)两个注意问题；</h3><h4 id="A-直接输出一个对象名称，其实默认调用了该对象的toString-方法。"><a href="#A-直接输出一个对象名称，其实默认调用了该对象的toString-方法。" class="headerlink" title="A:直接输出一个对象名称，其实默认调用了该对象的toString()方法。"></a>A:直接输出一个对象名称，其实默认调用了该对象的toString()方法。</h4><h4 id="B-面试题"><a href="#B-面试题" class="headerlink" title="B:面试题"></a>B:面试题</h4><pre><code>        ==和equals()的区别?        A:==            基本类型：比较的是值是否相同            引用类型：比较的是地址值是否相同        B:equals()            只能比较引用类型。默认情况下，比较的是地址值是否相同。            但是，我们可以根据自己的需要重写该方法。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day10</title>
      <link href="/2020/061047836.html"/>
      <url>/2020/061047836.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-形式参数和返回值的问题-理解"><a href="#1-形式参数和返回值的问题-理解" class="headerlink" title="1:形式参数和返回值的问题(理解)"></a>1:形式参数和返回值的问题(理解)</h2><h3 id="1-形式参数："><a href="#1-形式参数：" class="headerlink" title="(1)形式参数："></a>(1)形式参数：</h3><pre><code>    类名：需要该类的对象    抽象类名：需要该类的子类对象    接口名：需要该接口的实现类对象</code></pre><h3 id="2-返回值类型："><a href="#2-返回值类型：" class="headerlink" title="(2)返回值类型："></a>(2)返回值类型：</h3><pre><code>    类名：返回的是该类的对象    抽象类名：返回的是该类的子类对象    接口名：返回的是该接口的实现类的对象</code></pre><h3 id="3-链式编程"><a href="#3-链式编程" class="headerlink" title="(3)链式编程"></a>(3)链式编程</h3><pre><code>    对象.方法1().方法2().......方法n();    这种用法：其实在方法1()调用完毕后，应该一个对象；              方法2()调用完毕后，应该返回一个对象。              方法n()调用完毕后，可能是对象，也可以不是对象。</code></pre><h2 id="2-包-理解"><a href="#2-包-理解" class="headerlink" title="2:包(理解)"></a>2:包(理解)</h2><h3 id="1-其实就是文件夹"><a href="#1-其实就是文件夹" class="headerlink" title="(1)其实就是文件夹"></a>(1)其实就是文件夹</h3><h3 id="2-作用："><a href="#2-作用：" class="headerlink" title="(2)作用："></a>(2)作用：</h3><pre><code>    A:区分同名的类    B:对类进行分类管理        a:按照功能分        b:按照模块分</code></pre><h3 id="3-包的定义-掌握"><a href="#3-包的定义-掌握" class="headerlink" title="(3)包的定义(掌握)"></a>(3)包的定义(掌握)</h3><pre><code>    package 包名;    多级包用.分开。</code></pre><h3 id="4-注意事项：-掌握"><a href="#4-注意事项：-掌握" class="headerlink" title="(4)注意事项：(掌握)"></a>(4)注意事项：(掌握)</h3><pre><code>    A:package语句必须在文件中的第一条有效语句    B:在一个java文件中，只能有一个package    C:如果没有package，默认就是无包名</code></pre><h3 id="5-带包的编译和运行"><a href="#5-带包的编译和运行" class="headerlink" title="(5)带包的编译和运行"></a>(5)带包的编译和运行</h3><pre><code>    A:手动式    B:自动式(掌握)        javac -d . HelloWorld.java</code></pre><h2 id="3-导包-掌握"><a href="#3-导包-掌握" class="headerlink" title="3:导包(掌握)"></a>3:导包(掌握)</h2><h3 id="1-我们多次使用一个带包的类，非常的麻烦，这个时候，Java就提供了一个关键字import。"><a href="#1-我们多次使用一个带包的类，非常的麻烦，这个时候，Java就提供了一个关键字import。" class="headerlink" title="(1)我们多次使用一个带包的类，非常的麻烦，这个时候，Java就提供了一个关键字import。"></a>(1)我们多次使用一个带包的类，非常的麻烦，这个时候，Java就提供了一个关键字import。</h3><h3 id="2-格式："><a href="#2-格式：" class="headerlink" title="(2)格式："></a>(2)格式：</h3><pre><code>    import 包名...类名;    另一种：        import 包名...*;(不建议)</code></pre><h3 id="3-package-import-class的顺序"><a href="#3-package-import-class的顺序" class="headerlink" title="(3)package,import,class的顺序"></a>(3)package,import,class的顺序</h3><pre><code>    package &gt; import &gt; class</code></pre><h2 id="4-权限修饰符-掌握"><a href="#4-权限修饰符-掌握" class="headerlink" title="4:权限修饰符(掌握)"></a>4:权限修饰符(掌握)</h2><h3 id="1-权限修饰符"><a href="#1-权限修饰符" class="headerlink" title="(1)权限修饰符"></a>(1)权限修饰符</h3><pre><code>                本类    同一个包下    不同包下的子类    不同包下的无关类    private        Y    默认        Y        Y    protected    Y        Y            Y    public        Y        Y            Y                Y</code></pre><h3 id="2-这四种权限修饰符在任意时刻只能出现一种。"><a href="#2-这四种权限修饰符在任意时刻只能出现一种。" class="headerlink" title="(2)这四种权限修饰符在任意时刻只能出现一种。"></a>(2)这四种权限修饰符在任意时刻只能出现一种。</h3><pre><code>    public class Demo {}        </code></pre><h2 id="5-常见的修饰符-理解"><a href="#5-常见的修饰符-理解" class="headerlink" title="5:常见的修饰符(理解)"></a>5:常见的修饰符(理解)</h2><h3 id="1-分类："><a href="#1-分类：" class="headerlink" title="(1)分类："></a>(1)分类：</h3><pre><code>    权限修饰符：private,默认,protected,public    状态修饰符：static,final    抽象修饰符：abstract</code></pre><h3 id="2-常见的类及其组成的修饰"><a href="#2-常见的类及其组成的修饰" class="headerlink" title="(2)常见的类及其组成的修饰"></a>(2)常见的类及其组成的修饰</h3><pre><code>    类：        默认,public,final,abstract        常用的：public    成员变量：        private,默认,protected,public,static,final        常用的：private    构造方法：        private,默认,protected,public        常用的：public    成员方法：        private,默认,protected,public,static,final,abstract        常用的：public</code></pre><h3 id="3-另外比较常见的："><a href="#3-另外比较常见的：" class="headerlink" title="(3)另外比较常见的："></a>(3)另外比较常见的：</h3><pre><code>    public static final int X = 10;    public static void show() {}    public final void show() {}    public abstract void show();</code></pre><h2 id="6-内部类-理解"><a href="#6-内部类-理解" class="headerlink" title="6:内部类(理解)"></a>6:内部类(理解)</h2><h3 id="1-把类定义在另一个类的内部，该类就被称为内部类。"><a href="#1-把类定义在另一个类的内部，该类就被称为内部类。" class="headerlink" title="(1)把类定义在另一个类的内部，该类就被称为内部类。"></a>(1)把类定义在另一个类的内部，该类就被称为内部类。</h3><pre><code>    举例：把类B定义在类A中，类B就被称为内部类。</code></pre><h3 id="2-内部类的访问规则"><a href="#2-内部类的访问规则" class="headerlink" title="(2)内部类的访问规则"></a>(2)内部类的访问规则</h3><pre><code>    A:可以直接访问外部类的成员，包括私有    B:外部类要想访问内部类成员，必须创建对象</code></pre><h3 id="3-内部类的分类"><a href="#3-内部类的分类" class="headerlink" title="(3)内部类的分类"></a>(3)内部类的分类</h3><pre><code>    A:成员内部类    B:局部内部类</code></pre><h3 id="4-成员内部类"><a href="#4-成员内部类" class="headerlink" title="(4)成员内部类"></a>(4)成员内部类</h3><pre><code>    A:private 为了数据的安全性    B:static 为了访问的方便性    成员内部类不是静态的：        外部类名.内部类名 对象名 = new 外部类名.new 内部类名();    成员内部类是静态的：        外部类名.内部类名 对象名 = new 外部类名.内部类名();</code></pre><h3 id="5-成员内部类的面试题-填空"><a href="#5-成员内部类的面试题-填空" class="headerlink" title="(5)成员内部类的面试题(填空)"></a>(5)成员内部类的面试题(填空)</h3><pre><code>    30,20,10    class Outer {        public int num = 10;        class Inner {            public int num = 20;            public viod show() {                int num  = 30;                System.out.println(num);                System.out.println(this.num);                System.out.println(Outer.this.num);            }        }    }</code></pre><h3 id="6-局部内部类"><a href="#6-局部内部类" class="headerlink" title="(6)局部内部类"></a>(6)局部内部类</h3><pre><code>    A:局部内部类访问局部变量必须加final修饰。    B:为什么呢?        因为局部变量使用完毕就消失，而堆内存的数据并不会立即消失。        所以，堆内存还是用该变量，而改变量已经没有了。        为了让该值还存在，就加final修饰。        通过反编译工具我们看到了，加入final后，堆内存直接存储的是值，而不是变量名。</code></pre><h3 id="7-匿名内部类-掌握"><a href="#7-匿名内部类-掌握" class="headerlink" title="(7)匿名内部类(掌握)"></a>(7)匿名内部类(掌握)</h3><pre><code>    A:是局部内部类的简化形式    B:前提        存在一个类或者接口    C:格式:        new 类名或者接口名() {            重写方法;        }    D:本质：        其实是继承该类或者实现接口的子类匿名对象</code></pre><h3 id="8-匿名内部类在开发中的使用"><a href="#8-匿名内部类在开发中的使用" class="headerlink" title="(8)匿名内部类在开发中的使用"></a>(8)匿名内部类在开发中的使用</h3><pre><code>    我们在开发的时候，会看到抽象类，或者接口作为参数。    而这个时候，我们知道实际需要的是一个子类对象。    如果该方法仅仅调用一次，我们就可以使用匿名内部类的格式简化。    interface Person {        public abstract void study();    }    class PersonDemo {        public void method(Person p) {            p.study();        }    }    class PersonTest {        public static void main(String[] args) {            PersonDemo pd = new PersonDemo();            pd.method(new Person() {                public void study() {                    System.out.println(&quot;好好学习，天天向上&quot;);                }            });        }    }</code></pre><h3 id="9-匿名内部类的面试题-补齐代码"><a href="#9-匿名内部类的面试题-补齐代码" class="headerlink" title="(9)匿名内部类的面试题(补齐代码)"></a>(9)匿名内部类的面试题(补齐代码)</h3><pre><code>    interface Inter {        void show();    }    class Outer {        //补齐代码        public static Inter method() {            return new Inter() {                public void show() {                    System.out.println(&quot;HelloWorld&quot;);                }                };        }    }    class OuterDemo {        public static void main(String[] args) {            Outer.method().show(); //&quot;HelloWorld&quot;        }    }</code></pre><hr><p>1:形式参数和返回值问题   </p><pre><code>形式参数    基本类型    类名：需要该类的对象    引用类型    抽象类名：需要改类的子类对象                接口名：需要该接口的实现类对象返回值类型    基本类型    类名：返回的是该类的对象    引用类型    抽象类名：返回的是该类的子类对象                接口名：返回的是该接口的实现类的对象</code></pre><p>2:包的定义及注意事项  </p><pre><code>定义：package 报名;注意事项    A：package语句必须在文件中的定义一条有效语句            B：在一个Java文件中，只能有一个package            C：如果没有package，默认就是无包名</code></pre><p>3:导包及注意事项  </p><pre><code>（1）我们多次使用一个带包的类，非常麻烦，这个时候，Java就提供了一个关键字import（2）格式：            import 包名...类名；（3）package ，import，class的顺序        package&gt;import&gt;class</code></pre><p>4:四种权限修饰符及其特点  </p><pre><code>(1)权限修饰符                本类    同一个包下    不同包下的子类    不同包下的无关类    private        Y    默认        Y        Y    protected    Y        Y            Y    public        Y        Y            Y                Y(2)这四种权限修饰符在任意时刻只能出现一种。    public class Demo {}        </code></pre><p>5:常见的修饰符及组合  </p><pre><code>(1)分类：            权限修饰符：private,默认，protected，public            状态修饰符：static,final            抽象修饰符：abstract(2)常见的类及其组成的修饰    类：        默认,public,final,abstract        常用的：public    成员变量：        private,默认,protected,public,static,final        常用的：private    构造方法：        private,默认,protected,public        常用的：public    成员方法：        private,默认,protected,public,static,final,abstract        常用的：public(3)另外比较常见的：    public static final int X = 10;    public static void show() {}    public final void show() {}    public abstract void show();        </code></pre><p>6:内部类的概述及访问特点  </p><pre><code>(1)把类定义在另一个类的内部，该类就被称为内部类。    举例：把类B定义在类A中，类B就被称为内部类。(2)内部类的访问规则    A:可以直接访问外部类的成员，包括私有    B:外部类要想访问内部类成员，必须创建对象</code></pre><p>7:内部类的分类  </p><pre><code>(1)内部类的分类    A:成员内部类    B:局部内部类(2)成员内部类    A:private 为了数据的安全性    B:static 为了访问的方便性    成员内部类不是静态的：        外部类名.内部类名 对象名 = new 外部类名.new 内部类名();    成员内部类是静态的：        外部类名.内部类名 对象名 = new 外部类名.内部类名();(3)成员内部类的面试题(填空)    30,20,10    class Outer {        public int num = 10;        class Inner {            public int num = 20;            public viod show() {                int num  = 30;                System.out.println(num);                System.out.println(this.num);                System.out.println(Outer.this.num);            }        }    }(4)局部内部类    A:局部内部类访问局部变量必须加final修饰。    B:为什么呢?        因为局部变量使用完毕就消失，而堆内存的数据并不会立即消失。        所以，堆内存还是用该变量，而改变量已经没有了。        为了让该值还存在，就加final修饰。        通过反编译工具我们看到了，加入final后，堆内存直接存储的是值，而不是变量名。(5)匿名内部类(掌握)    A:是局部内部类的简化形式    B:前提        存在一个类或者接口    C:格式:        new 类名或者接口名() {            重写方法;        }    D:本质：        其实是继承该类或者实现接口的子类匿名对象</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day09</title>
      <link href="/2020/060911293.html"/>
      <url>/2020/060911293.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-final关键字-掌握"><a href="#1-final关键字-掌握" class="headerlink" title="1:final关键字(掌握)"></a>1:final关键字(掌握)</h2><h3 id="1-是最终的意思，可以修饰类，方法，变量。"><a href="#1-是最终的意思，可以修饰类，方法，变量。" class="headerlink" title="(1)是最终的意思，可以修饰类，方法，变量。"></a>(1)是最终的意思，可以修饰类，方法，变量。</h3><h3 id="2-特点："><a href="#2-特点：" class="headerlink" title="(2)特点："></a>(2)特点：</h3><pre><code>    A:它修饰的类，不能被继承。    B:它修饰的方法，不能被重写。    C:它修饰的变量，是一个常量。</code></pre><h3 id="3-面试相关："><a href="#3-面试相关：" class="headerlink" title="(3)面试相关："></a>(3)面试相关：</h3><pre><code>    A:局部变量        a:基本类型 值不能发生改变        b:引用类型 地址值不能发生改变，但是对象的内容是可以改变的    B:初始化时机        a:只能初始化一次。        b:常见的给值            定义的时候。(推荐)            构造方法中。</code></pre><h2 id="2-多态-掌握"><a href="#2-多态-掌握" class="headerlink" title="2:多态(掌握)"></a>2:多态(掌握)</h2><h3 id="1-同一个对象在不同时刻体现出来的不同状态。"><a href="#1-同一个对象在不同时刻体现出来的不同状态。" class="headerlink" title="(1)同一个对象在不同时刻体现出来的不同状态。"></a>(1)同一个对象在不同时刻体现出来的不同状态。</h3><h3 id="2-多态的前提："><a href="#2-多态的前提：" class="headerlink" title="(2)多态的前提："></a>(2)多态的前提：</h3><pre><code>    A:有继承或者实现关系。    B:有方法重写。    C:有父类或者父接口引用指向子类对象。    多态的分类：        a:具体类多态            class Fu {}            class Zi extends Fu {}            Fu f = new Zi();        b:抽象类多态            abstract class Fu {}            class Zi extends Fu {}            Fu f = new Zi();        c:接口多态            interface Fu {}            class Zi implements Fu {}            Fu f = new Zi();</code></pre><h3 id="3-多态中的成员访问特点"><a href="#3-多态中的成员访问特点" class="headerlink" title="(3)多态中的成员访问特点"></a>(3)多态中的成员访问特点</h3><pre><code>    A:成员变量        编译看左边，运行看左边    B:构造方法        子类的构造都会默认访问父类构造    C:成员方法        编译看左边，运行看右边    D:静态方法        编译看左边，运行看左边    为什么?        因为成员方法有重写。</code></pre><h3 id="4-多态的好处："><a href="#4-多态的好处：" class="headerlink" title="(4)多态的好处："></a>(4)多态的好处：</h3><pre><code>    A:提高代码的维护性(继承体现)    B:提高代码的扩展性(多态体现)</code></pre><h3 id="5-多态的弊端："><a href="#5-多态的弊端：" class="headerlink" title="(5)多态的弊端："></a>(5)多态的弊端：</h3><pre><code>    父不能使用子的特有功能。    现象：        子可以当作父使用，父不能当作子使用。</code></pre><h3 id="6-多态中的转型"><a href="#6-多态中的转型" class="headerlink" title="(6)多态中的转型"></a>(6)多态中的转型</h3><pre><code>    A:向上转型        从子到父    B:向下转型        从父到子</code></pre><h3 id="7-孔子装爹的案例帮助大家理解多态"><a href="#7-孔子装爹的案例帮助大家理解多态" class="headerlink" title="(7)孔子装爹的案例帮助大家理解多态"></a>(7)孔子装爹的案例帮助大家理解多态</h3><h3 id="8-多态的练习"><a href="#8-多态的练习" class="headerlink" title="(8)多态的练习"></a>(8)多态的练习</h3><pre><code>    A:猫狗案例    B:老师和学生案例</code></pre><h2 id="3-抽象类-掌握"><a href="#3-抽象类-掌握" class="headerlink" title="3:抽象类(掌握)"></a>3:抽象类(掌握)</h2><h3 id="1-把多个共性的东西提取到一个类中，这是继承的做法。"><a href="#1-把多个共性的东西提取到一个类中，这是继承的做法。" class="headerlink" title="(1)把多个共性的东西提取到一个类中，这是继承的做法。"></a>(1)把多个共性的东西提取到一个类中，这是继承的做法。</h3><pre><code>   但是呢，这多个共性的东西，在有些时候，方法声明一样，但是方法体。   也就是说，方法声明一样，但是每个具体的对象在具体实现的时候内容不一样。   所以，我们在定义这些共性的方法的时候，就不能给出具体的方法体。   而一个没有具体的方法体的方法是抽象的方法。   在一个类中如果有抽象方法，该类必须定义为抽象类。</code></pre><h3 id="2-抽象类的特点"><a href="#2-抽象类的特点" class="headerlink" title="(2)抽象类的特点"></a>(2)抽象类的特点</h3><pre><code>    A:抽象类和抽象方法必须用关键字abstract修饰    B:抽象类中不一定有抽象方法,但是有抽象方法的类一定是抽象类    C:抽象类不能实例化    D:抽象类的子类        a:是一个抽象类。        b:是一个具体类。这个类必须重写抽象类中的所有抽象方法。</code></pre><h3 id="3-抽象类的成员特点："><a href="#3-抽象类的成员特点：" class="headerlink" title="(3)抽象类的成员特点："></a>(3)抽象类的成员特点：</h3><pre><code>    A:成员变量        有变量，有常量    B:构造方法        有构造方法    C:成员方法        有抽象，有非抽象</code></pre><h3 id="4-抽象类的练习"><a href="#4-抽象类的练习" class="headerlink" title="(4)抽象类的练习"></a>(4)抽象类的练习</h3><pre><code>    A:猫狗案例练习    B:老师案例练习    C:学生案例练习    D:员工案例练习</code></pre><h3 id="5-抽象类的几个小问题"><a href="#5-抽象类的几个小问题" class="headerlink" title="(5)抽象类的几个小问题"></a>(5)抽象类的几个小问题</h3><pre><code>    A:抽象类有构造方法，不能实例化，那么构造方法有什么用?        用于子类访问父类数据的初始化    B:一个类如果没有抽象方法,却定义为了抽象类，有什么用?        为了不让创建对象    C:abstract不能和哪些关键字共存        a:final    冲突        b:private 冲突        c:static 无意义</code></pre><h2 id="4-接口-掌握"><a href="#4-接口-掌握" class="headerlink" title="4:接口(掌握)"></a>4:接口(掌握)</h2><h3 id="1-回顾猫狗案例，它们仅仅提供一些基本功能。"><a href="#1-回顾猫狗案例，它们仅仅提供一些基本功能。" class="headerlink" title="(1)回顾猫狗案例，它们仅仅提供一些基本功能。"></a>(1)回顾猫狗案例，它们仅仅提供一些基本功能。</h3><pre><code>   比如：猫钻火圈，狗跳高等功能，不是动物本身就具备的，   是在后面的培养中训练出来的，这种额外的功能，java提供了接口表示。</code></pre><h3 id="2-接口的特点："><a href="#2-接口的特点：" class="headerlink" title="(2)接口的特点："></a>(2)接口的特点：</h3><pre><code>    A:接口用关键字interface修饰        interface 接口名 {}    B:类实现接口用implements修饰        class 类名 implements 接口名 {}    C:接口不能实例化    D:接口的实现类        a:是一个抽象类。        b:是一个具体类，这个类必须重写接口中的所有抽象方法。</code></pre><h3 id="3-接口的成员特点："><a href="#3-接口的成员特点：" class="headerlink" title="(3)接口的成员特点："></a>(3)接口的成员特点：</h3><pre><code>    A:成员变量        只能是常量        默认修饰符：public static final    B:构造方法        没有构造方法    C:成员方法        只能是抽象的        默认修饰符：public abstract</code></pre><h3 id="4-类与类-类与接口-接口与接口"><a href="#4-类与类-类与接口-接口与接口" class="headerlink" title="(4)类与类,类与接口,接口与接口"></a>(4)类与类,类与接口,接口与接口</h3><pre><code>    A:类与类        继承关系，只能单继承，可以多层继承    B:类与接口        实现关系，可以单实现，也可以多实现。        还可以在继承一个类的同时，实现多个接口    C:接口与接口        继承关系，可以单继承，也可以多继承</code></pre><h3 id="5-抽象类和接口的区别-自己补齐"><a href="#5-抽象类和接口的区别-自己补齐" class="headerlink" title="(5)抽象类和接口的区别(自己补齐)?"></a>(5)抽象类和接口的区别(自己补齐)?</h3><pre><code>    A:成员区别        抽象类：        接口：    B:关系区别:        类与类：        类与接口：        接口与接口：    C:设计理念不同        抽象类：is a，抽象类中定义的是共性功能。        接口：like a，接口中定义的是扩展功能。</code></pre><h3 id="6-练习："><a href="#6-练习：" class="headerlink" title="(6)练习："></a>(6)练习：</h3><pre><code>    A:猫狗案例，加入跳高功能    B:老师和学生案例，加入抽烟功能0</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day08</title>
      <link href="/2020/060860636.html"/>
      <url>/2020/060860636.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-如何制作帮助文档-了解"><a href="#1-如何制作帮助文档-了解" class="headerlink" title="1:如何制作帮助文档(了解)"></a>1:如何制作帮助文档(了解)</h2><h3 id="1-写一个类"><a href="#1-写一个类" class="headerlink" title="(1)写一个类"></a>(1)写一个类</h3><h3 id="2-加入文档注释"><a href="#2-加入文档注释" class="headerlink" title="(2)加入文档注释"></a>(2)加入文档注释</h3><h3 id="3-通过javadoc工具生成即可"><a href="#3-通过javadoc工具生成即可" class="headerlink" title="(3)通过javadoc工具生成即可"></a>(3)通过javadoc工具生成即可</h3><pre><code>    javadoc -d 目录 -author -version ArrayTool.java</code></pre><h2 id="2-通过JDK提供的API学习了Math类-掌握"><a href="#2-通过JDK提供的API学习了Math类-掌握" class="headerlink" title="2:通过JDK提供的API学习了Math类(掌握)"></a>2:通过JDK提供的API学习了Math类(掌握)</h2><h3 id="1-API-Application-Programming-Interface"><a href="#1-API-Application-Programming-Interface" class="headerlink" title="(1)API(Application Programming Interface)"></a>(1)API(Application Programming Interface)</h3><pre><code>    应用程序编程接口(帮助文档)</code></pre><h3 id="2-如何使用呢"><a href="#2-如何使用呢" class="headerlink" title="(2)如何使用呢?"></a>(2)如何使用呢?</h3><pre><code>    请参照        day08\code\02_如何使用JDK提供的帮助文档\如何使用帮助文档.txt</code></pre><h3 id="3-Math类"><a href="#3-Math类" class="headerlink" title="(3)Math类"></a>(3)Math类</h3><pre><code>    A:是针对数学进行操作的类    B:没有构造方法，因为它的成员都是静态的    C:产生随机数        public static double random(): [0.0,1.0)    D:如何产生一个1-100之间的随机数        int number = (int)(Math.random()*100)+1;    E:猜数字小游戏</code></pre><h2 id="3-代码块-理解"><a href="#3-代码块-理解" class="headerlink" title="3:代码块(理解)"></a>3:代码块(理解)</h2><h3 id="1-用-括起来的代码。"><a href="#1-用-括起来的代码。" class="headerlink" title="(1)用{}括起来的代码。"></a>(1)用{}括起来的代码。</h3><h3 id="2-分类："><a href="#2-分类：" class="headerlink" title="(2)分类："></a>(2)分类：</h3><pre><code>    A:局部代码块        用于限定变量的生命周期，及早释放，提高内存利用率。    B:构造代码块        把多个构造方法中相同的代码可以放到这里，每个构造方法执行前，首先执行构造代码块。    C:静态代码块        对类的数据进行初始化，仅仅只执行一次。</code></pre><h3 id="3-静态代码块-构造代码块-构造方法的顺序问题"><a href="#3-静态代码块-构造代码块-构造方法的顺序问题" class="headerlink" title="(3)静态代码块,构造代码块,构造方法的顺序问题?"></a>(3)静态代码块,构造代码块,构造方法的顺序问题?</h3><pre><code>    静态代码块 &gt; 构造代码块 &gt; 构造方法</code></pre><h2 id="4-继承-掌握"><a href="#4-继承-掌握" class="headerlink" title="4:继承(掌握)"></a>4:继承(掌握)</h2><h3 id="1-把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该独立的类产生一个关系，"><a href="#1-把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该独立的类产生一个关系，" class="headerlink" title="(1)把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该独立的类产生一个关系，"></a>(1)把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该独立的类产生一个关系，</h3><pre><code>   这多个类就具备了这些内容。这个关系叫继承。</code></pre><h3 id="2-Java中如何表示继承呢-格式是什么呢"><a href="#2-Java中如何表示继承呢-格式是什么呢" class="headerlink" title="(2)Java中如何表示继承呢?格式是什么呢?"></a>(2)Java中如何表示继承呢?格式是什么呢?</h3><pre><code>    A:用关键字extends表示    B:格式：        class 子类名 extends 父类名 {}</code></pre><h3 id="3-继承的好处："><a href="#3-继承的好处：" class="headerlink" title="(3)继承的好处："></a>(3)继承的好处：</h3><pre><code>    A:提高了代码的复用性    B:提高了代码的维护性    C:让类与类产生了一个关系，是多态的前提</code></pre><h3 id="4-继承的弊端："><a href="#4-继承的弊端：" class="headerlink" title="(4)继承的弊端："></a>(4)继承的弊端：</h3><pre><code>    A:让类的耦合性增强。这样某个类的改变，就会影响其他和该类相关的类。        原则：低耦合，高内聚。        耦合：类与类的关系        内聚：自己完成某件事情的能力    B:打破了封装性</code></pre><h3 id="5-Java中继承的特点"><a href="#5-Java中继承的特点" class="headerlink" title="(5)Java中继承的特点"></a>(5)Java中继承的特点</h3><pre><code>    A:Java中类只支持单继承    B:Java中可以多层(重)继承(继承体系)</code></pre><h3 id="6-继承的注意事项："><a href="#6-继承的注意事项：" class="headerlink" title="(6)继承的注意事项："></a>(6)继承的注意事项：</h3><pre><code>    A:子类不能继承父类的私有成员    B:子类不能继承父类的构造方法，但是可以通过super去访问    C:不要为了部分功能而去继承</code></pre><h3 id="7-什么时候使用继承呢"><a href="#7-什么时候使用继承呢" class="headerlink" title="(7)什么时候使用继承呢?"></a>(7)什么时候使用继承呢?</h3><pre><code>    A:继承体现的是：is a的关系。    B:采用假设法</code></pre><h3 id="8-Java继承中的成员关系"><a href="#8-Java继承中的成员关系" class="headerlink" title="(8)Java继承中的成员关系"></a>(8)Java继承中的成员关系</h3><pre><code>    A:成员变量        a:子类的成员变量名称和父类中的成员变量名称不一样，这个太简单        b:子类的成员变量名称和父类中的成员变量名称一样，这个怎么访问呢?            子类的方法访问变量的查找顺序：                在子类方法的局部范围找，有就使用。                在子类的成员范围找，有就使用。                在父类的成员范围找，有就使用。                找不到，就报错。    B:构造方法        a:子类的构造方法默认会去访问父类的无参构造方法            是为了子类访问父类数据的初始化        b:父类中如果没有无参构造方法，怎么办?            子类通过super去明确调用带参构造            子类通过this调用本身的其他构造，但是一定会有一个去访问了父类的构造            让父类提供无参构造    C:成员方法        a:子类的成员方法和父类中的成员方法名称不一样，这个太简单        b:子类的成员方法和父类中的成员方法名称一样，这个怎么访问呢?            通过子类对象访问一个方法的查找顺序：                在子类中找，有就使用                在父类中找，有就使用                找不到，就报错</code></pre><h3 id="9-两个面试题："><a href="#9-两个面试题：" class="headerlink" title="(9)两个面试题："></a>(9)两个面试题：</h3><pre><code>    A:Override和Overload的区别?Overload是否可以改变返回值类型?    B:this和super的区别和各自的作用?</code></pre><h3 id="10-数据初始化的面试题"><a href="#10-数据初始化的面试题" class="headerlink" title="(10)数据初始化的面试题"></a>(10)数据初始化的面试题</h3><pre><code>    A:一个类的初始化过程    B:子父类的构造执行过程    C:分层初始化</code></pre><h3 id="11-案例："><a href="#11-案例：" class="headerlink" title="(11)案例："></a>(11)案例：</h3><pre><code>    A:学生和老师案例        继承前        继承后    B:猫狗案例的分析和实现</code></pre><p>1:代码块是什么?代码块的分类和各自特点?  </p><p>用{}括起来的代码。<br>分类：<br>A：局部代码块：用于限定变量的生命周期，及早释放，提高内存利用率<br>B：构造代码块：把多个构造方法中相同的代码可以放到这里，每个构造方法执行前，首先执行构造代码块。<br>C：静态大妈快：对类的数据进行初始化，仅仅只执行一次。<br>静态代码块&gt;构造代码块&gt;局部代码块</p><p>2:静态代码块,构造代码块,构造方法的执行流程?    </p><p>3:继承概述  </p><p>把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该独立的类产生一个关系，这多个类就具备了这些内容，这个关系叫继承。</p><p>4:继承的好处  </p><p>A：提高了代码的复用性<br>B：提高了代码的维护性<br>C：让类与类产生了一个关系，是多态的前提</p><p>5:Java中继承的特点  </p><p>A：Java中类只支持单继承<br>B：Java中可以多层继承</p><p>6:Java中继承的注意事项?以及我们什么时候使用继承?  </p><p>A：子类不能继承父类的私有成员<br>B：子类不能继承父类的构造方法，但是可以通过super去访问<br>C：不要为了部分功能而去继承</p><p>A：继承体现的是： is a的关系<br>B：采用假设法</p><p>7:继承中的成员访问特点  </p><pre><code>A:成员变量    在子类方法中访问一个变量B:成员方法    在测试类中通过子类对象去访问一个方法</code></pre><p>8:继承中构造方法的执行流程?假如父类没有无参构造方法，子类应该怎么办?  </p><p>A：子类的构造方法默认会去访问父类的无参构造方法，是为了子类访问父类数据的初始化<br>B：            子类通过super去明确调用带参构造<br>    子类通过this调用本身的其他构造，但是一定会有一个去访问了父类的构造<br>    让父类提供无参构造<br>9:面试题：  </p><pre><code>方法重写和方法重载的区别?方法重载能改变返回值类型吗?Overload （方法重载）同一个类中，出现的方法名相同，参数列表不同的现象Override    （方法重写）在子类中，出现和父类中一摸一样的方法声明的现象方法重载能改变返回值类型，因为它和返回值类型无关this关键字和super关键字分别代表什么?以及他们各自的使用场景和作用。    this：代表当前类的对象引用    super：代表父类存储空间的标识。（可以理解为父类的引用，通过这个东西可以访问父类的成员）</code></pre><p>10:继承案例练习  </p><p>11:猜数字小游戏练习。  </p><pre><code>通过API学习并使用Math类的random()方法。        </code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day07</title>
      <link href="/2020/060759548.html"/>
      <url>/2020/060759548.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-成员变量和局部变量的区别-理解"><a href="#1-成员变量和局部变量的区别-理解" class="headerlink" title="1:成员变量和局部变量的区别(理解)"></a>1:成员变量和局部变量的区别(理解)</h2><h3 id="1-在类中的位置不同"><a href="#1-在类中的位置不同" class="headerlink" title="(1)在类中的位置不同"></a>(1)在类中的位置不同</h3><pre><code>    成员变量：类中方法外    局部变量：方法定义中或者方法声明上</code></pre><h3 id="2-在内存中的位置不同"><a href="#2-在内存中的位置不同" class="headerlink" title="(2)在内存中的位置不同"></a>(2)在内存中的位置不同</h3><pre><code>    成员变量：在堆中    局部变量：在栈中</code></pre><h3 id="3-生命周期不同"><a href="#3-生命周期不同" class="headerlink" title="(3)生命周期不同"></a>(3)生命周期不同</h3><pre><code>    成员变量：随着对象的创建而存在，随着对象的消失而消失    局部变量：随着方法的调用而存在，随着方法的调用完毕而消失</code></pre><h3 id="4-初始化值不同"><a href="#4-初始化值不同" class="headerlink" title="(4)初始化值不同"></a>(4)初始化值不同</h3><pre><code>    成员变量：有默认值    局部变量：没有默认值，必须定义，赋值，然后才能使用</code></pre><h2 id="2-类作为形式参数的问题-理解"><a href="#2-类作为形式参数的问题-理解" class="headerlink" title="2:类作为形式参数的问题?(理解)"></a>2:类作为形式参数的问题?(理解)</h2><h3 id="1-如果你看到一个方法需要的参数是一个类名，就应该知道这里实际需要的是一个具体的对象。"><a href="#1-如果你看到一个方法需要的参数是一个类名，就应该知道这里实际需要的是一个具体的对象。" class="headerlink" title="(1)如果你看到一个方法需要的参数是一个类名，就应该知道这里实际需要的是一个具体的对象。"></a>(1)如果你看到一个方法需要的参数是一个类名，就应该知道这里实际需要的是一个具体的对象。</h3><h2 id="3-匿名对象-理解"><a href="#3-匿名对象-理解" class="headerlink" title="3:匿名对象(理解)"></a>3:匿名对象(理解)</h2><h3 id="1-没有名字的对象"><a href="#1-没有名字的对象" class="headerlink" title="(1)没有名字的对象"></a>(1)没有名字的对象</h3><h3 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="(2)应用场景"></a>(2)应用场景</h3><pre><code>    A:调用方法，仅仅只调用一次的时候。    b:可以作为实际参数传递。</code></pre><h2 id="4-封装-理解"><a href="#4-封装-理解" class="headerlink" title="4:封装(理解)"></a>4:封装(理解)</h2><h3 id="1-隐藏实现细节，提供公共的访问方式"><a href="#1-隐藏实现细节，提供公共的访问方式" class="headerlink" title="(1)隐藏实现细节，提供公共的访问方式"></a>(1)隐藏实现细节，提供公共的访问方式</h3><h3 id="2-好处："><a href="#2-好处：" class="headerlink" title="(2)好处："></a>(2)好处：</h3><pre><code>    A:隐藏实现细节，提供公共的访问方式    B:提高代码的复用性    C:提高代码的安全性</code></pre><h3 id="3-设计原则"><a href="#3-设计原则" class="headerlink" title="(3)设计原则"></a>(3)设计原则</h3><pre><code>    把不想让外界知道的实现细节给隐藏起来，提供公共的访问方式</code></pre><h3 id="4-private是封装的一种体现。"><a href="#4-private是封装的一种体现。" class="headerlink" title="(4)private是封装的一种体现。"></a>(4)private是封装的一种体现。</h3><pre><code>    封装：类，方法，private修饰成员变量</code></pre><h2 id="private关键字-掌握"><a href="#private关键字-掌握" class="headerlink" title=":private关键字(掌握)"></a>:private关键字(掌握)</h2><h3 id="1-私有的意义，可以修饰成员变量和成员方法"><a href="#1-私有的意义，可以修饰成员变量和成员方法" class="headerlink" title="(1)私有的意义，可以修饰成员变量和成员方法"></a>(1)私有的意义，可以修饰成员变量和成员方法</h3><h3 id="2-特点："><a href="#2-特点：" class="headerlink" title="(2)特点："></a>(2)特点：</h3><pre><code>    被private修饰的后的成员只能在本类中被访问</code></pre><h3 id="3-private的应用："><a href="#3-private的应用：" class="headerlink" title="(3)private的应用："></a>(3)private的应用：</h3><pre><code>    以后再写一个类的时候：        把所有的成员变量给private了        提供对应的getXxx()/setXxx()方法</code></pre><h2 id="6-this关键字-掌握"><a href="#6-this关键字-掌握" class="headerlink" title="6:this关键字(掌握)"></a>6:this关键字(掌握)</h2><h3 id="1-代表当前类的引用对象"><a href="#1-代表当前类的引用对象" class="headerlink" title="(1)代表当前类的引用对象"></a>(1)代表当前类的引用对象</h3><pre><code>    记住：哪个对象调用方法，该方法内部的this就代表那个对象</code></pre><h3 id="2-this的应用场景："><a href="#2-this的应用场景：" class="headerlink" title="(2)this的应用场景："></a>(2)this的应用场景：</h3><pre><code>    A:解决了局部变量隐藏成员变量的问题    B:其实this还有其他的应用，明天讲解。</code></pre><h2 id="7-构造方法-掌握"><a href="#7-构造方法-掌握" class="headerlink" title="7:构造方法(掌握)"></a>7:构造方法(掌握)</h2><h3 id="1-作用：用于对对象的数据进行初始化"><a href="#1-作用：用于对对象的数据进行初始化" class="headerlink" title="(1)作用：用于对对象的数据进行初始化"></a>(1)作用：用于对对象的数据进行初始化</h3><h3 id="2-格式："><a href="#2-格式：" class="headerlink" title="(2)格式："></a>(2)格式：</h3><pre><code>    A:方法名和类名相同    B:没有返回值类型，连void都不能有    C:没有返回值    思考题：构造方法中可不可以有return语句呢?    可以。而是我们写成这个样子就OK了：return;    其实，在任何的void类型的方法的最后你都可以写上：return;</code></pre><h3 id="3-构造方法的注意事项"><a href="#3-构造方法的注意事项" class="headerlink" title="(3)构造方法的注意事项"></a>(3)构造方法的注意事项</h3><pre><code>    A:如果我们没写构造方法，系统将提供一个默认的无参构造方法    B:如果我们给出了构造方法，系统将不再提供默认构造方法        如果这个时候，我们要使用无参构造方法，就必须自己给出。        推荐：永远手动自己给出无参构造方法。</code></pre><h3 id="4-给成员变量赋值的方式"><a href="#4-给成员变量赋值的方式" class="headerlink" title="(4)给成员变量赋值的方式"></a>(4)给成员变量赋值的方式</h3><pre><code>    A:setXxx()    B:带参构造方法</code></pre><h3 id="5-标准案例"><a href="#5-标准案例" class="headerlink" title="(5)标准案例"></a>(5)标准案例</h3><pre><code>    class Student {        private String name;        private int age;        public Student(){}        public Student(String name,int age) {            this.name = name;            this.age = age;        }        public String getName() {            return name;        }        public void setName(String name) {            this.name = name;        }        public int getAge() {            return age;        }        public void setAge(int age) {            this.age = age;        }    }    测试：    class StudentDemo {        public static void main(String[] args) {            //方式1            Student s1 = new Student();            s1.setName(&quot;林青霞&quot;);            s1.setAge(27);            System.out.println(s1.getName()+&quot;---&quot;+s1.getAge());            //方式2            Student s2 = new Student(&quot;刘意&quot;,30);            System.out.println(s2.getName()+&quot;---&quot;+s2.getAge());        }    }</code></pre><h2 id="8-代码：Student-s-new-Student-做了哪些事情-理解"><a href="#8-代码：Student-s-new-Student-做了哪些事情-理解" class="headerlink" title="8:代码：Student s = new Student();做了哪些事情?(理解)"></a>8:代码：Student s = new Student();做了哪些事情?(理解)</h2><h3 id="1-把Student-class文件加载到内存"><a href="#1-把Student-class文件加载到内存" class="headerlink" title="(1)把Student.class文件加载到内存"></a>(1)把Student.class文件加载到内存</h3><h3 id="2-在栈内存为s开辟空间"><a href="#2-在栈内存为s开辟空间" class="headerlink" title="(2)在栈内存为s开辟空间"></a>(2)在栈内存为s开辟空间</h3><h3 id="3-在堆内存为学生对象申请空间"><a href="#3-在堆内存为学生对象申请空间" class="headerlink" title="(3)在堆内存为学生对象申请空间"></a>(3)在堆内存为学生对象申请空间</h3><h3 id="4-给学生的成员变量进行默认初始化。null-0"><a href="#4-给学生的成员变量进行默认初始化。null-0" class="headerlink" title="(4)给学生的成员变量进行默认初始化。null,0"></a>(4)给学生的成员变量进行默认初始化。null,0</h3><h3 id="5-给学生的成员变量进行显示初始化。林青霞-27"><a href="#5-给学生的成员变量进行显示初始化。林青霞-27" class="headerlink" title="(5)给学生的成员变量进行显示初始化。林青霞,27"></a>(5)给学生的成员变量进行显示初始化。林青霞,27</h3><h3 id="6-通过构造方法给成员变量进行初始化。刘意-30"><a href="#6-通过构造方法给成员变量进行初始化。刘意-30" class="headerlink" title="(6)通过构造方法给成员变量进行初始化。刘意,30"></a>(6)通过构造方法给成员变量进行初始化。刘意,30</h3><h3 id="7-对象构造完毕，把地址赋值给s变量"><a href="#7-对象构造完毕，把地址赋值给s变量" class="headerlink" title="(7)对象构造完毕，把地址赋值给s变量"></a>(7)对象构造完毕，把地址赋值给s变量</h3><p>9:面向对象的练习题(掌握)  </p><h3 id="1-标准的手机类的定义和测试"><a href="#1-标准的手机类的定义和测试" class="headerlink" title="(1)标准的手机类的定义和测试"></a>(1)标准的手机类的定义和测试</h3><h3 id="2-Demo类有求和方法，Test类进行测试。"><a href="#2-Demo类有求和方法，Test类进行测试。" class="headerlink" title="(2)Demo类有求和方法，Test类进行测试。"></a>(2)Demo类有求和方法，Test类进行测试。</h3><pre><code>    什么时候定义成员变量?    当该变量是用来描述一个类的时候。</code></pre><h3 id="3-长方形案例"><a href="#3-长方形案例" class="headerlink" title="(3)长方形案例"></a>(3)长方形案例</h3><h3 id="4-员工案例"><a href="#4-员工案例" class="headerlink" title="(4)员工案例"></a>(4)员工案例</h3><h3 id="5-MyMath案例-自己提供加减乘除并测试"><a href="#5-MyMath案例-自己提供加减乘除并测试" class="headerlink" title="(5)MyMath案例(自己提供加减乘除并测试)"></a>(5)MyMath案例(自己提供加减乘除并测试)</h3><h2 id="10-static关键字-理解"><a href="#10-static关键字-理解" class="headerlink" title="10:static关键字(理解)"></a>10:static关键字(理解)</h2><h3 id="1-静态的意思。可以修饰成员变量和成员方法。"><a href="#1-静态的意思。可以修饰成员变量和成员方法。" class="headerlink" title="(1)静态的意思。可以修饰成员变量和成员方法。"></a>(1)静态的意思。可以修饰成员变量和成员方法。</h3><h3 id="2-静态的特点："><a href="#2-静态的特点：" class="headerlink" title="(2)静态的特点："></a>(2)静态的特点：</h3><pre><code>    A:随着类的加载而加载    B:优先与对象存在    C:被类的所有对象共享        这其实也是我们判断该不该使用静态的依据。        举例：饮水机和水杯的问题思考    D:可以通过类名调用        既可以通过对象名调用，也可以通过类名调用，建议通过类名调用。</code></pre><h3 id="3-静态的内存图"><a href="#3-静态的内存图" class="headerlink" title="(3)静态的内存图"></a>(3)静态的内存图</h3><pre><code>    静态的内容在方法区的静态区</code></pre><h3 id="4-静态的注意事项；"><a href="#4-静态的注意事项；" class="headerlink" title="(4)静态的注意事项；"></a>(4)静态的注意事项；</h3><pre><code>    A:在静态方法中没有this对象    B:静态只能访问静态(代码测试过)</code></pre><h3 id="5-静态变量和成员变量的区别"><a href="#5-静态变量和成员变量的区别" class="headerlink" title="(5)静态变量和成员变量的区别"></a>(5)静态变量和成员变量的区别</h3><pre><code>    A:所属不同        静态变量：属于类，类变量        成员变量：属于对象，对象变量，实例变量    B:内存位置不同        静态变量：方法区的静态区        成员变量：堆内存    C:生命周期不同        静态变量：静态变量是随着类的加载而加载，随着类的消失而消失        成员变量：成员变量是随着对象的创建而存在，随着对象的消失而消失    D:调用不同        静态变量：可以通过对象名调用，也可以通过类名调用        成员变量：只能通过对象名调用</code></pre><h3 id="6-main方法是静态的"><a href="#6-main方法是静态的" class="headerlink" title="(6)main方法是静态的"></a>(6)main方法是静态的</h3><pre><code>    public:权限最大    static:不用创建对象调用    void:返回值给jvm没有意义    main:就是一个常见的名称。    String[] args:可以接收数据，提供程序的灵活性        格式：java MainDemo hello world java              java MainDemo 10 20 30</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day06</title>
      <link href="/2020/060610333.html"/>
      <url>/2020/060610333.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-二维数组-理解"><a href="#1-二维数组-理解" class="headerlink" title="1:二维数组(理解)"></a>1:二维数组(理解)</h2><h3 id="1-元素是一维数组的数组。"><a href="#1-元素是一维数组的数组。" class="headerlink" title="(1)元素是一维数组的数组。"></a>(1)元素是一维数组的数组。</h3><h3 id="2-格式："><a href="#2-格式：" class="headerlink" title="(2)格式："></a>(2)格式：</h3><pre><code>    A:数据类型[][] 数组名 = new 数据类型[m][n];    B:数据类型[][] 数组名 = new 数据类型[m][];    C:数据类型[][] 数组名 = new 数据类型[][]{{...},{...},{...}};    D:数据类型[][] 数组名 = {{...},{...},{...}};</code></pre><h3 id="3-案例-掌握"><a href="#3-案例-掌握" class="headerlink" title="(3)案例(掌握):"></a>(3)案例(掌握):</h3><pre><code>    A:二维数组的遍历    B:二维数组的求和    C:杨辉三角形</code></pre><h2 id="2-两个思考题-理解"><a href="#2-两个思考题-理解" class="headerlink" title="2:两个思考题(理解)"></a>2:两个思考题(理解)</h2><h3 id="1-Java中的参数传递问题"><a href="#1-Java中的参数传递问题" class="headerlink" title="(1)Java中的参数传递问题"></a>(1)Java中的参数传递问题</h3><pre><code>    Java中只有值传递。    基本类型：形式参数的改变不影响实际参数    引用类型：形式参数的改变直接影响实际参数</code></pre><h3 id="2-数据加密问题"><a href="#2-数据加密问题" class="headerlink" title="(2)数据加密问题"></a>(2)数据加密问题</h3><pre><code>    综合的小案例。</code></pre><h2 id="3-面向对象-掌握"><a href="#3-面向对象-掌握" class="headerlink" title="3:面向对象(掌握)"></a>3:面向对象(掌握)</h2><h3 id="1-面向对象"><a href="#1-面向对象" class="headerlink" title="(1)面向对象"></a>(1)面向对象</h3><pre><code>    面向对象是基于面向过程的编程思想</code></pre><h3 id="2-面向对象的思想特点"><a href="#2-面向对象的思想特点" class="headerlink" title="(2)面向对象的思想特点"></a>(2)面向对象的思想特点</h3><pre><code>    A:是一种更符合我们思考习惯的思想    B:把复杂的事情简单化    C:让我们从执行者变成了指挥者    举例：        买电脑        洗衣服        做饭        ...        万事万物皆对象</code></pre><h3 id="3-把大象装进冰箱-理解"><a href="#3-把大象装进冰箱-理解" class="headerlink" title="(3)把大象装进冰箱(理解)"></a>(3)把大象装进冰箱(理解)</h3><pre><code>    A:面向过程实现    B:面向对象实现    注意：如何让我们的操作更符合面向对象思想呢?    A:有哪些类    B:每个类有哪些成员    C:类与类的关系</code></pre><h3 id="4-类与对象"><a href="#4-类与对象" class="headerlink" title="(4)类与对象"></a>(4)类与对象</h3><pre><code>    A:现实世界的事物        属性    事物的基本描述        行为    事物的功能    B:Java语言中最基本的单位是类。所以，我们要用类来体现事物    C:类        成员变量    事物属性        成员方法    事物行为    D:类：是一组相关的属性和行为的集合。是一个抽象的概念。      对象：是该类事物的具体存在，是一个具体的实例。(对象)      举例：        学生：类        班长：对象</code></pre><h3 id="5-类的定义及使用"><a href="#5-类的定义及使用" class="headerlink" title="(5)类的定义及使用"></a>(5)类的定义及使用</h3><pre><code>    A:类的定义        成员变量    定义格式和以前一样，就是位置不同，在类中，方法外。        成员方法    定义格式和以前一样，就是去掉了static。    B:使用类的内容        a:创建对象? 格式            类名 对象名 =  new 类名();        b:如何使用成员变量和成员方法呢            对象名.成员变量            对象名.成员方法()</code></pre><h3 id="6-案例："><a href="#6-案例：" class="headerlink" title="(6)案例："></a>(6)案例：</h3><pre><code>    A:学生类的定义和使用    B:手机类的定义和使用</code></pre><h3 id="7-内存图"><a href="#7-内存图" class="headerlink" title="(7)内存图"></a>(7)内存图</h3><pre><code>    A:一个对象的内存图    B:二个对象的内存图    C:三个对象的内存图</code></pre><h3 id="8-Java程序的开发，设计和特征"><a href="#8-Java程序的开发，设计和特征" class="headerlink" title="(8)Java程序的开发，设计和特征"></a>(8)Java程序的开发，设计和特征</h3><pre><code>    A:开发：就是不断的创建对象，通过对象调用功能    B:设计：就是管理和维护对象间的关系    C:特征        a:封装        b:继承        c:多态</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day05</title>
      <link href="/2020/060410525.html"/>
      <url>/2020/060410525.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-方法-掌握"><a href="#1-方法-掌握" class="headerlink" title="1:方法(掌握)"></a>1:方法(掌握)</h2><h3 id="1-方法：就是完成特定功能的代码块。"><a href="#1-方法：就是完成特定功能的代码块。" class="headerlink" title="(1)方法：就是完成特定功能的代码块。"></a>(1)方法：就是完成特定功能的代码块。</h3><pre><code>    注意：在很多语言里面有函数的定义，而在Java中，函数被称为方法。</code></pre><h3 id="2-格式："><a href="#2-格式：" class="headerlink" title="(2)格式："></a>(2)格式：</h3><pre><code>    修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) {        方法体语句;        return 返回值;    }    修饰符：目前就用 public static。后面再详细讲解其他修饰符    返回值类型：就是功能结果的数据类型    方法名：就是起了一个名字，方便我们调用该方法。    参数类型：就是参数的数据类型    参数名：就是变量    参数分类：        实参：实际参与运算的数据        形参：方法上定义的，用于接收实际参数的变量    方法体语句：就是完成功能的代码块    return：结束方法    返回值：就是功能的结果，由return带给调用者。</code></pre><h3 id="3-两个明确："><a href="#3-两个明确：" class="headerlink" title="(3)两个明确："></a>(3)两个明确：</h3><pre><code>    返回值类型：结果的数据类型    参数列表：参数的个数及对应的数据类型</code></pre><h3 id="4-方法调用"><a href="#4-方法调用" class="headerlink" title="(4)方法调用"></a>(4)方法调用</h3><pre><code>    A:有明确返回值的方法        a:单独调用，没有意义        b:输出调用，不是很好，因为我可能需要不结果进行进一步的操作。但是讲课一般我就用了。        c:赋值调用，推荐方案    B:void类型修饰的方法        a:单独调用</code></pre><h3 id="5-案例："><a href="#5-案例：" class="headerlink" title="(5)案例："></a>(5)案例：</h3><pre><code>    A:求和方案    B:获取两个数中的较大值    C:比较两个数据是否相同    D:获取三个数中的最大值    E:输出m行n列的星形    F:输出nn乘法表</code></pre><h3 id="6-方法的注意事项"><a href="#6-方法的注意事项" class="headerlink" title="(6)方法的注意事项"></a>(6)方法的注意事项</h3><pre><code>    A:方法不调用不执行    B:方法之间是平级关系，不能嵌套定义    C:方法定义的时候，参数是用，隔开的    D:方法在调用的时候，不用在传递数据类型    E:如果方法有明确的返回值类型，就必须有return语句返回。</code></pre><h3 id="7-方法重载"><a href="#7-方法重载" class="headerlink" title="(7)方法重载"></a>(7)方法重载</h3><pre><code>    在同一个类中，方法名相同，参数列表不同。与返回值无关。    参数列表不同：        参数的个数不同。        参数的对应的数据类型不同。</code></pre><h3 id="8-方法重载案例"><a href="#8-方法重载案例" class="headerlink" title="(8)方法重载案例"></a>(8)方法重载案例</h3><pre><code>    不同的类型的多个同名方法的比较。</code></pre><h2 id="2-数组-掌握"><a href="#2-数组-掌握" class="headerlink" title="2:数组(掌握)"></a>2:数组(掌握)</h2><h3 id="1-数组："><a href="#1-数组：" class="headerlink" title="(1)数组："></a>(1)数组：</h3><pre><code>存储同一种数据类型的多个元素的容器。</code></pre><h3 id="2-特点："><a href="#2-特点：" class="headerlink" title="(2)特点："></a>(2)特点：</h3><pre><code>每一个元素都有编号，从0开始，最大编号是长度-1。         编号的专业叫法：索引</code></pre><h3 id="3-定义格式"><a href="#3-定义格式" class="headerlink" title="(3)定义格式"></a>(3)定义格式</h3><pre><code>    A:数据类型[] 数组名;    B:数据类型 数组名[];    推荐是用A方式，B方法就忘了吧。    但是要能看懂</code></pre><h3 id="4-数组的初始化"><a href="#4-数组的初始化" class="headerlink" title="(4)数组的初始化"></a>(4)数组的初始化</h3><pre><code>    A:动态初始化        只给长度，系统给出默认值        举例：int[] arr = new int[3];    B:静态初始化        给出值，系统决定长度        举例：int[] arr = new int[]{1,2,3};        简化版：int[] arr = {1,2,3};</code></pre><h3 id="5-Java的内存分配"><a href="#5-Java的内存分配" class="headerlink" title="(5)Java的内存分配"></a>(5)Java的内存分配</h3><pre><code>    A:栈 存储局部变量    B:堆 存储所有new出来的    C:方法区(面向对象部分详细讲解)    D:本地方法区(系统相关)    E:寄存器(CPU使用)    注意：        a:局部变量 在方法定义中或者方法声明上定义的变量。        b:栈内存和堆内存的区别            栈：数据使用完毕，就消失。            堆：每一个new出来的东西都有地址                每一个变量都有默认值                    byte,short,int,long 0                    float,double 0.0                    char &#39;\u0000&#39;                    boolean false                    引用类型 null                数据使用完毕后，在垃圾回收器空闲的时候回收。</code></pre><h3 id="6-数组内存图"><a href="#6-数组内存图" class="headerlink" title="(6)数组内存图"></a>(6)数组内存图</h3><pre><code>    A:一个数组    B:二个数组    C:三个数组(两个栈变量指向同一个堆内存)</code></pre><h3 id="7-数组的常见操作"><a href="#7-数组的常见操作" class="headerlink" title="(7)数组的常见操作"></a>(7)数组的常见操作</h3><pre><code>    A:遍历        方式1：            public static void printArray(int[] arr) {                for(int x=0; x&lt;arr.length; x++) {                    System.out.println(arr[x]);                }            }        方式2：            public static void printArray(int[] arr) {                System.out.print(&quot;[&quot;);                for(int x=0; x&lt;arr.length; x++) {                    if(x == arr.length-1) {                        System.out.println(arr[x]+&quot;]&quot;);                    }else {                        System.out.println(arr[x]+&quot;, &quot;);                    }                }            }    B:最值        最大值：            public static int getMax(int[] arr) {                int max = arr[0];                for(int x=1; x&lt;arr.length; x++) {                    if(arr[x] &gt; max) {                        max = arr[x];                    }                }                return max;            }        最小值：            public static int getMin(int[] arr) {                int min = arr[0];                for(int x=1; x&lt;arr.length; x++) {                    if(arr[x] &lt; min) {                        min = arr[x];                    }                }                return min;            }    C:逆序        方式1：            public static void reverse(int[] arr) {                for(int x=0; x&lt;arr.length/2; x++) {                    int temp = arr[x];                    arr[x] = arr[arr.length-1-x];                    arr[arr.length-1-x] = temp;                }            }        方式2：            public static void reverse(int[] arr) {                for(int start=0,end=arr.length-1; start&lt;=end; start++,end--) {                    int temp = arr[start];                    arr[start] = arr[end];                    arr[end] = temp;                }            }    D:查表            public static String getString(String[] strArray,int index) {                return strArray[index];            }    E:基本查找        方式1：            public static int getIndex(int[] arr,int value) {                for(int x=0; x&lt;arr.length; x++) {                    if(arr[x] == value) {                        return x;                    }                }                return -1;            }        方式2：            public static int getIndex(int[] arr,int value) {                int index = -1;                for(int x=0; x&lt;arr.length; x++) {                    if(arr[x] == value) {                        index = x;                        break;                    }                }                return index;            }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day04</title>
      <link href="/2020/060359868.html"/>
      <url>/2020/060359868.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-switch语句-掌握"><a href="#1-switch语句-掌握" class="headerlink" title="1:switch语句(掌握)"></a>1:switch语句(掌握)</h2><h3 id="1-格式："><a href="#1-格式：" class="headerlink" title="(1)格式："></a>(1)格式：</h3><pre><code>    switch(表达式) {        case 值1:            语句体1;            break;        case 值2:            语句体2;            break;        ...        default:            语句体n+1;            break;    }    格式解释说明：        switch:说明这是switch语句。        表达式:可以是byte,short,int,char            JDK5以后可以是枚举            JDK7以后可以是字符串        case:后面的值就是要和表达式进行比较的值        break:表示程序到这里中断，跳出switch语句        default:如果所有的情况都不匹配,就执行这里,相当于if语句中的else</code></pre><h3 id="2-面试题"><a href="#2-面试题" class="headerlink" title="(2)面试题"></a>(2)面试题</h3><pre><code>    switch语句的表达式可以是byte吗?可以是long吗?可以是String吗?        可以,不可以,JDK7以后可以</code></pre><h3 id="3-执行流程"><a href="#3-执行流程" class="headerlink" title="(3)执行流程:"></a>(3)执行流程:</h3><pre><code>    A:首先计算表达式的值    B:和每一个case进行匹配，如果有就执行对应的语句体，看到break就结束。    C:如果没有匹配，就执行default的语句体n+1。</code></pre><h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="(4)注意事项:"></a>(4)注意事项:</h3><pre><code>    A:case后面只能是常量，不能是变量，而且，多个case后面的值不能出现相同的    B:default可以省略吗?        可以省略，但是不建议，因为它的作用是对不正确的情况给出提示。        特殊情况：            case就可以把值固定。            A,B,C,D    C:break可以省略吗?        可以省略，但是结果可能不是我们想要的。        会出现一个现象：case穿透。        最终我们建议不要省略    D:default一定要在最后吗?        不是，可以在任意位置。但是建议在最后。    E:switch语句的结束条件        a:遇到break就结束了        b:执行到末尾就结束了</code></pre><h3 id="5-案例："><a href="#5-案例：" class="headerlink" title="(5)案例："></a>(5)案例：</h3><pre><code>    A:键盘录入一个数字(1-7),输出对应的星期几。    B:单项选择题    C:键盘录入一个字符串的问题        String s = sc.nextLine();    D:根据给定的月份,输出对应的季节</code></pre><h3 id="6-if语句和switch语句各自的场景"><a href="#6-if语句和switch语句各自的场景" class="headerlink" title="(6)if语句和switch语句各自的场景"></a>(6)if语句和switch语句各自的场景</h3><pre><code>    A:if        针对boolean类型的判断        针对一个范围的判断        针对几个常量的判断    B:switch        针对几个常量的判断</code></pre><h2 id="2-循环语句-掌握"><a href="#2-循环语句-掌握" class="headerlink" title="2:循环语句(掌握)"></a>2:循环语句(掌握)</h2><h3 id="1-有三种-for-while-do…while"><a href="#1-有三种-for-while-do…while" class="headerlink" title="(1)有三种:for,while,do…while"></a>(1)有三种:for,while,do…while</h3><h3 id="2-for循环语句"><a href="#2-for循环语句" class="headerlink" title="(2)for循环语句"></a>(2)for循环语句</h3><pre><code>    A:格式        for(初始化语句;判断条件语句;控制条件语句){            循环体语句;        }        执行流程：            a:执行初始化语句            b:执行判断条件语句                如果这里是true，就继续                如果这里是false，循环就结束            c:执行循环体语句            d:执行控制条件语句            e:回到b    B:注意事项        a:判断条件语句无论简单还是复杂，结果是boolean类型        b:循环体语句如果是一条，可以省略大括号，但是不建议        c:有分号就没有左大括号，有左大括号就没有分号    C:案例        a:输出10次HelloWorld        b:输出1-10的数据        c:输出10-1的数据        d:求1-10的和        e:求1-100的和,求1-100的偶数和,求1-100的奇数和        f:求5的阶乘        g:在控制台打印水仙花数        h:统计水仙花个数        i:改进版的回文数            一个五位数            个位 = 万位            十位 = 千位            个位 + 十位 + 千位 + 万位 = 百位        j:统计1-1000之间同时满足如下条件的数据有多少个            x%3==2            x%5==3            x%7==2</code></pre><h3 id="3-while循环"><a href="#3-while循环" class="headerlink" title="(3)while循环"></a>(3)while循环</h3><pre><code>    A:基本格式        while(判断条件语句) {            循环体语句;        }        扩展格式：        初始化语句;        while(判断条件语句){            循环体语句;            控制条件语句;        }        通过查看这个格式，我们就知道while循环可以和for循环等价转换。    B:while的练习        把for语句的练习用while改进    C:for和while的区别        a:使用上的区别            for语句的那个控制条件变量,在循环结束后不能在使用了。            而while的可以继续使用。        b:理解上的区别            for适合于一个范围的判断            while适合次数不明确的                举例:吃葡萄    D:案例：        a:珠穆朗玛峰问题        b:小芳存钱问题(break以后才能做)</code></pre><h3 id="4-do…while循环"><a href="#4-do…while循环" class="headerlink" title="(4)do…while循环"></a>(4)do…while循环</h3><pre><code>    A:基本格式        do {            循环体语句;        }while(判断条件语句);        扩展格式：        初始化语句;        do {            循环体语句;            控制条件语句;        }while(判断条件语句);        通过查看格式，我们就可以看出其实三种循环的格式可以是统一的。    B:三种循环的区别        a:do...while循环至少执行一次循环体        b:for和while必须先判断条件是否是true，然后后才能决定是否执行循环体</code></pre><h3 id="5-循环使用的注意事项-死循环"><a href="#5-循环使用的注意事项-死循环" class="headerlink" title="(5)循环使用的注意事项(死循环)"></a>(5)循环使用的注意事项(死循环)</h3><pre><code>    A:一定要注意修改控制条件,否则容易出现死循环。    B:最简单的死循环格式        a:while(true){...}        b:for(;;){}</code></pre><h2 id="3-控制跳转语句-掌握"><a href="#3-控制跳转语句-掌握" class="headerlink" title="3:控制跳转语句(掌握)"></a>3:控制跳转语句(掌握)</h2><h3 id="1-break-中断的意思"><a href="#1-break-中断的意思" class="headerlink" title="(1)break:中断的意思"></a>(1)break:中断的意思</h3><pre><code>    A:用在循环和switch语句中，离开此应用场景无意义。    B:作用        a:跳出单层循环        b:跳出多层循环，需要标签语句的配合</code></pre><h3 id="2-continue-继续"><a href="#2-continue-继续" class="headerlink" title="(2)continue:继续"></a>(2)continue:继续</h3><pre><code>    A:用在循环中，离开此应用场景无意义。    B:作用        a:跳出单层循环的一次，可以继续下一次    C:填空题        for(int x=1; x&lt;=10; x++) {            if(x%3 == 0) {                //补齐代码            }            System.out.println(&quot;Java基础班&quot;);        }        如何让控制台输出2次：Java基础班        如何让控制台输出7次：Java基础班        如何让控制台输出13次：Java基础班</code></pre><h3 id="3-return-返回"><a href="#3-return-返回" class="headerlink" title="(3)return:返回"></a>(3)return:返回</h3><pre><code>    A:用于结束方法的，后面还会在继续讲解和使用。    B:一旦遇到return,程序就不会在继续往后执行。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day03</title>
      <link href="/2020/060211165.html"/>
      <url>/2020/060211165.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-运算符-掌握"><a href="#1-运算符-掌握" class="headerlink" title="1:运算符(掌握)"></a>1:运算符(掌握)</h2><h3 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="(1)算术运算符"></a>(1)算术运算符</h3><pre><code>    A:+,-,*,/,%,++,--    B:+的用法        a:加法        b:正号        c:字符串连接符    C:/和%的区别        数据做除法操作的时候，/取得是商，%取得是余数    D:++和--的用法        a:他们的作用是自增或者自减        b:使用            **单独使用                放在操作数据的前面和后面效果一样。                a++或者++a效果一样。            **参与操作使用                放在操作数的前面：先自增或者自减，再参与操作                    int a = 10;                    int b = ++a;                放在操作数的后面：先参与操作，再自增或者自减                    int a = 10;                    int b = a++;</code></pre><h3 id="2-赋值运算符"><a href="#2-赋值运算符" class="headerlink" title="(2)赋值运算符"></a>(2)赋值运算符</h3><pre><code>    A:=,+=,-=,*=,/=,%=等    B:=叫做赋值运算符，也是最基本的赋值运算符        int x = 10; 把10赋值给int类型的变量x。    C:扩展的赋值运算符的特点        隐含了自动强制转换。        面试题：            short s = 1;            s = s + 1;            short s = 1;            s += 1;            请问上面的代码哪个有问题?</code></pre><h3 id="3-比较运算符"><a href="#3-比较运算符" class="headerlink" title="(3)比较运算符"></a>(3)比较运算符</h3><pre><code>    A:==,!=,&gt;,&gt;=,&lt;,&lt;=    B:无论运算符两端简单还是复杂最终结果是boolean类型。    C:千万不要把==写成了=</code></pre><h3 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="(4)逻辑运算符"></a>(4)逻辑运算符</h3><pre><code>    A:&amp;,|,^,!,&amp;&amp;,||    B:逻辑运算符用于连接boolean类型的式子    C:结论        &amp;:有false则false        |:有true则true        ^:相同则false，不同则true。            情侣关系。        !:非true则false，非false则true        &amp;&amp;:结果和&amp;是一样的，只不过有短路效果。左边是false，右边不执行。        ||:结果和|是一样的，只不过有短路效果。左边是true，右边不执行。</code></pre><h3 id="5-位运算符-了解"><a href="#5-位运算符-了解" class="headerlink" title="(5)位运算符(了解)"></a>(5)位运算符(了解)</h3><pre><code>    A:^的特殊用法        一个数据针对另一个数据位异或两次，该数不变    B:面试题        a:请实现两个变量的交换            **采用第三方变量            **用位异或运算符                左边a,b,a                右边a^b        b:请用最有效率的方式计算出2乘以8的结果            2&lt;&lt;3</code></pre><h3 id="6-三元运算符"><a href="#6-三元运算符" class="headerlink" title="(6)三元运算符"></a>(6)三元运算符</h3><pre><code>    A:格式        比较表达式?表达式1:表达式2;    B:执行流程：        首先计算比较表达式的值，看是true还是false。        如果是true，表达式1就是结果。        如果是false，表达式2就是结果。    C:案例：        a:比较两个数据是否相等        b:获取两个数据中的最大值        c:获取三个数据中的最大值</code></pre><h2 id="2-键盘录入-掌握"><a href="#2-键盘录入-掌握" class="headerlink" title="2:键盘录入(掌握)"></a>2:键盘录入(掌握)</h2><h3 id="1-实际开发中，数据是变化的，为了提高程序的灵活性，我们加入键盘录入数据。"><a href="#1-实际开发中，数据是变化的，为了提高程序的灵活性，我们加入键盘录入数据。" class="headerlink" title="(1)实际开发中，数据是变化的，为了提高程序的灵活性，我们加入键盘录入数据。"></a>(1)实际开发中，数据是变化的，为了提高程序的灵活性，我们加入键盘录入数据。</h3><h3 id="2-如何实现呢-目前就记住"><a href="#2-如何实现呢-目前就记住" class="headerlink" title="(2)如何实现呢?目前就记住"></a>(2)如何实现呢?目前就记住</h3><pre><code>    A:导包        import java.util.Scanner;        位置：在class的上边    B:创建对象        Scanner sc = new Scanner(System.in);    C:获取数据        int x = sc.nextInt();</code></pre><h3 id="3-把三元运算符的案例加入键盘录入改进。"><a href="#3-把三元运算符的案例加入键盘录入改进。" class="headerlink" title="(3)把三元运算符的案例加入键盘录入改进。"></a>(3)把三元运算符的案例加入键盘录入改进。</h3><h2 id="3-流程控制语句"><a href="#3-流程控制语句" class="headerlink" title="3:流程控制语句"></a>3:流程控制语句</h2><h3 id="1-顺序结构-从上往下，依次执行"><a href="#1-顺序结构-从上往下，依次执行" class="headerlink" title="(1)顺序结构 从上往下，依次执行"></a>(1)顺序结构 从上往下，依次执行</h3><h3 id="2-选择结构-按照不同的选择，执行不同的代码"><a href="#2-选择结构-按照不同的选择，执行不同的代码" class="headerlink" title="(2)选择结构    按照不同的选择，执行不同的代码"></a>(2)选择结构    按照不同的选择，执行不同的代码</h3><h3 id="3-循环结构-做一些重复的代码"><a href="#3-循环结构-做一些重复的代码" class="headerlink" title="(3)循环结构 做一些重复的代码"></a>(3)循环结构 做一些重复的代码</h3><h2 id="4-if语句-掌握"><a href="#4-if语句-掌握" class="headerlink" title="4:if语句(掌握)"></a>4:if语句(掌握)</h2><h3 id="1-三种格式"><a href="#1-三种格式" class="headerlink" title="(1)三种格式"></a>(1)三种格式</h3><pre><code>    A:格式1        if(比较表达式) {            语句体;        }        执行流程：            判断比较表达式的值，看是true还是false            如果是true，就执行语句体            如果是false，就不执行语句体    B:格式2        if(比较表达式) {            语句体1;        }else {            语句体2;        }        执行流程：            判断比较表达式的值，看是true还是false            如果是true，就执行语句体1            如果是false，就执行语句体2    C:格式3        if(比较表达式1) {            语句体1;        }else if(比较表达式2){            语句体2;        }        ...        else {            语句体n+1;        }        执行流程：            判断比较表达式1的值，看是true还是false            如果是true，就执行语句体1            如果是false，就继续判断比较表达式2的值，看是true还是false            如果是true，就执行语句体2            如果是false，就继续判断比较表达式3的值，看是true还是false            ...            如果都不满足，就执行语句体n+1</code></pre><h3 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="(2)注意事项"></a>(2)注意事项</h3><pre><code>    A:比较表达式无论简单还是复杂，结果是boolean类型    B:if语句控制的语句体如果是一条语句，是可以省略大括号的；如果是多条，不能省略。        建议：永远不要省略。    C:一般来说，有左大括号，就没有分号，有分号，就没有左大括号。    D:else后面如果没有if，是不会出现比较表达式的。    E:三种if语句其实都是一个语句，只要有一个执行，其他的就不再执行。</code></pre><h3 id="3-案例："><a href="#3-案例：" class="headerlink" title="(3)案例："></a>(3)案例：</h3><pre><code>    A:比较两个数是否相等    B:获取两个数中的最大值    C:获取三个数中的最大值(if语句的嵌套)    D:根据成绩输出对应的等级    E:根据月份，输出对应的季节    F:根据x计算对应y的值并输出</code></pre><h3 id="4-三元运算符和if语句第二种格式的关系"><a href="#4-三元运算符和if语句第二种格式的关系" class="headerlink" title="(4)三元运算符和if语句第二种格式的关系"></a>(4)三元运算符和if语句第二种格式的关系</h3><pre><code>    所有的三元运算符能够实现的，if语句的第二种格式都能实现。    反之不成立。    如果if语句第二种格式控制的语句体是输出语句，就不可以。    因为三元运算符是一个运算符，必须要有一个结果返回，不能是一个输出语句。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day02</title>
      <link href="/2020/060160252.html"/>
      <url>/2020/060160252.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-关键字-掌握"><a href="#1-关键字-掌握" class="headerlink" title="1:关键字(掌握)"></a>1:关键字(掌握)</h2><h3 id="1-被Java语言赋予特定含义的单词"><a href="#1-被Java语言赋予特定含义的单词" class="headerlink" title="(1)被Java语言赋予特定含义的单词"></a>(1)被Java语言赋予特定含义的单词</h3><h3 id="2-特点："><a href="#2-特点：" class="headerlink" title="(2)特点："></a>(2)特点：</h3><pre><code>    全部小写。</code></pre><h3 id="3-注意事项："><a href="#3-注意事项：" class="headerlink" title="(3)注意事项："></a>(3)注意事项：</h3><pre><code>    A:goto和const作为保留字存在。    B:类似于Notepad++这样的高级记事本会对关键字有特殊颜色标记</code></pre><h2 id="2-标识符-掌握"><a href="#2-标识符-掌握" class="headerlink" title="2:标识符(掌握)"></a>2:标识符(掌握)</h2><h3 id="1-就是给类，接口，方法，变量等起名字的字符序列"><a href="#1-就是给类，接口，方法，变量等起名字的字符序列" class="headerlink" title="(1)就是给类，接口，方法，变量等起名字的字符序列"></a>(1)就是给类，接口，方法，变量等起名字的字符序列</h3><h3 id="2-组成规则："><a href="#2-组成规则：" class="headerlink" title="(2)组成规则："></a>(2)组成规则：</h3><pre><code>    A:英文大小写字母    B:数字    C:$和_</code></pre><h3 id="3-注意事项：-1"><a href="#3-注意事项：-1" class="headerlink" title="(3)注意事项："></a>(3)注意事项：</h3><pre><code>    A:不能以数字开头    B:不能是java中的关键字    C:区分大小写</code></pre><h3 id="4-常见的命名规则-见名知意"><a href="#4-常见的命名规则-见名知意" class="headerlink" title="(4)常见的命名规则(见名知意)"></a>(4)常见的命名规则(见名知意)</h3><pre><code>    A:包    全部小写        单级包：小写            举例：liuyi,com        多级包：小写，并用.隔开            举例：cn.itcast,com.baidu                    B:类或者接口        一个单词：首字母大写            举例：Student,Demo        多个单词：每个单词首字母大写            举例：HelloWorld,StudentName    C:方法或者变量        一个单词：首字母小写            举例：name,main        多个单词：从第二个单词开始，每个单词首字母大写            举例：studentAge,showAllNames()    D:常量        全部大写        一个单词：大写            举例：PI        多个单词：大写，并用_隔开            举例：STUDENT_MAX_AGE</code></pre><h2 id="3-注释-掌握"><a href="#3-注释-掌握" class="headerlink" title="3:注释(掌握)"></a>3:注释(掌握)</h2><h3 id="1-就是对程序进行解释说明的文字"><a href="#1-就是对程序进行解释说明的文字" class="headerlink" title="(1)就是对程序进行解释说明的文字"></a>(1)就是对程序进行解释说明的文字</h3><h3 id="2-分类："><a href="#2-分类：" class="headerlink" title="(2)分类："></a>(2)分类：</h3><pre><code>    A:单行注释    //    B:多行注释    /**/    C:文档注释(后面讲) /** */</code></pre><h3 id="3-把HelloWorld案例写了一个带注释的版本。"><a href="#3-把HelloWorld案例写了一个带注释的版本。" class="headerlink" title="(3)把HelloWorld案例写了一个带注释的版本。"></a>(3)把HelloWorld案例写了一个带注释的版本。</h3><pre><code>    后面我们要写一个程序的过程。    需求：    分析：    实现：    代码体现：</code></pre><h3 id="4-注释的作用"><a href="#4-注释的作用" class="headerlink" title="(4)注释的作用"></a>(4)注释的作用</h3><pre><code>    A:解释说明程序，提高了代码的阅读性。    B:可以帮助我们调试程序。        后面我们会讲解一个更高端的一个调试工具</code></pre><h2 id="4-常量-掌握"><a href="#4-常量-掌握" class="headerlink" title="4:常量(掌握)"></a>4:常量(掌握)</h2><h3 id="1-在程序执行的过程中，其值不发生改变的量"><a href="#1-在程序执行的过程中，其值不发生改变的量" class="headerlink" title="(1)在程序执行的过程中，其值不发生改变的量"></a>(1)在程序执行的过程中，其值不发生改变的量</h3><h3 id="2-分类：-1"><a href="#2-分类：-1" class="headerlink" title="(2)分类："></a>(2)分类：</h3><pre><code>    A:字面值常量    B:自定义常量(后面讲)</code></pre><h3 id="3-字面值常量"><a href="#3-字面值常量" class="headerlink" title="(3)字面值常量"></a>(3)字面值常量</h3><pre><code>    A:字符串常量 &quot;hello&quot;    B:整数常量    12,23    C:小数常量    12.345    D:字符常量    &#39;a&#39;,&#39;A&#39;,&#39;0&#39;    E:布尔常量    true,false    F:空常量    null(后面讲)</code></pre><h3 id="4-在Java中针对整数常量提供了四种表现形式"><a href="#4-在Java中针对整数常量提供了四种表现形式" class="headerlink" title="(4)在Java中针对整数常量提供了四种表现形式"></a>(4)在Java中针对整数常量提供了四种表现形式</h3><pre><code>    A:二进制    由0，1组成。以0b开头。    B:八进制    由0，1，...7组成。以0开头。    C:十进制    由0，1，...9组成。整数默认是十进制。    D:十六进制    由0，1，...9,a,b,c,d,e,f(大小写均可)组成。以0x开头。</code></pre><h2 id="5-进制转换-了解"><a href="#5-进制转换-了解" class="headerlink" title="5:进制转换(了解)"></a>5:进制转换(了解)</h2><h3 id="1-其他进制到十进制"><a href="#1-其他进制到十进制" class="headerlink" title="(1)其他进制到十进制"></a>(1)其他进制到十进制</h3><pre><code>    系数：就是每一个位上的数值    基数：x进制的基数就是x    权：对每一个位上的数据，从右，并且从0开始编号，对应的编号就是该数据的权。    结果：系数*基数^权次幂之和。</code></pre><h3 id="2-十进制到其他进制"><a href="#2-十进制到其他进制" class="headerlink" title="(2)十进制到其他进制"></a>(2)十进制到其他进制</h3><pre><code>    除基取余，直到商为0，余数反转。</code></pre><h3 id="3-进制转换的快速转换法"><a href="#3-进制转换的快速转换法" class="headerlink" title="(3)进制转换的快速转换法"></a>(3)进制转换的快速转换法</h3><pre><code>    A:十进制和二进制间的转换        8421码。    B:二进制到八进制，十六进制的转换</code></pre><h2 id="6-变量-掌握"><a href="#6-变量-掌握" class="headerlink" title="6:变量(掌握)"></a>6:变量(掌握)</h2><h3 id="1-在程序的执行过程中，其值在某个范围内可以发生改变的量"><a href="#1-在程序的执行过程中，其值在某个范围内可以发生改变的量" class="headerlink" title="(1)在程序的执行过程中，其值在某个范围内可以发生改变的量"></a>(1)在程序的执行过程中，其值在某个范围内可以发生改变的量</h3><h3 id="2-变量的定义格式："><a href="#2-变量的定义格式：" class="headerlink" title="(2)变量的定义格式："></a>(2)变量的定义格式：</h3><pre><code>    A:数据类型 变量名 = 初始化值;    B:数据类型 变量名;      变量名 = 初始化值;</code></pre><h2 id="7-数据类型-掌握"><a href="#7-数据类型-掌握" class="headerlink" title="7:数据类型(掌握)"></a>7:数据类型(掌握)</h2><h3 id="1-Java是一种强类型语言，针对每种数据都提供了对应的数据类型。"><a href="#1-Java是一种强类型语言，针对每种数据都提供了对应的数据类型。" class="headerlink" title="(1)Java是一种强类型语言，针对每种数据都提供了对应的数据类型。"></a>(1)Java是一种强类型语言，针对每种数据都提供了对应的数据类型。</h3><h3 id="2-分类：-2"><a href="#2-分类：-2" class="headerlink" title="(2)分类："></a>(2)分类：</h3><pre><code>    A:基本数据类型：4类8种    B:引用数据类型：类，接口，数组。</code></pre><h3 id="3-基本数据类型"><a href="#3-基本数据类型" class="headerlink" title="(3)基本数据类型"></a>(3)基本数据类型</h3><pre><code>    A:整数            占用字节数        byte            1        short            2        int             4        long            8    B:浮点数        float            4        double            8    C:字符        char            2    D:布尔        boolean            1    注意：        整数默认是int类型，浮点数默认是double。        长整数要加L或者l。        单精度的浮点数要加F或者f。</code></pre><h2 id="8-数据类型转换-掌握"><a href="#8-数据类型转换-掌握" class="headerlink" title="8:数据类型转换(掌握)"></a>8:数据类型转换(掌握)</h2><h3 id="1-boolean类型不参与转换"><a href="#1-boolean类型不参与转换" class="headerlink" title="(1)boolean类型不参与转换"></a>(1)boolean类型不参与转换</h3><h3 id="2-默认转换"><a href="#2-默认转换" class="headerlink" title="(2)默认转换"></a>(2)默认转换</h3><pre><code>    A:从小到大    B:byte,short,char -- int -- long -- float -- double    C:byte,short,char之间不相互转换，直接转成int类型参与运算。</code></pre><h3 id="3-强制转换"><a href="#3-强制转换" class="headerlink" title="(3)强制转换"></a>(3)强制转换</h3><pre><code>    A:从大到小    B:可能会有精度的损失，一般不建议这样使用。    C:格式：        目标数据类型 变量名 = (目标数据类型) (被转换的数据);</code></pre><h3 id="4-思考题和面试题："><a href="#4-思考题和面试题：" class="headerlink" title="(4)思考题和面试题："></a>(4)思考题和面试题：</h3><pre><code>    A:下面两种方式有区别吗?        float f1 = 12.345f;        float f2 = (float)12.345;    B:下面的程序有问题吗，如果有，在哪里呢?        byte b1 = 3;        byte b2 = 4;        byte b3 = b1 + b2;        byte b4 = 3 + 4;    C:下面的操作结果是什么呢?        byte b = (byte)130;    D:字符参与运算        是查找ASCII里面的值        &#39;a&#39;        97        &#39;A&#39;        65        &#39;0&#39;        48        System.out.println(&#39;a&#39;);        System.out.println(&#39;a&#39; + 1);    E:字符串参与运算        这里其实是字符串的连接        System.out.println(&quot;hello&quot;+&#39;a&#39;+1);        System.out.println(&#39;a&#39;+1+&quot;hello&quot;);        System.out.println(&quot;5+5=&quot;+5+5);        System.out.println(5+5+&quot;=5+5&quot;);  </code></pre><hr><p>1：什么是注释?注释分为几种?注释有什么作用?  </p><pre><code>就是对程序进行解释说明；分为三种，单行注释，多行注释，文档注释；解释说明，提高代码的阅读性，帮助我们调试程序。</code></pre><p>2：什么是关键字?有什么特点?  </p><pre><code>被Java语言赋予特定含义的单词；全部小写；goto和const作为保留字存在。</code></pre><p>3：什么是标识符?由哪些部分组成?常见的命名规则有哪些?  </p><pre><code>就是给类，接口，方法，变量名等其名字的字符序列；A:英文字母大小写B:数字C：$和_。</code></pre><p>4：什么是常量?常量的分类?字面值常量表现形式有哪些?    </p><pre><code>在程序执行过程中，其值不发生改变的量；A字符串B整数C小数D字符E布尔F空常量null。</code></pre><p>5：计算出十进制46对应的二进制，八进制，十六进制的值。  </p><p>至于进制的内容今天在练习一次，以后就可以不用练习了。<br>后面能听懂就OK了。不用浪费太多时间。<br>(可用计算器验证你算的是否正确)</p><p>6：什么是变量?变量的定义格式?要使用变量需要注意什么?  </p><pre><code>在程序执行过程中，其值在某个范围内可以发生改变的量；A数据类型 变量名 = 初始值；B 数据类型 变量名；变量名 = 初始化值；</code></pre><p>7：Java中的数据类型分几类?基本数据类型有哪些?  </p><pre><code>A基本数据类型：4类8种 B引用数据类型：类，接口，数组。基本数据类型：    A整数     byte short int long   1 2 4 8    B浮点数 float double   4 8    C字符 char  2    D布尔 boolean 1</code></pre><p>8：数据类型转换：  </p><pre><code>隐式转换：A从小到大 Bbyte，short，char--int--long--float--double C:byte,short,char之间不相互转换，直接转成int类型参与运算。强制转换：A:从大到小          B:可能会有精度的损失，一般不建议这样使用。          C:格式：          目标数据类型 变量名 = (目标数据类型) (被转换的数据);</code></pre><p>面试题：  </p><pre><code>    第一题：    byte b1=3,b2=4,b;    b=b1+b2;    b=3+4;    哪句是编译失败的呢？为什么呢？    第二题：    byte  by = 130;有没有问题?有问题如何解决?结果是多少呢?</code></pre><p>9：练习打字(每天十分钟,即使休息的时候，也建议练习)</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day01</title>
      <link href="/2020/053159932.html"/>
      <url>/2020/053159932.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-计算机概述-了解"><a href="#1-计算机概述-了解" class="headerlink" title="1:计算机概述(了解)"></a>1:计算机概述(了解)</h2><h3 id="1-计算机"><a href="#1-计算机" class="headerlink" title="(1)计算机"></a>(1)计算机</h3><h3 id="2-计算机硬件"><a href="#2-计算机硬件" class="headerlink" title="(2)计算机硬件"></a>(2)计算机硬件</h3><h3 id="3-计算机软件"><a href="#3-计算机软件" class="headerlink" title="(3)计算机软件"></a>(3)计算机软件</h3><pre><code>    系统软件：window,linux,mac    应用软件：qq,yy,飞秋</code></pre><h3 id="4-软件开发-理解"><a href="#4-软件开发-理解" class="headerlink" title="(4)软件开发(理解)"></a>(4)软件开发(理解)</h3><pre><code>    软件：是由数据和指令组成的。(计算器)    开发：就是把软件做出来。    如何实现软件开发呢?        就是使用开发工具和计算机语言做出东西来</code></pre><h3 id="5-语言"><a href="#5-语言" class="headerlink" title="(5)语言"></a>(5)语言</h3><pre><code>    自然语言：人与人交流沟通的    计算机语言：人与计算机交流沟通的        C,C++,C#,Java</code></pre><h3 id="6-人机交换"><a href="#6-人机交换" class="headerlink" title="(6)人机交换"></a>(6)人机交换</h3><pre><code>    图形界面：操作方便只管    DOS命令：需要记忆一些常见的命令</code></pre><h2 id="2-键盘功能键的认识和快捷键-掌握"><a href="#2-键盘功能键的认识和快捷键-掌握" class="headerlink" title="2:键盘功能键的认识和快捷键(掌握)"></a>2:键盘功能键的认识和快捷键(掌握)</h2><h3 id="1-功能键的认识"><a href="#1-功能键的认识" class="headerlink" title="(1)功能键的认识"></a>(1)功能键的认识</h3><pre><code>    tab    shift    ctrl    alt    windos    空格    上下左右    回车    截图</code></pre><h3 id="2-快捷键"><a href="#2-快捷键" class="headerlink" title="(2)快捷键"></a>(2)快捷键</h3><pre><code>    全选    Ctrl+A    复制    Ctrl+C    粘贴    Ctrl+V    剪切    Ctrl+X    撤销    Ctrl+Z    保存    Ctrl+S</code></pre><h2 id="3-常见的DOS命令-掌握"><a href="#3-常见的DOS命令-掌握" class="headerlink" title="3:常见的DOS命令(掌握)"></a>3:常见的DOS命令(掌握)</h2><h3 id="1-常见的如下"><a href="#1-常见的如下" class="headerlink" title="(1)常见的如下"></a>(1)常见的如下</h3><pre><code>    盘符的切换        d:回车    目录的进入        cd javase        cd javase\day01\code    目录的回退        cd..        cd\    清屏        cls    退出        exit</code></pre><h3 id="2-其他的几个-了解"><a href="#2-其他的几个-了解" class="headerlink" title="(2)其他的几个(了解)"></a>(2)其他的几个(了解)</h3><pre><code>    创建目录    删除目录    创建文件    删除文件    显示目录下的内容    删除带内容的目录</code></pre><h2 id="4-Java语言概述-了解"><a href="#4-Java语言概述-了解" class="headerlink" title="4:Java语言概述(了解)"></a>4:Java语言概述(了解)</h2><h3 id="1-Java语言的发展史"><a href="#1-Java语言的发展史" class="headerlink" title="(1)Java语言的发展史"></a>(1)Java语言的发展史</h3><pre><code>    Java之父    JDK1.4.2    JDK5    JDK7</code></pre><h3 id="2-Java语言的特点"><a href="#2-Java语言的特点" class="headerlink" title="(2)Java语言的特点"></a>(2)Java语言的特点</h3><pre><code>    有很多小特点，重点有两个开源，跨平台</code></pre><h3 id="3-Java语言是跨平台的，请问是如何保证的呢-理解"><a href="#3-Java语言是跨平台的，请问是如何保证的呢-理解" class="headerlink" title="(3)Java语言是跨平台的，请问是如何保证的呢?(理解)"></a>(3)Java语言是跨平台的，请问是如何保证的呢?(理解)</h3><pre><code>    我们是通过翻译的案例讲解的。    针对不同的操作系统，提高不同的jvm来实现的。</code></pre><h3 id="4-Java语言的平台"><a href="#4-Java语言的平台" class="headerlink" title="(4)Java语言的平台"></a>(4)Java语言的平台</h3><pre><code>    JavaSE    JavaME--Android    JavaEE</code></pre><h2 id="5-JDK-JRE-JVM的作用及关系-掌握"><a href="#5-JDK-JRE-JVM的作用及关系-掌握" class="headerlink" title="5:JDK,JRE,JVM的作用及关系(掌握)"></a>5:JDK,JRE,JVM的作用及关系(掌握)</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="(1)作用"></a>(1)作用</h3><pre><code>    JVM：保证Java语言跨平台    JRE：Java程序的运行环境    JDK：Java程序的开发环境</code></pre><h3 id="2-关系"><a href="#2-关系" class="headerlink" title="(2)关系"></a>(2)关系</h3><pre><code>    JDK：JRE+工具    JRE：JVM+类库</code></pre><h2 id="6-JDK的下载-安装-卸载-掌握"><a href="#6-JDK的下载-安装-卸载-掌握" class="headerlink" title="6:JDK的下载,安装,卸载(掌握)"></a>6:JDK的下载,安装,卸载(掌握)</h2><h3 id="1-下载到官网。"><a href="#1-下载到官网。" class="headerlink" title="(1)下载到官网。"></a>(1)下载到官网。</h3><pre><code>    A:也可以到百度搜索即可。    B:我给你。</code></pre><h3 id="2-安装"><a href="#2-安装" class="headerlink" title="(2)安装"></a>(2)安装</h3><pre><code>    A:绿色版    解压就可以使用    B:安装版    必须一步一步的安装，一般只要会点击下一步即可    注意：        建议所有跟开发相关的软件都不要安装在有中文或者空格的目录下。</code></pre><h3 id="3-卸载"><a href="#3-卸载" class="headerlink" title="(3)卸载"></a>(3)卸载</h3><pre><code>    A:绿色版    直接删除文件夹    B:安装版            a:控制面板 -- 添加删除程序        b:通过专业的软件卸载工具。(比如360的软件管家卸载)</code></pre><h2 id="7-第一个程序：HelloWorld案例-掌握"><a href="#7-第一个程序：HelloWorld案例-掌握" class="headerlink" title="7:第一个程序：HelloWorld案例(掌握)"></a>7:第一个程序：HelloWorld案例(掌握)</h2><pre><code>class HelloWorld {    public static void main(String[] args) {        System.out.println(&quot;HelloWorld&quot;);    }}</code></pre><h3 id="1-程序解释："><a href="#1-程序解释：" class="headerlink" title="(1)程序解释："></a>(1)程序解释：</h3><pre><code>    A:Java程序的最基本单位是类，所以我们要定义一个类。        格式：class 类名        举例：class HelloWorld    B:在类中写内容的时候，用大括号括起来。    C:Java程序要想执行，必须有main方法。        格式：public static void main(String[] args)    D:要指向那些东西呢，也用大括号括起来。    E:你要做什么呢?今天我们仅仅做了一个简单的输出        格式：System.out.println(&quot;HelloWorld&quot;);        注意：&quot;&quot;里面的内容是可以改动的。</code></pre><h3 id="2-Java程序的开发执行流程："><a href="#2-Java程序的开发执行流程：" class="headerlink" title="(2)Java程序的开发执行流程："></a>(2)Java程序的开发执行流程：</h3><pre><code>    A:编写java源程序(.java)    B:通过javac命令编译生成.class文件    C:通过java命令运行.class文件</code></pre><h2 id="8-常见的问题-掌握"><a href="#8-常见的问题-掌握" class="headerlink" title="8:常见的问题(掌握)"></a>8:常见的问题(掌握)</h2><h3 id="1-扩展名被隐藏"><a href="#1-扩展名被隐藏" class="headerlink" title="(1)扩展名被隐藏"></a>(1)扩展名被隐藏</h3><pre><code>    如何找到：工具--文件夹选项--查看--去除隐藏扩展名的那个勾勾</code></pre><h3 id="2-我要求文件名称和类名一致。"><a href="#2-我要求文件名称和类名一致。" class="headerlink" title="(2)我要求文件名称和类名一致。"></a>(2)我要求文件名称和类名一致。</h3><pre><code>    实际上不这样做也是可以的。    但是，注意：        javac后面跟的是文件名+扩展名        java后面跟的类名不带扩展名</code></pre><h3 id="3-Java语言严格区分大小写，请注意。"><a href="#3-Java语言严格区分大小写，请注意。" class="headerlink" title="(3)Java语言严格区分大小写，请注意。"></a>(3)Java语言严格区分大小写，请注意。</h3><pre><code>     还有就是单词不要写错了。</code></pre><h3 id="4-见到非法字符-65307肯定是中文问题。"><a href="#4-见到非法字符-65307肯定是中文问题。" class="headerlink" title="(4)见到非法字符: \65307肯定是中文问题。"></a>(4)见到非法字符: \65307肯定是中文问题。</h3><pre><code>    我们写程序要求标点符号必须全部是英文状态。</code></pre><h3 id="5-括号的配对问题。"><a href="#5-括号的配对问题。" class="headerlink" title="(5)括号的配对问题。"></a>(5)括号的配对问题。</h3><pre><code>    一般来说，括号都是成对出现的。</code></pre><h3 id="6-遇到"><a href="#6-遇到" class="headerlink" title="(6)遇到"></a>(6)遇到</h3><pre><code>    在类 HelloWorld 中找不到主方法, 请将主方法定义为    肯定是主方法的格式问题。</code></pre><h2 id="9-path环境变量-掌握"><a href="#9-path环境变量-掌握" class="headerlink" title="9:path环境变量(掌握)"></a>9:path环境变量(掌握)</h2><h3 id="1-path环境变量的作用"><a href="#1-path环境变量的作用" class="headerlink" title="(1)path环境变量的作用"></a>(1)path环境变量的作用</h3><pre><code>    保证javac命令可以在任意目录下运行。    同理可以配置qq等</code></pre><h3 id="2-path配置的两种方案："><a href="#2-path配置的两种方案：" class="headerlink" title="(2)path配置的两种方案："></a>(2)path配置的两种方案：</h3><pre><code>    A:方案1(了解)    B:方案2        找到环境变量的位置，在系统变量里面        新建：            变量名：JAVA_HOME            变量值：D:\develop\Java\jdk1.7.0_60        修改：            变量名：Path            变量值：%JAVA_HOME%\bin;以前的内容</code></pre><h2 id="10-classpath环境变量-理解"><a href="#10-classpath环境变量-理解" class="headerlink" title="10:classpath环境变量(理解)"></a>10:classpath环境变量(理解)</h2><h3 id="1-classpath环境变量的作用"><a href="#1-classpath环境变量的作用" class="headerlink" title="(1)classpath环境变量的作用"></a>(1)classpath环境变量的作用</h3><pre><code>    保证class文件可以在任意目录下运行</code></pre><h3 id="2-classpath环境变量的配置"><a href="#2-classpath环境变量的配置" class="headerlink" title="(2)classpath环境变量的配置"></a>(2)classpath环境变量的配置</h3><pre><code>    找到环境变量的位置，在系统变量里面    新建：        变量名：classpath        变量值：E:\JavaSE\day01\code\HelloWorld案例</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CCS5.5——快速傅里叶变换(FFT)</title>
      <link href="/2020/052749146.html"/>
      <url>/2020/052749146.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h1><p>1、离散傅里叶变换DFT的定义：将时域的采样变换成频域的周期性离散函数，频域的采样也可以变换成时域的周期性离散函数，这样的变化称为离散傅里叶变换，简称DFT。  </p><p>2、FFT是DFT的一种快速算法。由于在计算DFT是一次复数乘法需用四次实数乘法和两次实数加法；一次复数加法需要两次实数加法。每运算一个X(k)需要4N次复数乘法及 实数加法。所以整个DFT运算总共需要 次实数乘法及 次实数加法。如此，计算时乘法次数和加法次数都是和 成正比的，当N很大时，运算量是客观的，因而需要改进带DFT的算法减少运算速度。  </p><p>根据傅里叶变换的对称性和周期性，我们可以将DFT运算中有些项合并。假设序列长度为 ,L为整数。将 的序列x(n)(n=0,1,…,N-1),按N的奇偶分成两组，分解成两个N/2点的DFT，重新组合成一个如下式表达的N点DFT:<br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P05271.jpg" alt="">  </p><p>将DFT的 步运算减少为 步，极大地提高了运算的速度；  </p><p>3、    旋转因子的变化规律；  </p><p>4、    碟形运算规律；  </p><p>5、    基于2FFT算法。  </p><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P05272.jpg" alt=""></p><h1 id="2-记录实验数据"><a href="#2-记录实验数据" class="headerlink" title="2.记录实验数据"></a>2.记录实验数据</h1><p>按照图6-2，3进行输入信号时域，频域以及输出信号时域波形的设置。<br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P05273.jpg" alt=""><br>输入信号及输出信号的波形如图6-4,5,6所示：<br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P05274.jpg" alt=""><br>代码：</p><pre><code>#include&quot;math.h&quot;#define PI 3.1415926#define SAMPLENUMBER 128void InitForFFT();void MakeWave();int INPUT[SAMPLENUMBER],DATA[SAMPLENUMBER];float fWaveR[SAMPLENUMBER],fWaveI[SAMPLENUMBER],w[SAMPLENUMBER];float sin_tab[SAMPLENUMBER],cos_tab[SAMPLENUMBER];void FFT(float dataR[SAMPLENUMBER],float dataI[SAMPLENUMBER]){    int x0, x1, x2, x3, x4, x5, x6, xx;    int i, j, k, b, p, L;    float TR, TI, temp;/***************fllowing code invert sequence***************/    for( i = 0; i &lt; SAMPLENUMBER; i++)    {        x0=x1=x2=x3=x4=x5=x6=0;        x0=i&amp;0x01;x1=(i/2)&amp;0x01;x2=(i/4)&amp;0x01;x3=(i/8)&amp;0x01;x4=(i/16)&amp;0x01;x5=(i/32)&amp;0x01;x6=(i/64)&amp;0x01;        xx=x0*64+x1*32+x2*16+x3*8+x4*4+x5*2+x6;        dataI[xx]=dataR[i];    }    for( i = 0; i &lt; SAMPLENUMBER; i++)    {        dataR[i]=dataI[i];dataI[i]=0;    }/***********fllowing code FFT***************/    for( L = 1; L &lt;= 7; L++)    {        b=1;i=L-1;        while( i &gt; 0 ){            b=b*2;i--;        }/*b= 2^(L-1)*/        for( j = 0; j &lt;= b-1; j++ )        {            p=1;i=7-L;            while( i &gt; 0 ) /*p=pow(2,7-L)*j;*/            {                p=p*2;i--;            }            p=p*j;            for( k = j; k &lt; 128; k = k+2*b )            {                TR=dataR[k];TI=dataI[k];temp=dataR[k+b];                dataR[k]=dataR[k]+dataR[k+b]*cos_tab[p]+dataI[k+b]*sin_tab[p];                dataI[k]=dataI[k]-dataR[k+b]*sin_tab[p]+dataI[k+b]*cos_tab[p];                dataR[k+b]=TR-dataR[k+b]*cos_tab[p]-dataI[k+b]*sin_tab[p];                dataI[k+b]=TI+temp*sin_tab[p]-dataI[k+b]*cos_tab[p];            }        }    }    for( i = 0; i &lt; SAMPLENUMBER/2; i++)    {        w[i]=sqrt(dataR[i]*dataR[i]+dataI[i]*dataI[i]);    }}/*END FFT*/main(){    int i;    InitForFFT();    MakeWave();    for( i = 0; i &lt; SAMPLENUMBER; i++)    {        fWaveR[i]=INPUT[i];        fWaveI[i]=0.0f;        w[i]=0.0f;    }    FFT(fWaveR,fWaveI);    for(i = 0; i &lt; SAMPLENUMBER; i++)    {        DATA[i]=w[i];    }    while(1);  //break point}void InitForFFT(){    int i;    for(i = 0; i &lt; SAMPLENUMBER; i++)    {        sin_tab[i]=sin(PI*2*i/SAMPLENUMBER);        cos_tab[i]=cos(PI*2*i/SAMPLENUMBER);    }}void MakeWave(){    int i;    for( i=0; i&lt;SAMPLENUMBER; i++ )    {        INPUT[i]=sin(PI*2*i/SAMPLENUMBER*3)*1024;    }}  </code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客之备份与恢复</title>
      <link href="/2020/050127743.html"/>
      <url>/2020/050127743.html</url>
      
        <content type="html"><![CDATA[<h1 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h1><p>1、在你的博客仓库创建一个分支<code>hexo</code>（这个命名随意）；</p><p>2、设置<code>hexo</code>为默认分支（不知道怎么设的可以百度）；<br>( <font color="ff0000">第一步和第二步都在<a href="https://github.com/" target="_blank" rel="noopener">github</a>网站中操作</font>)  </p><p>3、将博客仓库<code>hexo分支</code>clone至本地，<br>在本地新建一个文件夹<code>hexo</code>，并在此文件夹中右击鼠标打开<code>git bash</code>,执行命令  </p><pre><code>git clone git@github.com:Username/Username.github.io.git  </code></pre><p>(<font color="ff0000"><code>Username</code>为你自己的名字</font>)<br>克隆完之后在<code>hexo</code>文件夹中会出现新的Username.github.io文件夹，将其中的文件全部删除，只保留<code>.git\</code>文件夹。</p><p>将之前的博客根目录文件夹中的<br><code>_config.yml</code>，<code>themes/</code>，<code>source</code>，<code>scffolds/</code>，<code>package.json</code>，<code>.gitignore</code>复制到Username.github.io文件夹；（<code>Username</code>是你自己的用户名）</p><a id="more"></a><p>4、将themes/next/(是NexT主题)中的<code>.git/</code>删除，否则无法将主题文件夹<code>push</code>；( <font color="ff0000"><code>matery</code>主题中没有这个文件夹，应该就不用删除了</font>)</p><p>5、在Username.github.io文件夹执行<code>git add .</code>，<code>git commit -m &quot;提交文件&quot;</code>，<code>git push origin hexo</code>来提交hexo网站源文件；( <font color="ff0000">命令中的<code>hexo</code>为你创建的分支的名字</font>)    </p><p>6、执行<code>hexo g -d</code>生成静态网页部署到github上。<br>这样，Username.github.io仓库就有master分支保存静态网页，hexo分支保存源文件。<br>到这里备份就完成了。  </p><h1 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h1><h2 id="此后所有的博客操作都在Username-github-io文件夹中进行"><a href="#此后所有的博客操作都在Username-github-io文件夹中进行" class="headerlink" title="( 此后所有的博客操作都在Username.github.io文件夹中进行)"></a>( <font color="ff0000">此后所有的博客操作都在Username.github.io文件夹中进行</font>)</h2><h3 id="在本地对博客修改（包括修改主题样式、发布新文章等）后在Username-github-io文件夹中依次执行命令"><a href="#在本地对博客修改（包括修改主题样式、发布新文章等）后在Username-github-io文件夹中依次执行命令" class="headerlink" title="在本地对博客修改（包括修改主题样式、发布新文章等）后在Username.github.io文件夹中依次执行命令"></a>在本地对博客修改（包括修改主题样式、发布新文章等）后在Username.github.io文件夹中依次执行命令</h3><pre><code>git add .  git commit -m &quot;提交文件  git push origin hexo  hexo g -d  </code></pre><p>即在每次修改完本地博客后重复执行5、6步来完成来提交hexo网站源文件和生成静态网页部署到github上。  </p><h1 id="恢复博客"><a href="#恢复博客" class="headerlink" title="恢复博客"></a>恢复博客</h1><p>换电脑想改博客：  </p><p>1、安装git；  </p><p>2、安装Nodejs和npm；  </p><p>3、使用克隆命令<code>git clone git@github.com:Username/Username.github.io.git</code>将仓库拷贝至本地；  </p><p>4、在文件夹内执行命令<code>npm install hexo-cli -g</code>、<code>npm install</code>、<code>npm install hexo-deployer-git</code>；</p><h2 id="添加ssh-keys"><a href="#添加ssh-keys" class="headerlink" title="添加ssh-keys"></a>添加ssh-keys</h2><p>在终端下运行：<code>ssh-keygen -t rsa -C &quot;yourname@email.com&quot;</code>，一路回车；<br>会在.ssh目录生成<code>id_rsa</code>、<code>id_rsa.pub</code>两个文件，这就是密钥对，<code>id_rsa</code>是私钥，千万不能泄漏出去；  </p><p>登录<a href="https://github.com/" target="_blank" rel="noopener">Github</a>，打开「Settings」–&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥<code>id_rsa.pub</code>文件的内容，注意不要粘贴成<code>id_rsa</code>，最后点击「Add SSH Key」。</p><blockquote><p><font color="ff0000">版权声明：本文为个人总结，欢迎转载，转载请注明出处，勿用于商业用途！</font>   </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网站搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建Hexo+Coding(最新教程)</title>
      <link href="/2020/042226283.html"/>
      <url>/2020/042226283.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-Hexo搭建"><a href="#1-Hexo搭建" class="headerlink" title="1. Hexo搭建"></a>1. Hexo搭建</h1><h2 id="1-nodejs，Git环境搭建："><a href="#1-nodejs，Git环境搭建：" class="headerlink" title="1.nodejs，Git环境搭建："></a>1.nodejs，Git环境搭建：</h2><ul><li><a href="https://blog.csdn.net/qq_43285335/article/details/90696126" target="_blank" rel="noopener">node.js搭建</a> </li><li><a href="https://www.cnblogs.com/xueweisuoyong/p/11914045.html" target="_blank" rel="noopener">git搭建</a>-<br><a href="https://www.cnblogs.com/luyuandatabase/p/12145707.html" target="_blank" rel="noopener">淘宝云配置</a> </li></ul><h2 id="2-注册github"><a href="#2-注册github" class="headerlink" title="2.注册github"></a>2.注册github</h2><ol><li>注册就不用我说了，创建仓库视频里有，然后这个也很简单，不会就百度（应该没人去百度<br>的，太简单了）</li><li>格式要求：gfyuan.github.io</li></ol><h2 id="3-快速利用hexo搭建博客："><a href="#3-快速利用hexo搭建博客：" class="headerlink" title="3.快速利用hexo搭建博客："></a>3.快速利用hexo搭建博客：</h2><p> 1.<a href="https://hexoscript.gitbook.io/hexo-script/" target="_blank" rel="noopener">Hexo脚本教程</a>  </p><p> 2.<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">主题安装及优化</a>  </p><h1 id="2-Coding创建项目"><a href="#2-Coding创建项目" class="headerlink" title="2.Coding创建项目"></a>2.Coding创建项目</h1><h3 id="1-首先，去Coding官网注册一个账号，接着，点击“-创建项目”-创建一个新项目。"><a href="#1-首先，去Coding官网注册一个账号，接着，点击“-创建项目”-创建一个新项目。" class="headerlink" title="1.首先，去Coding官网注册一个账号，接着，点击“+ 创建项目”,创建一个新项目。"></a>1.首先，去Coding<a href="coding.net">官网注册</a>一个账号，接着，点击“+ 创建项目”,创建一个新项目。</h3><ul><li>选择项目模板<br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P052211.jpg" alt=""><ul><li>创建项目<br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P052212.jpg" alt=""> <h3 id="2-同步本地hexo到coding上"><a href="#2-同步本地hexo到coding上" class="headerlink" title="2.同步本地hexo到coding上"></a>2.同步本地hexo到coding上</h3>把获取到了ssh配置在上面的<code>_config.yml</code>文件中的deploy下，<pre><code>deploy:type: gitrepo:    github: git@github.com:你的用户名/你的仓库名.github.io.git   coding: git@e.coding.net:你的用户名/你的仓库名.gitbranch: master</code></pre>如果是第一次使用coding的话，需要设置SSH公钥，生成的方法可以参考<a href="https://help.coding.net/" target="_blank" rel="noopener">coding帮助中心</a>   </li></ul></li></ul><p>当然这里直接使用之前部署github时已经生成的公钥。<br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P052213.jpg" alt="">    </p><p>添加后，在<code>git bash</code>命令输入：</p><pre><code>ssh -T git@git.coding.net</code></pre><p>如果得到下面提示就表示公钥添加成功了：</p><pre><code>Coding.net Tips : [Hello ! You&#39;ve conected to Coding.net by SSH successfully! ]</code></pre><p>最后使用部署命令就能把博客同步到coding上面：</p><pre><code>hexo g -d</code></pre><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P052214.jpg" alt=""> </p><h1 id="3-pages服务方式部署"><a href="#3-pages服务方式部署" class="headerlink" title="3.pages服务方式部署"></a>3.pages服务方式部署</h1><ul><li><p>你在你的仓库里是找不到pages页面的需要进行以下操作<br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P1.png" alt="">   </p><ul><li>勾选上持续部署和持续集成<br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P2.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P3.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P4.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P5.png" alt=""><br>然后就可通过访问地址访问自己的博客啦！</li></ul></li><li><p>如果你有自己的私人域名也可以绑定自己的域名<br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P6.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P7.png" alt="">  然后在你的域名服务台解析到你的博客访问地址即可通过域名访问博客。  </p></li></ul><blockquote><p><font color="ff0000">版权声明：本文为个人总结，欢迎转载，转载请注明出处，勿用于商业用途！</font>  </p></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1443900438&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> 网站搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你若安好，便是晴天</title>
      <link href="/2020/032134362.html"/>
      <url>/2020/032134362.html</url>
      
        <content type="html"><![CDATA[<hr><p> 晨起，窗外的阳光已是浩浩荡荡，远山苍绿如黛。夏天，就这样不慌不忙地来到身边，草木深深，风华绝代。</p><p>人生匆匆的聚散里，往事如烟，陌上花开如旧，而我们，却在凡俗的烟火里，承担岁月带给我们的浮世沧桑。青梅煮酒，一如旧时的味道，而那些走散的人，却再不会再回来。</p><p>我们都是光阴里的过客，有些人只是擦肩而过，有些人会短暂的停留，而有些人会携手白头。凡尘的烟火缭绕，我们总是在如烟的世海里丢了自己。岁月，偷换的又岂止是青春红颜，还有那些最初的情怀。</p><p>我们都只是拥挤红尘里孤独的赶路人，寂寞时，我们需要回忆相伴；迷茫时，我们需要情怀偎依取暖。</p><p>世间所有女子都曾如精灵般存在，或是柔情，或是灵动，在光阴里含笑，为一场雨动情。爱人间的莺歌燕舞，爱江南的山温水软，爱世间一切美好的东西。</p><p>世间所有女子都曾有过绝代的风华，有些人将这风华酿成一坛芬芳的酒酿，沉醉岁月；而有些，却在生活的枝头渐次苍白，一一凋落。</p><p>生活百味纷杂，尝过人情世味，看过世态炎凉，浸泡在红尘的染缸里，她们都不复当初的模样。世事如刀，所有最初的情怀、柔肠和优雅，被一点点削减。 </p><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/MoreInterests-PIC21a87bce-674a-4981-b056-60c22a7935d3.jpg" alt=""> </p><p>风景生动的城里，古城温暖的阳光里，江南水乡的石桥上，总有那怀着温润洁净情怀的女子走过；寻常的巷陌里，小镇的溪水旁，乡间的田野里，总有女子在为生活而奔忙。从她们降生在人间开始，便有万千色彩的故事等着她们去演绎。有悲欢，有离合，有酸甜，有苦辣。</p><p>不知在什么时候，便喜欢上这两个字：惜缘。佛说，前世五百次的回眸，换来今生的擦肩而过。</p><p>张爱玲也说：于千万人之中遇见你所要遇见的人, 于千万年之中, 时间的无涯的荒野里, 没有早一步, 也没有晚一步, 刚巧赶上了, 没有别的话可说, 惟有轻轻地问一声: “ 噢, 你也在这里?”</p><p>可见人与人的相遇是多么难得的缘分，所以我们应该学会珍惜，任何错过和伤害都是对缘分的蹉跎。</p><p>有时，行走在摩肩接踵的人群中，心中便会涌出莫名的感动，每一个来来去去的生命，都有他们的烟火幸福，有他们完整的故事。</p><p>邂逅一个人，只需片刻，爱上一个人，往往会是一生。</p><p>徐志摩说：一生至少该有一次,为了某个人而忘了自己,不求结果,不求同行,不求曾经拥有,甚至不求你爱我.只求在我最美的年华里,遇见你！</p><p>爱上一个人，是涅槃，亦是重生。因为爱了，所以听风含情，花柳带笑；因为爱了，所以感时花溅泪，恨别鸟惊心；因为爱了！   </p><hr><pre><code>                         初心亦在 有缘再见</code></pre>]]></content>
      
      
      <categories>
          
          <category> 美文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 情感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Github博客搭建入门</title>
      <link href="/2020/031034155.html"/>
      <url>/2020/031034155.html</url>
      
        <content type="html"><![CDATA[<h1 id="网站搭建"><a href="#网站搭建" class="headerlink" title="网站搭建"></a>网站搭建</h1><h2 id="安装需要的编辑软件"><a href="#安装需要的编辑软件" class="headerlink" title="安装需要的编辑软件"></a>安装需要的编辑软件</h2><ul><li>Typora<br>个人建议在国内的软件上下载，不要去官网，下载慢  </li><li>vs code<br>轻量级文档编辑器  </li></ul><h2 id="1-nodejs，Git环境搭建："><a href="#1-nodejs，Git环境搭建：" class="headerlink" title="1.nodejs，Git环境搭建："></a>1.nodejs，Git环境搭建：</h2><ul><li><a href="https://blog.csdn.net/qq_43285335/article/details/90696126" target="_blank" rel="noopener">node.js搭建</a> </li><li><a href="https://www.cnblogs.com/xueweisuoyong/p/11914045.html" target="_blank" rel="noopener">git搭建</a>-<br><a href="https://www.cnblogs.com/luyuandatabase/p/12145707.html" target="_blank" rel="noopener">淘宝云配置</a> </li></ul><h2 id="2-注册github"><a href="#2-注册github" class="headerlink" title="2.注册github"></a>2.注册github</h2><ol><li>注册就不用我说了，创建仓库视频里有，然后这个也很简单，不会就百度（应该没人去百度<br>的，太简单了）</li><li>格式要求：gfyuan.github.io</li></ol><h2 id="3-快速利用hexo搭建博客："><a href="#3-快速利用hexo搭建博客：" class="headerlink" title="3.快速利用hexo搭建博客："></a>3.快速利用hexo搭建博客：</h2><p> 1.<a href="https://hexoscript.gitbook.io/hexo-script/" target="_blank" rel="noopener">脚本教程</a>  </p><p> 2.<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">主题安装及优化</a> </p><p> <a href="https://www.jianshu.com/p/1e402922ee32" target="_blank" rel="noopener">Markdown入门</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客撰写教程</title>
      <link href="/2020/022054914.html"/>
      <url>/2020/022054914.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Markdown——入门指南"><a href="#1-Markdown——入门指南" class="headerlink" title="1.Markdown——入门指南"></a>1.Markdown——入门指南</h2><h1 id="导语："><a href="#导语：" class="headerlink" title="导语："></a>导语：</h1><p>Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的 HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。 </p><h2 id="Markdown-语法的简要规则"><a href="#Markdown-语法的简要规则" class="headerlink" title="Markdown 语法的简要规则"></a>Markdown 语法的简要规则</h2><ul><li><p>标题 </p><p>  #一级标题</p><p>  ##二级标题</p><p>  ###三级标题 </p></li><li><p>无序列表  </p></li></ul><p>*1<br>*2<br>*3</p><ul><li>有序列表   </li></ul><p>1.1<br>1.2<br>1.3  </p><ul><li>图片与链接<br>图片为：! [ ] ( )<br>链接为：[ ] ( )  </li><li>粗体  </li></ul><p><strong>中文本为斜体<br>**</strong>中为粗体  </p><ul><li>分割线<br>三个*为分割线  </li><li>代码框<br>一个``<br>例如：<br><code>if(a&lt;b)   {c=b;}</code>     </li><li>行内代码  <pre><code>coding: git@e.coding.net:</code></pre></li></ul><p><a href="https://www.jianshu.com/p/1e402922ee32" target="_blank" rel="noopener">文章出处</a>  </p><hr><h2 id="2-文章-Front-matter-介绍"><a href="#2-文章-Front-matter-介绍" class="headerlink" title="2.文章 Front-matter 介绍"></a>2.文章 Front-matter 介绍</h2><p>Front-matter 选项详解<br>Front-matter 选项中的所有内容均为非必填的。但我仍然建议至少填写 title 和 date 的值。</p><p>配置选项    默认值    描述<br><strong>title</strong>    Markdown 的文件标题    文章标题，强烈建议填写此选项<br><strong>date</strong>    文件创建时的日期时间    发布时间，强烈建议填写此选项，且最好保证全局唯一<br><strong>author</strong>    根 _config.yml 中的 author    文章作者<br><strong>img</strong>    featureImages 中的某个值    文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <a href="http://xxx.com/xxx.jpg" target="_blank" rel="noopener">http://xxx.com/xxx.jpg</a></p><p>  其余规则见<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">文章出处</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/021516107.html"/>
      <url>/2020/021516107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
