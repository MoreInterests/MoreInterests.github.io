<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java-day10</title>
      <link href="/2020/061047836.html"/>
      <url>/2020/061047836.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-形式参数和返回值的问题-理解"><a href="#1-形式参数和返回值的问题-理解" class="headerlink" title="1:形式参数和返回值的问题(理解)"></a>1:形式参数和返回值的问题(理解)</h2><h3 id="1-形式参数："><a href="#1-形式参数：" class="headerlink" title="(1)形式参数："></a>(1)形式参数：</h3><pre><code>    类名：需要该类的对象    抽象类名：需要该类的子类对象    接口名：需要该接口的实现类对象</code></pre><h3 id="2-返回值类型："><a href="#2-返回值类型：" class="headerlink" title="(2)返回值类型："></a>(2)返回值类型：</h3><pre><code>    类名：返回的是该类的对象    抽象类名：返回的是该类的子类对象    接口名：返回的是该接口的实现类的对象</code></pre><h3 id="3-链式编程"><a href="#3-链式编程" class="headerlink" title="(3)链式编程"></a>(3)链式编程</h3><pre><code>    对象.方法1().方法2().......方法n();    这种用法：其实在方法1()调用完毕后，应该一个对象；              方法2()调用完毕后，应该返回一个对象。              方法n()调用完毕后，可能是对象，也可以不是对象。</code></pre><h2 id="2-包-理解"><a href="#2-包-理解" class="headerlink" title="2:包(理解)"></a>2:包(理解)</h2><h3 id="1-其实就是文件夹"><a href="#1-其实就是文件夹" class="headerlink" title="(1)其实就是文件夹"></a>(1)其实就是文件夹</h3><h3 id="2-作用："><a href="#2-作用：" class="headerlink" title="(2)作用："></a>(2)作用：</h3><pre><code>    A:区分同名的类    B:对类进行分类管理        a:按照功能分        b:按照模块分</code></pre><h3 id="3-包的定义-掌握"><a href="#3-包的定义-掌握" class="headerlink" title="(3)包的定义(掌握)"></a>(3)包的定义(掌握)</h3><pre><code>    package 包名;    多级包用.分开。</code></pre><h3 id="4-注意事项：-掌握"><a href="#4-注意事项：-掌握" class="headerlink" title="(4)注意事项：(掌握)"></a>(4)注意事项：(掌握)</h3><pre><code>    A:package语句必须在文件中的第一条有效语句    B:在一个java文件中，只能有一个package    C:如果没有package，默认就是无包名</code></pre><h3 id="5-带包的编译和运行"><a href="#5-带包的编译和运行" class="headerlink" title="(5)带包的编译和运行"></a>(5)带包的编译和运行</h3><pre><code>    A:手动式    B:自动式(掌握)        javac -d . HelloWorld.java</code></pre><h2 id="3-导包-掌握"><a href="#3-导包-掌握" class="headerlink" title="3:导包(掌握)"></a>3:导包(掌握)</h2><h3 id="1-我们多次使用一个带包的类，非常的麻烦，这个时候，Java就提供了一个关键字import。"><a href="#1-我们多次使用一个带包的类，非常的麻烦，这个时候，Java就提供了一个关键字import。" class="headerlink" title="(1)我们多次使用一个带包的类，非常的麻烦，这个时候，Java就提供了一个关键字import。"></a>(1)我们多次使用一个带包的类，非常的麻烦，这个时候，Java就提供了一个关键字import。</h3><h3 id="2-格式："><a href="#2-格式：" class="headerlink" title="(2)格式："></a>(2)格式：</h3><pre><code>    import 包名...类名;    另一种：        import 包名...*;(不建议)</code></pre><h3 id="3-package-import-class的顺序"><a href="#3-package-import-class的顺序" class="headerlink" title="(3)package,import,class的顺序"></a>(3)package,import,class的顺序</h3><pre><code>    package &gt; import &gt; class</code></pre><h2 id="4-权限修饰符-掌握"><a href="#4-权限修饰符-掌握" class="headerlink" title="4:权限修饰符(掌握)"></a>4:权限修饰符(掌握)</h2><h3 id="1-权限修饰符"><a href="#1-权限修饰符" class="headerlink" title="(1)权限修饰符"></a>(1)权限修饰符</h3><pre><code>                本类    同一个包下    不同包下的子类    不同包下的无关类    private        Y    默认        Y        Y    protected    Y        Y            Y    public        Y        Y            Y                Y</code></pre><h3 id="2-这四种权限修饰符在任意时刻只能出现一种。"><a href="#2-这四种权限修饰符在任意时刻只能出现一种。" class="headerlink" title="(2)这四种权限修饰符在任意时刻只能出现一种。"></a>(2)这四种权限修饰符在任意时刻只能出现一种。</h3><pre><code>    public class Demo {}        </code></pre><h2 id="5-常见的修饰符-理解"><a href="#5-常见的修饰符-理解" class="headerlink" title="5:常见的修饰符(理解)"></a>5:常见的修饰符(理解)</h2><h3 id="1-分类："><a href="#1-分类：" class="headerlink" title="(1)分类："></a>(1)分类：</h3><pre><code>    权限修饰符：private,默认,protected,public    状态修饰符：static,final    抽象修饰符：abstract</code></pre><h3 id="2-常见的类及其组成的修饰"><a href="#2-常见的类及其组成的修饰" class="headerlink" title="(2)常见的类及其组成的修饰"></a>(2)常见的类及其组成的修饰</h3><pre><code>    类：        默认,public,final,abstract        常用的：public    成员变量：        private,默认,protected,public,static,final        常用的：private    构造方法：        private,默认,protected,public        常用的：public    成员方法：        private,默认,protected,public,static,final,abstract        常用的：public</code></pre><h3 id="3-另外比较常见的："><a href="#3-另外比较常见的：" class="headerlink" title="(3)另外比较常见的："></a>(3)另外比较常见的：</h3><pre><code>    public static final int X = 10;    public static void show() {}    public final void show() {}    public abstract void show();</code></pre><h2 id="6-内部类-理解"><a href="#6-内部类-理解" class="headerlink" title="6:内部类(理解)"></a>6:内部类(理解)</h2><h3 id="1-把类定义在另一个类的内部，该类就被称为内部类。"><a href="#1-把类定义在另一个类的内部，该类就被称为内部类。" class="headerlink" title="(1)把类定义在另一个类的内部，该类就被称为内部类。"></a>(1)把类定义在另一个类的内部，该类就被称为内部类。</h3><pre><code>    举例：把类B定义在类A中，类B就被称为内部类。</code></pre><h3 id="2-内部类的访问规则"><a href="#2-内部类的访问规则" class="headerlink" title="(2)内部类的访问规则"></a>(2)内部类的访问规则</h3><pre><code>    A:可以直接访问外部类的成员，包括私有    B:外部类要想访问内部类成员，必须创建对象</code></pre><h3 id="3-内部类的分类"><a href="#3-内部类的分类" class="headerlink" title="(3)内部类的分类"></a>(3)内部类的分类</h3><pre><code>    A:成员内部类    B:局部内部类</code></pre><h3 id="4-成员内部类"><a href="#4-成员内部类" class="headerlink" title="(4)成员内部类"></a>(4)成员内部类</h3><pre><code>    A:private 为了数据的安全性    B:static 为了访问的方便性    成员内部类不是静态的：        外部类名.内部类名 对象名 = new 外部类名.new 内部类名();    成员内部类是静态的：        外部类名.内部类名 对象名 = new 外部类名.内部类名();</code></pre><h3 id="5-成员内部类的面试题-填空"><a href="#5-成员内部类的面试题-填空" class="headerlink" title="(5)成员内部类的面试题(填空)"></a>(5)成员内部类的面试题(填空)</h3><pre><code>    30,20,10    class Outer {        public int num = 10;        class Inner {            public int num = 20;            public viod show() {                int num  = 30;                System.out.println(num);                System.out.println(this.num);                System.out.println(Outer.this.num);            }        }    }</code></pre><h3 id="6-局部内部类"><a href="#6-局部内部类" class="headerlink" title="(6)局部内部类"></a>(6)局部内部类</h3><pre><code>    A:局部内部类访问局部变量必须加final修饰。    B:为什么呢?        因为局部变量使用完毕就消失，而堆内存的数据并不会立即消失。        所以，堆内存还是用该变量，而改变量已经没有了。        为了让该值还存在，就加final修饰。        通过反编译工具我们看到了，加入final后，堆内存直接存储的是值，而不是变量名。</code></pre><h3 id="7-匿名内部类-掌握"><a href="#7-匿名内部类-掌握" class="headerlink" title="(7)匿名内部类(掌握)"></a>(7)匿名内部类(掌握)</h3><pre><code>    A:是局部内部类的简化形式    B:前提        存在一个类或者接口    C:格式:        new 类名或者接口名() {            重写方法;        }    D:本质：        其实是继承该类或者实现接口的子类匿名对象</code></pre><h3 id="8-匿名内部类在开发中的使用"><a href="#8-匿名内部类在开发中的使用" class="headerlink" title="(8)匿名内部类在开发中的使用"></a>(8)匿名内部类在开发中的使用</h3><pre><code>    我们在开发的时候，会看到抽象类，或者接口作为参数。    而这个时候，我们知道实际需要的是一个子类对象。    如果该方法仅仅调用一次，我们就可以使用匿名内部类的格式简化。    interface Person {        public abstract void study();    }    class PersonDemo {        public void method(Person p) {            p.study();        }    }    class PersonTest {        public static void main(String[] args) {            PersonDemo pd = new PersonDemo();            pd.method(new Person() {                public void study() {                    System.out.println(&quot;好好学习，天天向上&quot;);                }            });        }    }</code></pre><h3 id="9-匿名内部类的面试题-补齐代码"><a href="#9-匿名内部类的面试题-补齐代码" class="headerlink" title="(9)匿名内部类的面试题(补齐代码)"></a>(9)匿名内部类的面试题(补齐代码)</h3><pre><code>    interface Inter {        void show();    }    class Outer {        //补齐代码        public static Inter method() {            return new Inter() {                public void show() {                    System.out.println(&quot;HelloWorld&quot;);                }                };        }    }    class OuterDemo {        public static void main(String[] args) {            Outer.method().show(); //&quot;HelloWorld&quot;        }    }</code></pre><hr><p>1:形式参数和返回值问题   </p><pre><code>形式参数    基本类型    类名：需要该类的对象    引用类型    抽象类名：需要改类的子类对象                接口名：需要该接口的实现类对象返回值类型    基本类型    类名：返回的是该类的对象    引用类型    抽象类名：返回的是该类的子类对象                接口名：返回的是该接口的实现类的对象</code></pre><p>2:包的定义及注意事项  </p><pre><code>定义：package 报名;注意事项    A：package语句必须在文件中的定义一条有效语句            B：在一个Java文件中，只能有一个package            C：如果没有package，默认就是无包名</code></pre><p>3:导包及注意事项  </p><pre><code>（1）我们多次使用一个带包的类，非常麻烦，这个时候，Java就提供了一个关键字import（2）格式：            import 包名...类名；（3）package ，import，class的顺序        package&gt;import&gt;class</code></pre><p>4:四种权限修饰符及其特点  </p><pre><code>(1)权限修饰符                本类    同一个包下    不同包下的子类    不同包下的无关类    private        Y    默认        Y        Y    protected    Y        Y            Y    public        Y        Y            Y                Y(2)这四种权限修饰符在任意时刻只能出现一种。    public class Demo {}        </code></pre><p>5:常见的修饰符及组合  </p><pre><code>(1)分类：            权限修饰符：private,默认，protected，public            状态修饰符：static,final            抽象修饰符：abstract(2)常见的类及其组成的修饰    类：        默认,public,final,abstract        常用的：public    成员变量：        private,默认,protected,public,static,final        常用的：private    构造方法：        private,默认,protected,public        常用的：public    成员方法：        private,默认,protected,public,static,final,abstract        常用的：public(3)另外比较常见的：    public static final int X = 10;    public static void show() {}    public final void show() {}    public abstract void show();        </code></pre><p>6:内部类的概述及访问特点  </p><pre><code>(1)把类定义在另一个类的内部，该类就被称为内部类。    举例：把类B定义在类A中，类B就被称为内部类。(2)内部类的访问规则    A:可以直接访问外部类的成员，包括私有    B:外部类要想访问内部类成员，必须创建对象</code></pre><p>7:内部类的分类  </p><pre><code>(1)内部类的分类    A:成员内部类    B:局部内部类(2)成员内部类    A:private 为了数据的安全性    B:static 为了访问的方便性    成员内部类不是静态的：        外部类名.内部类名 对象名 = new 外部类名.new 内部类名();    成员内部类是静态的：        外部类名.内部类名 对象名 = new 外部类名.内部类名();(3)成员内部类的面试题(填空)    30,20,10    class Outer {        public int num = 10;        class Inner {            public int num = 20;            public viod show() {                int num  = 30;                System.out.println(num);                System.out.println(this.num);                System.out.println(Outer.this.num);            }        }    }(4)局部内部类    A:局部内部类访问局部变量必须加final修饰。    B:为什么呢?        因为局部变量使用完毕就消失，而堆内存的数据并不会立即消失。        所以，堆内存还是用该变量，而改变量已经没有了。        为了让该值还存在，就加final修饰。        通过反编译工具我们看到了，加入final后，堆内存直接存储的是值，而不是变量名。(5)匿名内部类(掌握)    A:是局部内部类的简化形式    B:前提        存在一个类或者接口    C:格式:        new 类名或者接口名() {            重写方法;        }    D:本质：        其实是继承该类或者实现接口的子类匿名对象</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day09</title>
      <link href="/2020/060911293.html"/>
      <url>/2020/060911293.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-final关键字-掌握"><a href="#1-final关键字-掌握" class="headerlink" title="1:final关键字(掌握)"></a>1:final关键字(掌握)</h2><h3 id="1-是最终的意思，可以修饰类，方法，变量。"><a href="#1-是最终的意思，可以修饰类，方法，变量。" class="headerlink" title="(1)是最终的意思，可以修饰类，方法，变量。"></a>(1)是最终的意思，可以修饰类，方法，变量。</h3><h3 id="2-特点："><a href="#2-特点：" class="headerlink" title="(2)特点："></a>(2)特点：</h3><pre><code>    A:它修饰的类，不能被继承。    B:它修饰的方法，不能被重写。    C:它修饰的变量，是一个常量。</code></pre><h3 id="3-面试相关："><a href="#3-面试相关：" class="headerlink" title="(3)面试相关："></a>(3)面试相关：</h3><pre><code>    A:局部变量        a:基本类型 值不能发生改变        b:引用类型 地址值不能发生改变，但是对象的内容是可以改变的    B:初始化时机        a:只能初始化一次。        b:常见的给值            定义的时候。(推荐)            构造方法中。</code></pre><h2 id="2-多态-掌握"><a href="#2-多态-掌握" class="headerlink" title="2:多态(掌握)"></a>2:多态(掌握)</h2><h3 id="1-同一个对象在不同时刻体现出来的不同状态。"><a href="#1-同一个对象在不同时刻体现出来的不同状态。" class="headerlink" title="(1)同一个对象在不同时刻体现出来的不同状态。"></a>(1)同一个对象在不同时刻体现出来的不同状态。</h3><h3 id="2-多态的前提："><a href="#2-多态的前提：" class="headerlink" title="(2)多态的前提："></a>(2)多态的前提：</h3><pre><code>    A:有继承或者实现关系。    B:有方法重写。    C:有父类或者父接口引用指向子类对象。    多态的分类：        a:具体类多态            class Fu {}            class Zi extends Fu {}            Fu f = new Zi();        b:抽象类多态            abstract class Fu {}            class Zi extends Fu {}            Fu f = new Zi();        c:接口多态            interface Fu {}            class Zi implements Fu {}            Fu f = new Zi();</code></pre><h3 id="3-多态中的成员访问特点"><a href="#3-多态中的成员访问特点" class="headerlink" title="(3)多态中的成员访问特点"></a>(3)多态中的成员访问特点</h3><pre><code>    A:成员变量        编译看左边，运行看左边    B:构造方法        子类的构造都会默认访问父类构造    C:成员方法        编译看左边，运行看右边    D:静态方法        编译看左边，运行看左边    为什么?        因为成员方法有重写。</code></pre><h3 id="4-多态的好处："><a href="#4-多态的好处：" class="headerlink" title="(4)多态的好处："></a>(4)多态的好处：</h3><pre><code>    A:提高代码的维护性(继承体现)    B:提高代码的扩展性(多态体现)</code></pre><h3 id="5-多态的弊端："><a href="#5-多态的弊端：" class="headerlink" title="(5)多态的弊端："></a>(5)多态的弊端：</h3><pre><code>    父不能使用子的特有功能。    现象：        子可以当作父使用，父不能当作子使用。</code></pre><h3 id="6-多态中的转型"><a href="#6-多态中的转型" class="headerlink" title="(6)多态中的转型"></a>(6)多态中的转型</h3><pre><code>    A:向上转型        从子到父    B:向下转型        从父到子</code></pre><h3 id="7-孔子装爹的案例帮助大家理解多态"><a href="#7-孔子装爹的案例帮助大家理解多态" class="headerlink" title="(7)孔子装爹的案例帮助大家理解多态"></a>(7)孔子装爹的案例帮助大家理解多态</h3><h3 id="8-多态的练习"><a href="#8-多态的练习" class="headerlink" title="(8)多态的练习"></a>(8)多态的练习</h3><pre><code>    A:猫狗案例    B:老师和学生案例</code></pre><h2 id="3-抽象类-掌握"><a href="#3-抽象类-掌握" class="headerlink" title="3:抽象类(掌握)"></a>3:抽象类(掌握)</h2><h3 id="1-把多个共性的东西提取到一个类中，这是继承的做法。"><a href="#1-把多个共性的东西提取到一个类中，这是继承的做法。" class="headerlink" title="(1)把多个共性的东西提取到一个类中，这是继承的做法。"></a>(1)把多个共性的东西提取到一个类中，这是继承的做法。</h3><pre><code>   但是呢，这多个共性的东西，在有些时候，方法声明一样，但是方法体。   也就是说，方法声明一样，但是每个具体的对象在具体实现的时候内容不一样。   所以，我们在定义这些共性的方法的时候，就不能给出具体的方法体。   而一个没有具体的方法体的方法是抽象的方法。   在一个类中如果有抽象方法，该类必须定义为抽象类。</code></pre><h3 id="2-抽象类的特点"><a href="#2-抽象类的特点" class="headerlink" title="(2)抽象类的特点"></a>(2)抽象类的特点</h3><pre><code>    A:抽象类和抽象方法必须用关键字abstract修饰    B:抽象类中不一定有抽象方法,但是有抽象方法的类一定是抽象类    C:抽象类不能实例化    D:抽象类的子类        a:是一个抽象类。        b:是一个具体类。这个类必须重写抽象类中的所有抽象方法。</code></pre><h3 id="3-抽象类的成员特点："><a href="#3-抽象类的成员特点：" class="headerlink" title="(3)抽象类的成员特点："></a>(3)抽象类的成员特点：</h3><pre><code>    A:成员变量        有变量，有常量    B:构造方法        有构造方法    C:成员方法        有抽象，有非抽象</code></pre><h3 id="4-抽象类的练习"><a href="#4-抽象类的练习" class="headerlink" title="(4)抽象类的练习"></a>(4)抽象类的练习</h3><pre><code>    A:猫狗案例练习    B:老师案例练习    C:学生案例练习    D:员工案例练习</code></pre><h3 id="5-抽象类的几个小问题"><a href="#5-抽象类的几个小问题" class="headerlink" title="(5)抽象类的几个小问题"></a>(5)抽象类的几个小问题</h3><pre><code>    A:抽象类有构造方法，不能实例化，那么构造方法有什么用?        用于子类访问父类数据的初始化    B:一个类如果没有抽象方法,却定义为了抽象类，有什么用?        为了不让创建对象    C:abstract不能和哪些关键字共存        a:final    冲突        b:private 冲突        c:static 无意义</code></pre><h2 id="4-接口-掌握"><a href="#4-接口-掌握" class="headerlink" title="4:接口(掌握)"></a>4:接口(掌握)</h2><h3 id="1-回顾猫狗案例，它们仅仅提供一些基本功能。"><a href="#1-回顾猫狗案例，它们仅仅提供一些基本功能。" class="headerlink" title="(1)回顾猫狗案例，它们仅仅提供一些基本功能。"></a>(1)回顾猫狗案例，它们仅仅提供一些基本功能。</h3><pre><code>   比如：猫钻火圈，狗跳高等功能，不是动物本身就具备的，   是在后面的培养中训练出来的，这种额外的功能，java提供了接口表示。</code></pre><h3 id="2-接口的特点："><a href="#2-接口的特点：" class="headerlink" title="(2)接口的特点："></a>(2)接口的特点：</h3><pre><code>    A:接口用关键字interface修饰        interface 接口名 {}    B:类实现接口用implements修饰        class 类名 implements 接口名 {}    C:接口不能实例化    D:接口的实现类        a:是一个抽象类。        b:是一个具体类，这个类必须重写接口中的所有抽象方法。</code></pre><h3 id="3-接口的成员特点："><a href="#3-接口的成员特点：" class="headerlink" title="(3)接口的成员特点："></a>(3)接口的成员特点：</h3><pre><code>    A:成员变量        只能是常量        默认修饰符：public static final    B:构造方法        没有构造方法    C:成员方法        只能是抽象的        默认修饰符：public abstract</code></pre><h3 id="4-类与类-类与接口-接口与接口"><a href="#4-类与类-类与接口-接口与接口" class="headerlink" title="(4)类与类,类与接口,接口与接口"></a>(4)类与类,类与接口,接口与接口</h3><pre><code>    A:类与类        继承关系，只能单继承，可以多层继承    B:类与接口        实现关系，可以单实现，也可以多实现。        还可以在继承一个类的同时，实现多个接口    C:接口与接口        继承关系，可以单继承，也可以多继承</code></pre><h3 id="5-抽象类和接口的区别-自己补齐"><a href="#5-抽象类和接口的区别-自己补齐" class="headerlink" title="(5)抽象类和接口的区别(自己补齐)?"></a>(5)抽象类和接口的区别(自己补齐)?</h3><pre><code>    A:成员区别        抽象类：        接口：    B:关系区别:        类与类：        类与接口：        接口与接口：    C:设计理念不同        抽象类：is a，抽象类中定义的是共性功能。        接口：like a，接口中定义的是扩展功能。</code></pre><h3 id="6-练习："><a href="#6-练习：" class="headerlink" title="(6)练习："></a>(6)练习：</h3><pre><code>    A:猫狗案例，加入跳高功能    B:老师和学生案例，加入抽烟功能0</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day08</title>
      <link href="/2020/060860636.html"/>
      <url>/2020/060860636.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-如何制作帮助文档-了解"><a href="#1-如何制作帮助文档-了解" class="headerlink" title="1:如何制作帮助文档(了解)"></a>1:如何制作帮助文档(了解)</h2><h3 id="1-写一个类"><a href="#1-写一个类" class="headerlink" title="(1)写一个类"></a>(1)写一个类</h3><h3 id="2-加入文档注释"><a href="#2-加入文档注释" class="headerlink" title="(2)加入文档注释"></a>(2)加入文档注释</h3><h3 id="3-通过javadoc工具生成即可"><a href="#3-通过javadoc工具生成即可" class="headerlink" title="(3)通过javadoc工具生成即可"></a>(3)通过javadoc工具生成即可</h3><pre><code>    javadoc -d 目录 -author -version ArrayTool.java</code></pre><h2 id="2-通过JDK提供的API学习了Math类-掌握"><a href="#2-通过JDK提供的API学习了Math类-掌握" class="headerlink" title="2:通过JDK提供的API学习了Math类(掌握)"></a>2:通过JDK提供的API学习了Math类(掌握)</h2><h3 id="1-API-Application-Programming-Interface"><a href="#1-API-Application-Programming-Interface" class="headerlink" title="(1)API(Application Programming Interface)"></a>(1)API(Application Programming Interface)</h3><pre><code>    应用程序编程接口(帮助文档)</code></pre><h3 id="2-如何使用呢"><a href="#2-如何使用呢" class="headerlink" title="(2)如何使用呢?"></a>(2)如何使用呢?</h3><pre><code>    请参照        day08\code\02_如何使用JDK提供的帮助文档\如何使用帮助文档.txt</code></pre><h3 id="3-Math类"><a href="#3-Math类" class="headerlink" title="(3)Math类"></a>(3)Math类</h3><pre><code>    A:是针对数学进行操作的类    B:没有构造方法，因为它的成员都是静态的    C:产生随机数        public static double random(): [0.0,1.0)    D:如何产生一个1-100之间的随机数        int number = (int)(Math.random()*100)+1;    E:猜数字小游戏</code></pre><h2 id="3-代码块-理解"><a href="#3-代码块-理解" class="headerlink" title="3:代码块(理解)"></a>3:代码块(理解)</h2><h3 id="1-用-括起来的代码。"><a href="#1-用-括起来的代码。" class="headerlink" title="(1)用{}括起来的代码。"></a>(1)用{}括起来的代码。</h3><h3 id="2-分类："><a href="#2-分类：" class="headerlink" title="(2)分类："></a>(2)分类：</h3><pre><code>    A:局部代码块        用于限定变量的生命周期，及早释放，提高内存利用率。    B:构造代码块        把多个构造方法中相同的代码可以放到这里，每个构造方法执行前，首先执行构造代码块。    C:静态代码块        对类的数据进行初始化，仅仅只执行一次。</code></pre><h3 id="3-静态代码块-构造代码块-构造方法的顺序问题"><a href="#3-静态代码块-构造代码块-构造方法的顺序问题" class="headerlink" title="(3)静态代码块,构造代码块,构造方法的顺序问题?"></a>(3)静态代码块,构造代码块,构造方法的顺序问题?</h3><pre><code>    静态代码块 &gt; 构造代码块 &gt; 构造方法</code></pre><h2 id="4-继承-掌握"><a href="#4-继承-掌握" class="headerlink" title="4:继承(掌握)"></a>4:继承(掌握)</h2><h3 id="1-把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该独立的类产生一个关系，"><a href="#1-把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该独立的类产生一个关系，" class="headerlink" title="(1)把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该独立的类产生一个关系，"></a>(1)把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该独立的类产生一个关系，</h3><pre><code>   这多个类就具备了这些内容。这个关系叫继承。</code></pre><h3 id="2-Java中如何表示继承呢-格式是什么呢"><a href="#2-Java中如何表示继承呢-格式是什么呢" class="headerlink" title="(2)Java中如何表示继承呢?格式是什么呢?"></a>(2)Java中如何表示继承呢?格式是什么呢?</h3><pre><code>    A:用关键字extends表示    B:格式：        class 子类名 extends 父类名 {}</code></pre><h3 id="3-继承的好处："><a href="#3-继承的好处：" class="headerlink" title="(3)继承的好处："></a>(3)继承的好处：</h3><pre><code>    A:提高了代码的复用性    B:提高了代码的维护性    C:让类与类产生了一个关系，是多态的前提</code></pre><h3 id="4-继承的弊端："><a href="#4-继承的弊端：" class="headerlink" title="(4)继承的弊端："></a>(4)继承的弊端：</h3><pre><code>    A:让类的耦合性增强。这样某个类的改变，就会影响其他和该类相关的类。        原则：低耦合，高内聚。        耦合：类与类的关系        内聚：自己完成某件事情的能力    B:打破了封装性</code></pre><h3 id="5-Java中继承的特点"><a href="#5-Java中继承的特点" class="headerlink" title="(5)Java中继承的特点"></a>(5)Java中继承的特点</h3><pre><code>    A:Java中类只支持单继承    B:Java中可以多层(重)继承(继承体系)</code></pre><h3 id="6-继承的注意事项："><a href="#6-继承的注意事项：" class="headerlink" title="(6)继承的注意事项："></a>(6)继承的注意事项：</h3><pre><code>    A:子类不能继承父类的私有成员    B:子类不能继承父类的构造方法，但是可以通过super去访问    C:不要为了部分功能而去继承</code></pre><h3 id="7-什么时候使用继承呢"><a href="#7-什么时候使用继承呢" class="headerlink" title="(7)什么时候使用继承呢?"></a>(7)什么时候使用继承呢?</h3><pre><code>    A:继承体现的是：is a的关系。    B:采用假设法</code></pre><h3 id="8-Java继承中的成员关系"><a href="#8-Java继承中的成员关系" class="headerlink" title="(8)Java继承中的成员关系"></a>(8)Java继承中的成员关系</h3><pre><code>    A:成员变量        a:子类的成员变量名称和父类中的成员变量名称不一样，这个太简单        b:子类的成员变量名称和父类中的成员变量名称一样，这个怎么访问呢?            子类的方法访问变量的查找顺序：                在子类方法的局部范围找，有就使用。                在子类的成员范围找，有就使用。                在父类的成员范围找，有就使用。                找不到，就报错。    B:构造方法        a:子类的构造方法默认会去访问父类的无参构造方法            是为了子类访问父类数据的初始化        b:父类中如果没有无参构造方法，怎么办?            子类通过super去明确调用带参构造            子类通过this调用本身的其他构造，但是一定会有一个去访问了父类的构造            让父类提供无参构造    C:成员方法        a:子类的成员方法和父类中的成员方法名称不一样，这个太简单        b:子类的成员方法和父类中的成员方法名称一样，这个怎么访问呢?            通过子类对象访问一个方法的查找顺序：                在子类中找，有就使用                在父类中找，有就使用                找不到，就报错</code></pre><h3 id="9-两个面试题："><a href="#9-两个面试题：" class="headerlink" title="(9)两个面试题："></a>(9)两个面试题：</h3><pre><code>    A:Override和Overload的区别?Overload是否可以改变返回值类型?    B:this和super的区别和各自的作用?</code></pre><h3 id="10-数据初始化的面试题"><a href="#10-数据初始化的面试题" class="headerlink" title="(10)数据初始化的面试题"></a>(10)数据初始化的面试题</h3><pre><code>    A:一个类的初始化过程    B:子父类的构造执行过程    C:分层初始化</code></pre><h3 id="11-案例："><a href="#11-案例：" class="headerlink" title="(11)案例："></a>(11)案例：</h3><pre><code>    A:学生和老师案例        继承前        继承后    B:猫狗案例的分析和实现</code></pre><p>1:代码块是什么?代码块的分类和各自特点?  </p><p>用{}括起来的代码。<br>分类：<br>A：局部代码块：用于限定变量的生命周期，及早释放，提高内存利用率<br>B：构造代码块：把多个构造方法中相同的代码可以放到这里，每个构造方法执行前，首先执行构造代码块。<br>C：静态大妈快：对类的数据进行初始化，仅仅只执行一次。<br>静态代码块&gt;构造代码块&gt;局部代码块</p><p>2:静态代码块,构造代码块,构造方法的执行流程?    </p><p>3:继承概述  </p><p>把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该独立的类产生一个关系，这多个类就具备了这些内容，这个关系叫继承。</p><p>4:继承的好处  </p><p>A：提高了代码的复用性<br>B：提高了代码的维护性<br>C：让类与类产生了一个关系，是多态的前提</p><p>5:Java中继承的特点  </p><p>A：Java中类只支持单继承<br>B：Java中可以多层继承</p><p>6:Java中继承的注意事项?以及我们什么时候使用继承?  </p><p>A：子类不能继承父类的私有成员<br>B：子类不能继承父类的构造方法，但是可以通过super去访问<br>C：不要为了部分功能而去继承</p><p>A：继承体现的是： is a的关系<br>B：采用假设法</p><p>7:继承中的成员访问特点  </p><pre><code>A:成员变量    在子类方法中访问一个变量B:成员方法    在测试类中通过子类对象去访问一个方法</code></pre><p>8:继承中构造方法的执行流程?假如父类没有无参构造方法，子类应该怎么办?  </p><p>A：子类的构造方法默认会去访问父类的无参构造方法，是为了子类访问父类数据的初始化<br>B：            子类通过super去明确调用带参构造<br>    子类通过this调用本身的其他构造，但是一定会有一个去访问了父类的构造<br>    让父类提供无参构造<br>9:面试题：  </p><pre><code>方法重写和方法重载的区别?方法重载能改变返回值类型吗?Overload （方法重载）同一个类中，出现的方法名相同，参数列表不同的现象Override    （方法重写）在子类中，出现和父类中一摸一样的方法声明的现象方法重载能改变返回值类型，因为它和返回值类型无关this关键字和super关键字分别代表什么?以及他们各自的使用场景和作用。    this：代表当前类的对象引用    super：代表父类存储空间的标识。（可以理解为父类的引用，通过这个东西可以访问父类的成员）</code></pre><p>10:继承案例练习  </p><p>11:猜数字小游戏练习。  </p><pre><code>通过API学习并使用Math类的random()方法。        </code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day07</title>
      <link href="/2020/060759548.html"/>
      <url>/2020/060759548.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-成员变量和局部变量的区别-理解"><a href="#1-成员变量和局部变量的区别-理解" class="headerlink" title="1:成员变量和局部变量的区别(理解)"></a>1:成员变量和局部变量的区别(理解)</h2><h3 id="1-在类中的位置不同"><a href="#1-在类中的位置不同" class="headerlink" title="(1)在类中的位置不同"></a>(1)在类中的位置不同</h3><pre><code>    成员变量：类中方法外    局部变量：方法定义中或者方法声明上</code></pre><h3 id="2-在内存中的位置不同"><a href="#2-在内存中的位置不同" class="headerlink" title="(2)在内存中的位置不同"></a>(2)在内存中的位置不同</h3><pre><code>    成员变量：在堆中    局部变量：在栈中</code></pre><h3 id="3-生命周期不同"><a href="#3-生命周期不同" class="headerlink" title="(3)生命周期不同"></a>(3)生命周期不同</h3><pre><code>    成员变量：随着对象的创建而存在，随着对象的消失而消失    局部变量：随着方法的调用而存在，随着方法的调用完毕而消失</code></pre><h3 id="4-初始化值不同"><a href="#4-初始化值不同" class="headerlink" title="(4)初始化值不同"></a>(4)初始化值不同</h3><pre><code>    成员变量：有默认值    局部变量：没有默认值，必须定义，赋值，然后才能使用</code></pre><h2 id="2-类作为形式参数的问题-理解"><a href="#2-类作为形式参数的问题-理解" class="headerlink" title="2:类作为形式参数的问题?(理解)"></a>2:类作为形式参数的问题?(理解)</h2><h3 id="1-如果你看到一个方法需要的参数是一个类名，就应该知道这里实际需要的是一个具体的对象。"><a href="#1-如果你看到一个方法需要的参数是一个类名，就应该知道这里实际需要的是一个具体的对象。" class="headerlink" title="(1)如果你看到一个方法需要的参数是一个类名，就应该知道这里实际需要的是一个具体的对象。"></a>(1)如果你看到一个方法需要的参数是一个类名，就应该知道这里实际需要的是一个具体的对象。</h3><h2 id="3-匿名对象-理解"><a href="#3-匿名对象-理解" class="headerlink" title="3:匿名对象(理解)"></a>3:匿名对象(理解)</h2><h3 id="1-没有名字的对象"><a href="#1-没有名字的对象" class="headerlink" title="(1)没有名字的对象"></a>(1)没有名字的对象</h3><h3 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="(2)应用场景"></a>(2)应用场景</h3><pre><code>    A:调用方法，仅仅只调用一次的时候。    b:可以作为实际参数传递。</code></pre><h2 id="4-封装-理解"><a href="#4-封装-理解" class="headerlink" title="4:封装(理解)"></a>4:封装(理解)</h2><h3 id="1-隐藏实现细节，提供公共的访问方式"><a href="#1-隐藏实现细节，提供公共的访问方式" class="headerlink" title="(1)隐藏实现细节，提供公共的访问方式"></a>(1)隐藏实现细节，提供公共的访问方式</h3><h3 id="2-好处："><a href="#2-好处：" class="headerlink" title="(2)好处："></a>(2)好处：</h3><pre><code>    A:隐藏实现细节，提供公共的访问方式    B:提高代码的复用性    C:提高代码的安全性</code></pre><h3 id="3-设计原则"><a href="#3-设计原则" class="headerlink" title="(3)设计原则"></a>(3)设计原则</h3><pre><code>    把不想让外界知道的实现细节给隐藏起来，提供公共的访问方式</code></pre><h3 id="4-private是封装的一种体现。"><a href="#4-private是封装的一种体现。" class="headerlink" title="(4)private是封装的一种体现。"></a>(4)private是封装的一种体现。</h3><pre><code>    封装：类，方法，private修饰成员变量</code></pre><h2 id="private关键字-掌握"><a href="#private关键字-掌握" class="headerlink" title=":private关键字(掌握)"></a>:private关键字(掌握)</h2><h3 id="1-私有的意义，可以修饰成员变量和成员方法"><a href="#1-私有的意义，可以修饰成员变量和成员方法" class="headerlink" title="(1)私有的意义，可以修饰成员变量和成员方法"></a>(1)私有的意义，可以修饰成员变量和成员方法</h3><h3 id="2-特点："><a href="#2-特点：" class="headerlink" title="(2)特点："></a>(2)特点：</h3><pre><code>    被private修饰的后的成员只能在本类中被访问</code></pre><h3 id="3-private的应用："><a href="#3-private的应用：" class="headerlink" title="(3)private的应用："></a>(3)private的应用：</h3><pre><code>    以后再写一个类的时候：        把所有的成员变量给private了        提供对应的getXxx()/setXxx()方法</code></pre><h2 id="6-this关键字-掌握"><a href="#6-this关键字-掌握" class="headerlink" title="6:this关键字(掌握)"></a>6:this关键字(掌握)</h2><h3 id="1-代表当前类的引用对象"><a href="#1-代表当前类的引用对象" class="headerlink" title="(1)代表当前类的引用对象"></a>(1)代表当前类的引用对象</h3><pre><code>    记住：哪个对象调用方法，该方法内部的this就代表那个对象</code></pre><h3 id="2-this的应用场景："><a href="#2-this的应用场景：" class="headerlink" title="(2)this的应用场景："></a>(2)this的应用场景：</h3><pre><code>    A:解决了局部变量隐藏成员变量的问题    B:其实this还有其他的应用，明天讲解。</code></pre><h2 id="7-构造方法-掌握"><a href="#7-构造方法-掌握" class="headerlink" title="7:构造方法(掌握)"></a>7:构造方法(掌握)</h2><h3 id="1-作用：用于对对象的数据进行初始化"><a href="#1-作用：用于对对象的数据进行初始化" class="headerlink" title="(1)作用：用于对对象的数据进行初始化"></a>(1)作用：用于对对象的数据进行初始化</h3><h3 id="2-格式："><a href="#2-格式：" class="headerlink" title="(2)格式："></a>(2)格式：</h3><pre><code>    A:方法名和类名相同    B:没有返回值类型，连void都不能有    C:没有返回值    思考题：构造方法中可不可以有return语句呢?    可以。而是我们写成这个样子就OK了：return;    其实，在任何的void类型的方法的最后你都可以写上：return;</code></pre><h3 id="3-构造方法的注意事项"><a href="#3-构造方法的注意事项" class="headerlink" title="(3)构造方法的注意事项"></a>(3)构造方法的注意事项</h3><pre><code>    A:如果我们没写构造方法，系统将提供一个默认的无参构造方法    B:如果我们给出了构造方法，系统将不再提供默认构造方法        如果这个时候，我们要使用无参构造方法，就必须自己给出。        推荐：永远手动自己给出无参构造方法。</code></pre><h3 id="4-给成员变量赋值的方式"><a href="#4-给成员变量赋值的方式" class="headerlink" title="(4)给成员变量赋值的方式"></a>(4)给成员变量赋值的方式</h3><pre><code>    A:setXxx()    B:带参构造方法</code></pre><h3 id="5-标准案例"><a href="#5-标准案例" class="headerlink" title="(5)标准案例"></a>(5)标准案例</h3><pre><code>    class Student {        private String name;        private int age;        public Student(){}        public Student(String name,int age) {            this.name = name;            this.age = age;        }        public String getName() {            return name;        }        public void setName(String name) {            this.name = name;        }        public int getAge() {            return age;        }        public void setAge(int age) {            this.age = age;        }    }    测试：    class StudentDemo {        public static void main(String[] args) {            //方式1            Student s1 = new Student();            s1.setName(&quot;林青霞&quot;);            s1.setAge(27);            System.out.println(s1.getName()+&quot;---&quot;+s1.getAge());            //方式2            Student s2 = new Student(&quot;刘意&quot;,30);            System.out.println(s2.getName()+&quot;---&quot;+s2.getAge());        }    }</code></pre><h2 id="8-代码：Student-s-new-Student-做了哪些事情-理解"><a href="#8-代码：Student-s-new-Student-做了哪些事情-理解" class="headerlink" title="8:代码：Student s = new Student();做了哪些事情?(理解)"></a>8:代码：Student s = new Student();做了哪些事情?(理解)</h2><h3 id="1-把Student-class文件加载到内存"><a href="#1-把Student-class文件加载到内存" class="headerlink" title="(1)把Student.class文件加载到内存"></a>(1)把Student.class文件加载到内存</h3><h3 id="2-在栈内存为s开辟空间"><a href="#2-在栈内存为s开辟空间" class="headerlink" title="(2)在栈内存为s开辟空间"></a>(2)在栈内存为s开辟空间</h3><h3 id="3-在堆内存为学生对象申请空间"><a href="#3-在堆内存为学生对象申请空间" class="headerlink" title="(3)在堆内存为学生对象申请空间"></a>(3)在堆内存为学生对象申请空间</h3><h3 id="4-给学生的成员变量进行默认初始化。null-0"><a href="#4-给学生的成员变量进行默认初始化。null-0" class="headerlink" title="(4)给学生的成员变量进行默认初始化。null,0"></a>(4)给学生的成员变量进行默认初始化。null,0</h3><h3 id="5-给学生的成员变量进行显示初始化。林青霞-27"><a href="#5-给学生的成员变量进行显示初始化。林青霞-27" class="headerlink" title="(5)给学生的成员变量进行显示初始化。林青霞,27"></a>(5)给学生的成员变量进行显示初始化。林青霞,27</h3><h3 id="6-通过构造方法给成员变量进行初始化。刘意-30"><a href="#6-通过构造方法给成员变量进行初始化。刘意-30" class="headerlink" title="(6)通过构造方法给成员变量进行初始化。刘意,30"></a>(6)通过构造方法给成员变量进行初始化。刘意,30</h3><h3 id="7-对象构造完毕，把地址赋值给s变量"><a href="#7-对象构造完毕，把地址赋值给s变量" class="headerlink" title="(7)对象构造完毕，把地址赋值给s变量"></a>(7)对象构造完毕，把地址赋值给s变量</h3><p>9:面向对象的练习题(掌握)  </p><h3 id="1-标准的手机类的定义和测试"><a href="#1-标准的手机类的定义和测试" class="headerlink" title="(1)标准的手机类的定义和测试"></a>(1)标准的手机类的定义和测试</h3><h3 id="2-Demo类有求和方法，Test类进行测试。"><a href="#2-Demo类有求和方法，Test类进行测试。" class="headerlink" title="(2)Demo类有求和方法，Test类进行测试。"></a>(2)Demo类有求和方法，Test类进行测试。</h3><pre><code>    什么时候定义成员变量?    当该变量是用来描述一个类的时候。</code></pre><h3 id="3-长方形案例"><a href="#3-长方形案例" class="headerlink" title="(3)长方形案例"></a>(3)长方形案例</h3><h3 id="4-员工案例"><a href="#4-员工案例" class="headerlink" title="(4)员工案例"></a>(4)员工案例</h3><h3 id="5-MyMath案例-自己提供加减乘除并测试"><a href="#5-MyMath案例-自己提供加减乘除并测试" class="headerlink" title="(5)MyMath案例(自己提供加减乘除并测试)"></a>(5)MyMath案例(自己提供加减乘除并测试)</h3><h2 id="10-static关键字-理解"><a href="#10-static关键字-理解" class="headerlink" title="10:static关键字(理解)"></a>10:static关键字(理解)</h2><h3 id="1-静态的意思。可以修饰成员变量和成员方法。"><a href="#1-静态的意思。可以修饰成员变量和成员方法。" class="headerlink" title="(1)静态的意思。可以修饰成员变量和成员方法。"></a>(1)静态的意思。可以修饰成员变量和成员方法。</h3><h3 id="2-静态的特点："><a href="#2-静态的特点：" class="headerlink" title="(2)静态的特点："></a>(2)静态的特点：</h3><pre><code>    A:随着类的加载而加载    B:优先与对象存在    C:被类的所有对象共享        这其实也是我们判断该不该使用静态的依据。        举例：饮水机和水杯的问题思考    D:可以通过类名调用        既可以通过对象名调用，也可以通过类名调用，建议通过类名调用。</code></pre><h3 id="3-静态的内存图"><a href="#3-静态的内存图" class="headerlink" title="(3)静态的内存图"></a>(3)静态的内存图</h3><pre><code>    静态的内容在方法区的静态区</code></pre><h3 id="4-静态的注意事项；"><a href="#4-静态的注意事项；" class="headerlink" title="(4)静态的注意事项；"></a>(4)静态的注意事项；</h3><pre><code>    A:在静态方法中没有this对象    B:静态只能访问静态(代码测试过)</code></pre><h3 id="5-静态变量和成员变量的区别"><a href="#5-静态变量和成员变量的区别" class="headerlink" title="(5)静态变量和成员变量的区别"></a>(5)静态变量和成员变量的区别</h3><pre><code>    A:所属不同        静态变量：属于类，类变量        成员变量：属于对象，对象变量，实例变量    B:内存位置不同        静态变量：方法区的静态区        成员变量：堆内存    C:生命周期不同        静态变量：静态变量是随着类的加载而加载，随着类的消失而消失        成员变量：成员变量是随着对象的创建而存在，随着对象的消失而消失    D:调用不同        静态变量：可以通过对象名调用，也可以通过类名调用        成员变量：只能通过对象名调用</code></pre><h3 id="6-main方法是静态的"><a href="#6-main方法是静态的" class="headerlink" title="(6)main方法是静态的"></a>(6)main方法是静态的</h3><pre><code>    public:权限最大    static:不用创建对象调用    void:返回值给jvm没有意义    main:就是一个常见的名称。    String[] args:可以接收数据，提供程序的灵活性        格式：java MainDemo hello world java              java MainDemo 10 20 30</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day06</title>
      <link href="/2020/060610333.html"/>
      <url>/2020/060610333.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-二维数组-理解"><a href="#1-二维数组-理解" class="headerlink" title="1:二维数组(理解)"></a>1:二维数组(理解)</h2><h3 id="1-元素是一维数组的数组。"><a href="#1-元素是一维数组的数组。" class="headerlink" title="(1)元素是一维数组的数组。"></a>(1)元素是一维数组的数组。</h3><h3 id="2-格式："><a href="#2-格式：" class="headerlink" title="(2)格式："></a>(2)格式：</h3><pre><code>    A:数据类型[][] 数组名 = new 数据类型[m][n];    B:数据类型[][] 数组名 = new 数据类型[m][];    C:数据类型[][] 数组名 = new 数据类型[][]{{...},{...},{...}};    D:数据类型[][] 数组名 = {{...},{...},{...}};</code></pre><h3 id="3-案例-掌握"><a href="#3-案例-掌握" class="headerlink" title="(3)案例(掌握):"></a>(3)案例(掌握):</h3><pre><code>    A:二维数组的遍历    B:二维数组的求和    C:杨辉三角形</code></pre><h2 id="2-两个思考题-理解"><a href="#2-两个思考题-理解" class="headerlink" title="2:两个思考题(理解)"></a>2:两个思考题(理解)</h2><h3 id="1-Java中的参数传递问题"><a href="#1-Java中的参数传递问题" class="headerlink" title="(1)Java中的参数传递问题"></a>(1)Java中的参数传递问题</h3><pre><code>    Java中只有值传递。    基本类型：形式参数的改变不影响实际参数    引用类型：形式参数的改变直接影响实际参数</code></pre><h3 id="2-数据加密问题"><a href="#2-数据加密问题" class="headerlink" title="(2)数据加密问题"></a>(2)数据加密问题</h3><pre><code>    综合的小案例。</code></pre><h2 id="3-面向对象-掌握"><a href="#3-面向对象-掌握" class="headerlink" title="3:面向对象(掌握)"></a>3:面向对象(掌握)</h2><h3 id="1-面向对象"><a href="#1-面向对象" class="headerlink" title="(1)面向对象"></a>(1)面向对象</h3><pre><code>    面向对象是基于面向过程的编程思想</code></pre><h3 id="2-面向对象的思想特点"><a href="#2-面向对象的思想特点" class="headerlink" title="(2)面向对象的思想特点"></a>(2)面向对象的思想特点</h3><pre><code>    A:是一种更符合我们思考习惯的思想    B:把复杂的事情简单化    C:让我们从执行者变成了指挥者    举例：        买电脑        洗衣服        做饭        ...        万事万物皆对象</code></pre><h3 id="3-把大象装进冰箱-理解"><a href="#3-把大象装进冰箱-理解" class="headerlink" title="(3)把大象装进冰箱(理解)"></a>(3)把大象装进冰箱(理解)</h3><pre><code>    A:面向过程实现    B:面向对象实现    注意：如何让我们的操作更符合面向对象思想呢?    A:有哪些类    B:每个类有哪些成员    C:类与类的关系</code></pre><h3 id="4-类与对象"><a href="#4-类与对象" class="headerlink" title="(4)类与对象"></a>(4)类与对象</h3><pre><code>    A:现实世界的事物        属性    事物的基本描述        行为    事物的功能    B:Java语言中最基本的单位是类。所以，我们要用类来体现事物    C:类        成员变量    事物属性        成员方法    事物行为    D:类：是一组相关的属性和行为的集合。是一个抽象的概念。      对象：是该类事物的具体存在，是一个具体的实例。(对象)      举例：        学生：类        班长：对象</code></pre><h3 id="5-类的定义及使用"><a href="#5-类的定义及使用" class="headerlink" title="(5)类的定义及使用"></a>(5)类的定义及使用</h3><pre><code>    A:类的定义        成员变量    定义格式和以前一样，就是位置不同，在类中，方法外。        成员方法    定义格式和以前一样，就是去掉了static。    B:使用类的内容        a:创建对象? 格式            类名 对象名 =  new 类名();        b:如何使用成员变量和成员方法呢            对象名.成员变量            对象名.成员方法()</code></pre><h3 id="6-案例："><a href="#6-案例：" class="headerlink" title="(6)案例："></a>(6)案例：</h3><pre><code>    A:学生类的定义和使用    B:手机类的定义和使用</code></pre><h3 id="7-内存图"><a href="#7-内存图" class="headerlink" title="(7)内存图"></a>(7)内存图</h3><pre><code>    A:一个对象的内存图    B:二个对象的内存图    C:三个对象的内存图</code></pre><h3 id="8-Java程序的开发，设计和特征"><a href="#8-Java程序的开发，设计和特征" class="headerlink" title="(8)Java程序的开发，设计和特征"></a>(8)Java程序的开发，设计和特征</h3><pre><code>    A:开发：就是不断的创建对象，通过对象调用功能    B:设计：就是管理和维护对象间的关系    C:特征        a:封装        b:继承        c:多态</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day05</title>
      <link href="/2020/060410525.html"/>
      <url>/2020/060410525.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-方法-掌握"><a href="#1-方法-掌握" class="headerlink" title="1:方法(掌握)"></a>1:方法(掌握)</h2><h3 id="1-方法：就是完成特定功能的代码块。"><a href="#1-方法：就是完成特定功能的代码块。" class="headerlink" title="(1)方法：就是完成特定功能的代码块。"></a>(1)方法：就是完成特定功能的代码块。</h3><pre><code>    注意：在很多语言里面有函数的定义，而在Java中，函数被称为方法。</code></pre><h3 id="2-格式："><a href="#2-格式：" class="headerlink" title="(2)格式："></a>(2)格式：</h3><pre><code>    修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) {        方法体语句;        return 返回值;    }    修饰符：目前就用 public static。后面再详细讲解其他修饰符    返回值类型：就是功能结果的数据类型    方法名：就是起了一个名字，方便我们调用该方法。    参数类型：就是参数的数据类型    参数名：就是变量    参数分类：        实参：实际参与运算的数据        形参：方法上定义的，用于接收实际参数的变量    方法体语句：就是完成功能的代码块    return：结束方法    返回值：就是功能的结果，由return带给调用者。</code></pre><h3 id="3-两个明确："><a href="#3-两个明确：" class="headerlink" title="(3)两个明确："></a>(3)两个明确：</h3><pre><code>    返回值类型：结果的数据类型    参数列表：参数的个数及对应的数据类型</code></pre><h3 id="4-方法调用"><a href="#4-方法调用" class="headerlink" title="(4)方法调用"></a>(4)方法调用</h3><pre><code>    A:有明确返回值的方法        a:单独调用，没有意义        b:输出调用，不是很好，因为我可能需要不结果进行进一步的操作。但是讲课一般我就用了。        c:赋值调用，推荐方案    B:void类型修饰的方法        a:单独调用</code></pre><h3 id="5-案例："><a href="#5-案例：" class="headerlink" title="(5)案例："></a>(5)案例：</h3><pre><code>    A:求和方案    B:获取两个数中的较大值    C:比较两个数据是否相同    D:获取三个数中的最大值    E:输出m行n列的星形    F:输出nn乘法表</code></pre><h3 id="6-方法的注意事项"><a href="#6-方法的注意事项" class="headerlink" title="(6)方法的注意事项"></a>(6)方法的注意事项</h3><pre><code>    A:方法不调用不执行    B:方法之间是平级关系，不能嵌套定义    C:方法定义的时候，参数是用，隔开的    D:方法在调用的时候，不用在传递数据类型    E:如果方法有明确的返回值类型，就必须有return语句返回。</code></pre><h3 id="7-方法重载"><a href="#7-方法重载" class="headerlink" title="(7)方法重载"></a>(7)方法重载</h3><pre><code>    在同一个类中，方法名相同，参数列表不同。与返回值无关。    参数列表不同：        参数的个数不同。        参数的对应的数据类型不同。</code></pre><h3 id="8-方法重载案例"><a href="#8-方法重载案例" class="headerlink" title="(8)方法重载案例"></a>(8)方法重载案例</h3><pre><code>    不同的类型的多个同名方法的比较。</code></pre><h2 id="2-数组-掌握"><a href="#2-数组-掌握" class="headerlink" title="2:数组(掌握)"></a>2:数组(掌握)</h2><h3 id="1-数组："><a href="#1-数组：" class="headerlink" title="(1)数组："></a>(1)数组：</h3><pre><code>存储同一种数据类型的多个元素的容器。</code></pre><h3 id="2-特点："><a href="#2-特点：" class="headerlink" title="(2)特点："></a>(2)特点：</h3><pre><code>每一个元素都有编号，从0开始，最大编号是长度-1。         编号的专业叫法：索引</code></pre><h3 id="3-定义格式"><a href="#3-定义格式" class="headerlink" title="(3)定义格式"></a>(3)定义格式</h3><pre><code>    A:数据类型[] 数组名;    B:数据类型 数组名[];    推荐是用A方式，B方法就忘了吧。    但是要能看懂</code></pre><h3 id="4-数组的初始化"><a href="#4-数组的初始化" class="headerlink" title="(4)数组的初始化"></a>(4)数组的初始化</h3><pre><code>    A:动态初始化        只给长度，系统给出默认值        举例：int[] arr = new int[3];    B:静态初始化        给出值，系统决定长度        举例：int[] arr = new int[]{1,2,3};        简化版：int[] arr = {1,2,3};</code></pre><h3 id="5-Java的内存分配"><a href="#5-Java的内存分配" class="headerlink" title="(5)Java的内存分配"></a>(5)Java的内存分配</h3><pre><code>    A:栈 存储局部变量    B:堆 存储所有new出来的    C:方法区(面向对象部分详细讲解)    D:本地方法区(系统相关)    E:寄存器(CPU使用)    注意：        a:局部变量 在方法定义中或者方法声明上定义的变量。        b:栈内存和堆内存的区别            栈：数据使用完毕，就消失。            堆：每一个new出来的东西都有地址                每一个变量都有默认值                    byte,short,int,long 0                    float,double 0.0                    char &#39;\u0000&#39;                    boolean false                    引用类型 null                数据使用完毕后，在垃圾回收器空闲的时候回收。</code></pre><h3 id="6-数组内存图"><a href="#6-数组内存图" class="headerlink" title="(6)数组内存图"></a>(6)数组内存图</h3><pre><code>    A:一个数组    B:二个数组    C:三个数组(两个栈变量指向同一个堆内存)</code></pre><h3 id="7-数组的常见操作"><a href="#7-数组的常见操作" class="headerlink" title="(7)数组的常见操作"></a>(7)数组的常见操作</h3><pre><code>    A:遍历        方式1：            public static void printArray(int[] arr) {                for(int x=0; x&lt;arr.length; x++) {                    System.out.println(arr[x]);                }            }        方式2：            public static void printArray(int[] arr) {                System.out.print(&quot;[&quot;);                for(int x=0; x&lt;arr.length; x++) {                    if(x == arr.length-1) {                        System.out.println(arr[x]+&quot;]&quot;);                    }else {                        System.out.println(arr[x]+&quot;, &quot;);                    }                }            }    B:最值        最大值：            public static int getMax(int[] arr) {                int max = arr[0];                for(int x=1; x&lt;arr.length; x++) {                    if(arr[x] &gt; max) {                        max = arr[x];                    }                }                return max;            }        最小值：            public static int getMin(int[] arr) {                int min = arr[0];                for(int x=1; x&lt;arr.length; x++) {                    if(arr[x] &lt; min) {                        min = arr[x];                    }                }                return min;            }    C:逆序        方式1：            public static void reverse(int[] arr) {                for(int x=0; x&lt;arr.length/2; x++) {                    int temp = arr[x];                    arr[x] = arr[arr.length-1-x];                    arr[arr.length-1-x] = temp;                }            }        方式2：            public static void reverse(int[] arr) {                for(int start=0,end=arr.length-1; start&lt;=end; start++,end--) {                    int temp = arr[start];                    arr[start] = arr[end];                    arr[end] = temp;                }            }    D:查表            public static String getString(String[] strArray,int index) {                return strArray[index];            }    E:基本查找        方式1：            public static int getIndex(int[] arr,int value) {                for(int x=0; x&lt;arr.length; x++) {                    if(arr[x] == value) {                        return x;                    }                }                return -1;            }        方式2：            public static int getIndex(int[] arr,int value) {                int index = -1;                for(int x=0; x&lt;arr.length; x++) {                    if(arr[x] == value) {                        index = x;                        break;                    }                }                return index;            }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day04</title>
      <link href="/2020/060359868.html"/>
      <url>/2020/060359868.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-switch语句-掌握"><a href="#1-switch语句-掌握" class="headerlink" title="1:switch语句(掌握)"></a>1:switch语句(掌握)</h2><h3 id="1-格式："><a href="#1-格式：" class="headerlink" title="(1)格式："></a>(1)格式：</h3><pre><code>    switch(表达式) {        case 值1:            语句体1;            break;        case 值2:            语句体2;            break;        ...        default:            语句体n+1;            break;    }    格式解释说明：        switch:说明这是switch语句。        表达式:可以是byte,short,int,char            JDK5以后可以是枚举            JDK7以后可以是字符串        case:后面的值就是要和表达式进行比较的值        break:表示程序到这里中断，跳出switch语句        default:如果所有的情况都不匹配,就执行这里,相当于if语句中的else</code></pre><h3 id="2-面试题"><a href="#2-面试题" class="headerlink" title="(2)面试题"></a>(2)面试题</h3><pre><code>    switch语句的表达式可以是byte吗?可以是long吗?可以是String吗?        可以,不可以,JDK7以后可以</code></pre><h3 id="3-执行流程"><a href="#3-执行流程" class="headerlink" title="(3)执行流程:"></a>(3)执行流程:</h3><pre><code>    A:首先计算表达式的值    B:和每一个case进行匹配，如果有就执行对应的语句体，看到break就结束。    C:如果没有匹配，就执行default的语句体n+1。</code></pre><h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="(4)注意事项:"></a>(4)注意事项:</h3><pre><code>    A:case后面只能是常量，不能是变量，而且，多个case后面的值不能出现相同的    B:default可以省略吗?        可以省略，但是不建议，因为它的作用是对不正确的情况给出提示。        特殊情况：            case就可以把值固定。            A,B,C,D    C:break可以省略吗?        可以省略，但是结果可能不是我们想要的。        会出现一个现象：case穿透。        最终我们建议不要省略    D:default一定要在最后吗?        不是，可以在任意位置。但是建议在最后。    E:switch语句的结束条件        a:遇到break就结束了        b:执行到末尾就结束了</code></pre><h3 id="5-案例："><a href="#5-案例：" class="headerlink" title="(5)案例："></a>(5)案例：</h3><pre><code>    A:键盘录入一个数字(1-7),输出对应的星期几。    B:单项选择题    C:键盘录入一个字符串的问题        String s = sc.nextLine();    D:根据给定的月份,输出对应的季节</code></pre><h3 id="6-if语句和switch语句各自的场景"><a href="#6-if语句和switch语句各自的场景" class="headerlink" title="(6)if语句和switch语句各自的场景"></a>(6)if语句和switch语句各自的场景</h3><pre><code>    A:if        针对boolean类型的判断        针对一个范围的判断        针对几个常量的判断    B:switch        针对几个常量的判断</code></pre><h2 id="2-循环语句-掌握"><a href="#2-循环语句-掌握" class="headerlink" title="2:循环语句(掌握)"></a>2:循环语句(掌握)</h2><h3 id="1-有三种-for-while-do…while"><a href="#1-有三种-for-while-do…while" class="headerlink" title="(1)有三种:for,while,do…while"></a>(1)有三种:for,while,do…while</h3><h3 id="2-for循环语句"><a href="#2-for循环语句" class="headerlink" title="(2)for循环语句"></a>(2)for循环语句</h3><pre><code>    A:格式        for(初始化语句;判断条件语句;控制条件语句){            循环体语句;        }        执行流程：            a:执行初始化语句            b:执行判断条件语句                如果这里是true，就继续                如果这里是false，循环就结束            c:执行循环体语句            d:执行控制条件语句            e:回到b    B:注意事项        a:判断条件语句无论简单还是复杂，结果是boolean类型        b:循环体语句如果是一条，可以省略大括号，但是不建议        c:有分号就没有左大括号，有左大括号就没有分号    C:案例        a:输出10次HelloWorld        b:输出1-10的数据        c:输出10-1的数据        d:求1-10的和        e:求1-100的和,求1-100的偶数和,求1-100的奇数和        f:求5的阶乘        g:在控制台打印水仙花数        h:统计水仙花个数        i:改进版的回文数            一个五位数            个位 = 万位            十位 = 千位            个位 + 十位 + 千位 + 万位 = 百位        j:统计1-1000之间同时满足如下条件的数据有多少个            x%3==2            x%5==3            x%7==2</code></pre><h3 id="3-while循环"><a href="#3-while循环" class="headerlink" title="(3)while循环"></a>(3)while循环</h3><pre><code>    A:基本格式        while(判断条件语句) {            循环体语句;        }        扩展格式：        初始化语句;        while(判断条件语句){            循环体语句;            控制条件语句;        }        通过查看这个格式，我们就知道while循环可以和for循环等价转换。    B:while的练习        把for语句的练习用while改进    C:for和while的区别        a:使用上的区别            for语句的那个控制条件变量,在循环结束后不能在使用了。            而while的可以继续使用。        b:理解上的区别            for适合于一个范围的判断            while适合次数不明确的                举例:吃葡萄    D:案例：        a:珠穆朗玛峰问题        b:小芳存钱问题(break以后才能做)</code></pre><h3 id="4-do…while循环"><a href="#4-do…while循环" class="headerlink" title="(4)do…while循环"></a>(4)do…while循环</h3><pre><code>    A:基本格式        do {            循环体语句;        }while(判断条件语句);        扩展格式：        初始化语句;        do {            循环体语句;            控制条件语句;        }while(判断条件语句);        通过查看格式，我们就可以看出其实三种循环的格式可以是统一的。    B:三种循环的区别        a:do...while循环至少执行一次循环体        b:for和while必须先判断条件是否是true，然后后才能决定是否执行循环体</code></pre><h3 id="5-循环使用的注意事项-死循环"><a href="#5-循环使用的注意事项-死循环" class="headerlink" title="(5)循环使用的注意事项(死循环)"></a>(5)循环使用的注意事项(死循环)</h3><pre><code>    A:一定要注意修改控制条件,否则容易出现死循环。    B:最简单的死循环格式        a:while(true){...}        b:for(;;){}</code></pre><h2 id="3-控制跳转语句-掌握"><a href="#3-控制跳转语句-掌握" class="headerlink" title="3:控制跳转语句(掌握)"></a>3:控制跳转语句(掌握)</h2><h3 id="1-break-中断的意思"><a href="#1-break-中断的意思" class="headerlink" title="(1)break:中断的意思"></a>(1)break:中断的意思</h3><pre><code>    A:用在循环和switch语句中，离开此应用场景无意义。    B:作用        a:跳出单层循环        b:跳出多层循环，需要标签语句的配合</code></pre><h3 id="2-continue-继续"><a href="#2-continue-继续" class="headerlink" title="(2)continue:继续"></a>(2)continue:继续</h3><pre><code>    A:用在循环中，离开此应用场景无意义。    B:作用        a:跳出单层循环的一次，可以继续下一次    C:填空题        for(int x=1; x&lt;=10; x++) {            if(x%3 == 0) {                //补齐代码            }            System.out.println(&quot;Java基础班&quot;);        }        如何让控制台输出2次：Java基础班        如何让控制台输出7次：Java基础班        如何让控制台输出13次：Java基础班</code></pre><h3 id="3-return-返回"><a href="#3-return-返回" class="headerlink" title="(3)return:返回"></a>(3)return:返回</h3><pre><code>    A:用于结束方法的，后面还会在继续讲解和使用。    B:一旦遇到return,程序就不会在继续往后执行。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day03</title>
      <link href="/2020/060211165.html"/>
      <url>/2020/060211165.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-运算符-掌握"><a href="#1-运算符-掌握" class="headerlink" title="1:运算符(掌握)"></a>1:运算符(掌握)</h2><h3 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="(1)算术运算符"></a>(1)算术运算符</h3><pre><code>    A:+,-,*,/,%,++,--    B:+的用法        a:加法        b:正号        c:字符串连接符    C:/和%的区别        数据做除法操作的时候，/取得是商，%取得是余数    D:++和--的用法        a:他们的作用是自增或者自减        b:使用            **单独使用                放在操作数据的前面和后面效果一样。                a++或者++a效果一样。            **参与操作使用                放在操作数的前面：先自增或者自减，再参与操作                    int a = 10;                    int b = ++a;                放在操作数的后面：先参与操作，再自增或者自减                    int a = 10;                    int b = a++;</code></pre><h3 id="2-赋值运算符"><a href="#2-赋值运算符" class="headerlink" title="(2)赋值运算符"></a>(2)赋值运算符</h3><pre><code>    A:=,+=,-=,*=,/=,%=等    B:=叫做赋值运算符，也是最基本的赋值运算符        int x = 10; 把10赋值给int类型的变量x。    C:扩展的赋值运算符的特点        隐含了自动强制转换。        面试题：            short s = 1;            s = s + 1;            short s = 1;            s += 1;            请问上面的代码哪个有问题?</code></pre><h3 id="3-比较运算符"><a href="#3-比较运算符" class="headerlink" title="(3)比较运算符"></a>(3)比较运算符</h3><pre><code>    A:==,!=,&gt;,&gt;=,&lt;,&lt;=    B:无论运算符两端简单还是复杂最终结果是boolean类型。    C:千万不要把==写成了=</code></pre><h3 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="(4)逻辑运算符"></a>(4)逻辑运算符</h3><pre><code>    A:&amp;,|,^,!,&amp;&amp;,||    B:逻辑运算符用于连接boolean类型的式子    C:结论        &amp;:有false则false        |:有true则true        ^:相同则false，不同则true。            情侣关系。        !:非true则false，非false则true        &amp;&amp;:结果和&amp;是一样的，只不过有短路效果。左边是false，右边不执行。        ||:结果和|是一样的，只不过有短路效果。左边是true，右边不执行。</code></pre><h3 id="5-位运算符-了解"><a href="#5-位运算符-了解" class="headerlink" title="(5)位运算符(了解)"></a>(5)位运算符(了解)</h3><pre><code>    A:^的特殊用法        一个数据针对另一个数据位异或两次，该数不变    B:面试题        a:请实现两个变量的交换            **采用第三方变量            **用位异或运算符                左边a,b,a                右边a^b        b:请用最有效率的方式计算出2乘以8的结果            2&lt;&lt;3</code></pre><h3 id="6-三元运算符"><a href="#6-三元运算符" class="headerlink" title="(6)三元运算符"></a>(6)三元运算符</h3><pre><code>    A:格式        比较表达式?表达式1:表达式2;    B:执行流程：        首先计算比较表达式的值，看是true还是false。        如果是true，表达式1就是结果。        如果是false，表达式2就是结果。    C:案例：        a:比较两个数据是否相等        b:获取两个数据中的最大值        c:获取三个数据中的最大值</code></pre><h2 id="2-键盘录入-掌握"><a href="#2-键盘录入-掌握" class="headerlink" title="2:键盘录入(掌握)"></a>2:键盘录入(掌握)</h2><h3 id="1-实际开发中，数据是变化的，为了提高程序的灵活性，我们加入键盘录入数据。"><a href="#1-实际开发中，数据是变化的，为了提高程序的灵活性，我们加入键盘录入数据。" class="headerlink" title="(1)实际开发中，数据是变化的，为了提高程序的灵活性，我们加入键盘录入数据。"></a>(1)实际开发中，数据是变化的，为了提高程序的灵活性，我们加入键盘录入数据。</h3><h3 id="2-如何实现呢-目前就记住"><a href="#2-如何实现呢-目前就记住" class="headerlink" title="(2)如何实现呢?目前就记住"></a>(2)如何实现呢?目前就记住</h3><pre><code>    A:导包        import java.util.Scanner;        位置：在class的上边    B:创建对象        Scanner sc = new Scanner(System.in);    C:获取数据        int x = sc.nextInt();</code></pre><h3 id="3-把三元运算符的案例加入键盘录入改进。"><a href="#3-把三元运算符的案例加入键盘录入改进。" class="headerlink" title="(3)把三元运算符的案例加入键盘录入改进。"></a>(3)把三元运算符的案例加入键盘录入改进。</h3><h2 id="3-流程控制语句"><a href="#3-流程控制语句" class="headerlink" title="3:流程控制语句"></a>3:流程控制语句</h2><h3 id="1-顺序结构-从上往下，依次执行"><a href="#1-顺序结构-从上往下，依次执行" class="headerlink" title="(1)顺序结构 从上往下，依次执行"></a>(1)顺序结构 从上往下，依次执行</h3><h3 id="2-选择结构-按照不同的选择，执行不同的代码"><a href="#2-选择结构-按照不同的选择，执行不同的代码" class="headerlink" title="(2)选择结构    按照不同的选择，执行不同的代码"></a>(2)选择结构    按照不同的选择，执行不同的代码</h3><h3 id="3-循环结构-做一些重复的代码"><a href="#3-循环结构-做一些重复的代码" class="headerlink" title="(3)循环结构 做一些重复的代码"></a>(3)循环结构 做一些重复的代码</h3><h2 id="4-if语句-掌握"><a href="#4-if语句-掌握" class="headerlink" title="4:if语句(掌握)"></a>4:if语句(掌握)</h2><h3 id="1-三种格式"><a href="#1-三种格式" class="headerlink" title="(1)三种格式"></a>(1)三种格式</h3><pre><code>    A:格式1        if(比较表达式) {            语句体;        }        执行流程：            判断比较表达式的值，看是true还是false            如果是true，就执行语句体            如果是false，就不执行语句体    B:格式2        if(比较表达式) {            语句体1;        }else {            语句体2;        }        执行流程：            判断比较表达式的值，看是true还是false            如果是true，就执行语句体1            如果是false，就执行语句体2    C:格式3        if(比较表达式1) {            语句体1;        }else if(比较表达式2){            语句体2;        }        ...        else {            语句体n+1;        }        执行流程：            判断比较表达式1的值，看是true还是false            如果是true，就执行语句体1            如果是false，就继续判断比较表达式2的值，看是true还是false            如果是true，就执行语句体2            如果是false，就继续判断比较表达式3的值，看是true还是false            ...            如果都不满足，就执行语句体n+1</code></pre><h3 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="(2)注意事项"></a>(2)注意事项</h3><pre><code>    A:比较表达式无论简单还是复杂，结果是boolean类型    B:if语句控制的语句体如果是一条语句，是可以省略大括号的；如果是多条，不能省略。        建议：永远不要省略。    C:一般来说，有左大括号，就没有分号，有分号，就没有左大括号。    D:else后面如果没有if，是不会出现比较表达式的。    E:三种if语句其实都是一个语句，只要有一个执行，其他的就不再执行。</code></pre><h3 id="3-案例："><a href="#3-案例：" class="headerlink" title="(3)案例："></a>(3)案例：</h3><pre><code>    A:比较两个数是否相等    B:获取两个数中的最大值    C:获取三个数中的最大值(if语句的嵌套)    D:根据成绩输出对应的等级    E:根据月份，输出对应的季节    F:根据x计算对应y的值并输出</code></pre><h3 id="4-三元运算符和if语句第二种格式的关系"><a href="#4-三元运算符和if语句第二种格式的关系" class="headerlink" title="(4)三元运算符和if语句第二种格式的关系"></a>(4)三元运算符和if语句第二种格式的关系</h3><pre><code>    所有的三元运算符能够实现的，if语句的第二种格式都能实现。    反之不成立。    如果if语句第二种格式控制的语句体是输出语句，就不可以。    因为三元运算符是一个运算符，必须要有一个结果返回，不能是一个输出语句。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day02</title>
      <link href="/2020/060160252.html"/>
      <url>/2020/060160252.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-关键字-掌握"><a href="#1-关键字-掌握" class="headerlink" title="1:关键字(掌握)"></a>1:关键字(掌握)</h2><h3 id="1-被Java语言赋予特定含义的单词"><a href="#1-被Java语言赋予特定含义的单词" class="headerlink" title="(1)被Java语言赋予特定含义的单词"></a>(1)被Java语言赋予特定含义的单词</h3><h3 id="2-特点："><a href="#2-特点：" class="headerlink" title="(2)特点："></a>(2)特点：</h3><pre><code>    全部小写。</code></pre><h3 id="3-注意事项："><a href="#3-注意事项：" class="headerlink" title="(3)注意事项："></a>(3)注意事项：</h3><pre><code>    A:goto和const作为保留字存在。    B:类似于Notepad++这样的高级记事本会对关键字有特殊颜色标记</code></pre><h2 id="2-标识符-掌握"><a href="#2-标识符-掌握" class="headerlink" title="2:标识符(掌握)"></a>2:标识符(掌握)</h2><h3 id="1-就是给类，接口，方法，变量等起名字的字符序列"><a href="#1-就是给类，接口，方法，变量等起名字的字符序列" class="headerlink" title="(1)就是给类，接口，方法，变量等起名字的字符序列"></a>(1)就是给类，接口，方法，变量等起名字的字符序列</h3><h3 id="2-组成规则："><a href="#2-组成规则：" class="headerlink" title="(2)组成规则："></a>(2)组成规则：</h3><pre><code>    A:英文大小写字母    B:数字    C:$和_</code></pre><h3 id="3-注意事项：-1"><a href="#3-注意事项：-1" class="headerlink" title="(3)注意事项："></a>(3)注意事项：</h3><pre><code>    A:不能以数字开头    B:不能是java中的关键字    C:区分大小写</code></pre><h3 id="4-常见的命名规则-见名知意"><a href="#4-常见的命名规则-见名知意" class="headerlink" title="(4)常见的命名规则(见名知意)"></a>(4)常见的命名规则(见名知意)</h3><pre><code>    A:包    全部小写        单级包：小写            举例：liuyi,com        多级包：小写，并用.隔开            举例：cn.itcast,com.baidu                    B:类或者接口        一个单词：首字母大写            举例：Student,Demo        多个单词：每个单词首字母大写            举例：HelloWorld,StudentName    C:方法或者变量        一个单词：首字母小写            举例：name,main        多个单词：从第二个单词开始，每个单词首字母大写            举例：studentAge,showAllNames()    D:常量        全部大写        一个单词：大写            举例：PI        多个单词：大写，并用_隔开            举例：STUDENT_MAX_AGE</code></pre><h2 id="3-注释-掌握"><a href="#3-注释-掌握" class="headerlink" title="3:注释(掌握)"></a>3:注释(掌握)</h2><h3 id="1-就是对程序进行解释说明的文字"><a href="#1-就是对程序进行解释说明的文字" class="headerlink" title="(1)就是对程序进行解释说明的文字"></a>(1)就是对程序进行解释说明的文字</h3><h3 id="2-分类："><a href="#2-分类：" class="headerlink" title="(2)分类："></a>(2)分类：</h3><pre><code>    A:单行注释    //    B:多行注释    /**/    C:文档注释(后面讲) /** */</code></pre><h3 id="3-把HelloWorld案例写了一个带注释的版本。"><a href="#3-把HelloWorld案例写了一个带注释的版本。" class="headerlink" title="(3)把HelloWorld案例写了一个带注释的版本。"></a>(3)把HelloWorld案例写了一个带注释的版本。</h3><pre><code>    后面我们要写一个程序的过程。    需求：    分析：    实现：    代码体现：</code></pre><h3 id="4-注释的作用"><a href="#4-注释的作用" class="headerlink" title="(4)注释的作用"></a>(4)注释的作用</h3><pre><code>    A:解释说明程序，提高了代码的阅读性。    B:可以帮助我们调试程序。        后面我们会讲解一个更高端的一个调试工具</code></pre><h2 id="4-常量-掌握"><a href="#4-常量-掌握" class="headerlink" title="4:常量(掌握)"></a>4:常量(掌握)</h2><h3 id="1-在程序执行的过程中，其值不发生改变的量"><a href="#1-在程序执行的过程中，其值不发生改变的量" class="headerlink" title="(1)在程序执行的过程中，其值不发生改变的量"></a>(1)在程序执行的过程中，其值不发生改变的量</h3><h3 id="2-分类：-1"><a href="#2-分类：-1" class="headerlink" title="(2)分类："></a>(2)分类：</h3><pre><code>    A:字面值常量    B:自定义常量(后面讲)</code></pre><h3 id="3-字面值常量"><a href="#3-字面值常量" class="headerlink" title="(3)字面值常量"></a>(3)字面值常量</h3><pre><code>    A:字符串常量 &quot;hello&quot;    B:整数常量    12,23    C:小数常量    12.345    D:字符常量    &#39;a&#39;,&#39;A&#39;,&#39;0&#39;    E:布尔常量    true,false    F:空常量    null(后面讲)</code></pre><h3 id="4-在Java中针对整数常量提供了四种表现形式"><a href="#4-在Java中针对整数常量提供了四种表现形式" class="headerlink" title="(4)在Java中针对整数常量提供了四种表现形式"></a>(4)在Java中针对整数常量提供了四种表现形式</h3><pre><code>    A:二进制    由0，1组成。以0b开头。    B:八进制    由0，1，...7组成。以0开头。    C:十进制    由0，1，...9组成。整数默认是十进制。    D:十六进制    由0，1，...9,a,b,c,d,e,f(大小写均可)组成。以0x开头。</code></pre><h2 id="5-进制转换-了解"><a href="#5-进制转换-了解" class="headerlink" title="5:进制转换(了解)"></a>5:进制转换(了解)</h2><h3 id="1-其他进制到十进制"><a href="#1-其他进制到十进制" class="headerlink" title="(1)其他进制到十进制"></a>(1)其他进制到十进制</h3><pre><code>    系数：就是每一个位上的数值    基数：x进制的基数就是x    权：对每一个位上的数据，从右，并且从0开始编号，对应的编号就是该数据的权。    结果：系数*基数^权次幂之和。</code></pre><h3 id="2-十进制到其他进制"><a href="#2-十进制到其他进制" class="headerlink" title="(2)十进制到其他进制"></a>(2)十进制到其他进制</h3><pre><code>    除基取余，直到商为0，余数反转。</code></pre><h3 id="3-进制转换的快速转换法"><a href="#3-进制转换的快速转换法" class="headerlink" title="(3)进制转换的快速转换法"></a>(3)进制转换的快速转换法</h3><pre><code>    A:十进制和二进制间的转换        8421码。    B:二进制到八进制，十六进制的转换</code></pre><h2 id="6-变量-掌握"><a href="#6-变量-掌握" class="headerlink" title="6:变量(掌握)"></a>6:变量(掌握)</h2><h3 id="1-在程序的执行过程中，其值在某个范围内可以发生改变的量"><a href="#1-在程序的执行过程中，其值在某个范围内可以发生改变的量" class="headerlink" title="(1)在程序的执行过程中，其值在某个范围内可以发生改变的量"></a>(1)在程序的执行过程中，其值在某个范围内可以发生改变的量</h3><h3 id="2-变量的定义格式："><a href="#2-变量的定义格式：" class="headerlink" title="(2)变量的定义格式："></a>(2)变量的定义格式：</h3><pre><code>    A:数据类型 变量名 = 初始化值;    B:数据类型 变量名;      变量名 = 初始化值;</code></pre><h2 id="7-数据类型-掌握"><a href="#7-数据类型-掌握" class="headerlink" title="7:数据类型(掌握)"></a>7:数据类型(掌握)</h2><h3 id="1-Java是一种强类型语言，针对每种数据都提供了对应的数据类型。"><a href="#1-Java是一种强类型语言，针对每种数据都提供了对应的数据类型。" class="headerlink" title="(1)Java是一种强类型语言，针对每种数据都提供了对应的数据类型。"></a>(1)Java是一种强类型语言，针对每种数据都提供了对应的数据类型。</h3><h3 id="2-分类：-2"><a href="#2-分类：-2" class="headerlink" title="(2)分类："></a>(2)分类：</h3><pre><code>    A:基本数据类型：4类8种    B:引用数据类型：类，接口，数组。</code></pre><h3 id="3-基本数据类型"><a href="#3-基本数据类型" class="headerlink" title="(3)基本数据类型"></a>(3)基本数据类型</h3><pre><code>    A:整数            占用字节数        byte            1        short            2        int             4        long            8    B:浮点数        float            4        double            8    C:字符        char            2    D:布尔        boolean            1    注意：        整数默认是int类型，浮点数默认是double。        长整数要加L或者l。        单精度的浮点数要加F或者f。</code></pre><h2 id="8-数据类型转换-掌握"><a href="#8-数据类型转换-掌握" class="headerlink" title="8:数据类型转换(掌握)"></a>8:数据类型转换(掌握)</h2><h3 id="1-boolean类型不参与转换"><a href="#1-boolean类型不参与转换" class="headerlink" title="(1)boolean类型不参与转换"></a>(1)boolean类型不参与转换</h3><h3 id="2-默认转换"><a href="#2-默认转换" class="headerlink" title="(2)默认转换"></a>(2)默认转换</h3><pre><code>    A:从小到大    B:byte,short,char -- int -- long -- float -- double    C:byte,short,char之间不相互转换，直接转成int类型参与运算。</code></pre><h3 id="3-强制转换"><a href="#3-强制转换" class="headerlink" title="(3)强制转换"></a>(3)强制转换</h3><pre><code>    A:从大到小    B:可能会有精度的损失，一般不建议这样使用。    C:格式：        目标数据类型 变量名 = (目标数据类型) (被转换的数据);</code></pre><h3 id="4-思考题和面试题："><a href="#4-思考题和面试题：" class="headerlink" title="(4)思考题和面试题："></a>(4)思考题和面试题：</h3><pre><code>    A:下面两种方式有区别吗?        float f1 = 12.345f;        float f2 = (float)12.345;    B:下面的程序有问题吗，如果有，在哪里呢?        byte b1 = 3;        byte b2 = 4;        byte b3 = b1 + b2;        byte b4 = 3 + 4;    C:下面的操作结果是什么呢?        byte b = (byte)130;    D:字符参与运算        是查找ASCII里面的值        &#39;a&#39;        97        &#39;A&#39;        65        &#39;0&#39;        48        System.out.println(&#39;a&#39;);        System.out.println(&#39;a&#39; + 1);    E:字符串参与运算        这里其实是字符串的连接        System.out.println(&quot;hello&quot;+&#39;a&#39;+1);        System.out.println(&#39;a&#39;+1+&quot;hello&quot;);        System.out.println(&quot;5+5=&quot;+5+5);        System.out.println(5+5+&quot;=5+5&quot;);  </code></pre><hr><p>1：什么是注释?注释分为几种?注释有什么作用?  </p><pre><code>就是对程序进行解释说明；分为三种，单行注释，多行注释，文档注释；解释说明，提高代码的阅读性，帮助我们调试程序。</code></pre><p>2：什么是关键字?有什么特点?  </p><pre><code>被Java语言赋予特定含义的单词；全部小写；goto和const作为保留字存在。</code></pre><p>3：什么是标识符?由哪些部分组成?常见的命名规则有哪些?  </p><pre><code>就是给类，接口，方法，变量名等其名字的字符序列；A:英文字母大小写B:数字C：$和_。</code></pre><p>4：什么是常量?常量的分类?字面值常量表现形式有哪些?    </p><pre><code>在程序执行过程中，其值不发生改变的量；A字符串B整数C小数D字符E布尔F空常量null。</code></pre><p>5：计算出十进制46对应的二进制，八进制，十六进制的值。  </p><p>至于进制的内容今天在练习一次，以后就可以不用练习了。<br>后面能听懂就OK了。不用浪费太多时间。<br>(可用计算器验证你算的是否正确)</p><p>6：什么是变量?变量的定义格式?要使用变量需要注意什么?  </p><pre><code>在程序执行过程中，其值在某个范围内可以发生改变的量；A数据类型 变量名 = 初始值；B 数据类型 变量名；变量名 = 初始化值；</code></pre><p>7：Java中的数据类型分几类?基本数据类型有哪些?  </p><pre><code>A基本数据类型：4类8种 B引用数据类型：类，接口，数组。基本数据类型：    A整数     byte short int long   1 2 4 8    B浮点数 float double   4 8    C字符 char  2    D布尔 boolean 1</code></pre><p>8：数据类型转换：  </p><pre><code>隐式转换：A从小到大 Bbyte，short，char--int--long--float--double C:byte,short,char之间不相互转换，直接转成int类型参与运算。强制转换：A:从大到小          B:可能会有精度的损失，一般不建议这样使用。          C:格式：          目标数据类型 变量名 = (目标数据类型) (被转换的数据);</code></pre><p>面试题：  </p><pre><code>    第一题：    byte b1=3,b2=4,b;    b=b1+b2;    b=3+4;    哪句是编译失败的呢？为什么呢？    第二题：    byte  by = 130;有没有问题?有问题如何解决?结果是多少呢?</code></pre><p>9：练习打字(每天十分钟,即使休息的时候，也建议练习)</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-day01</title>
      <link href="/2020/053159932.html"/>
      <url>/2020/053159932.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-计算机概述-了解"><a href="#1-计算机概述-了解" class="headerlink" title="1:计算机概述(了解)"></a>1:计算机概述(了解)</h2><h3 id="1-计算机"><a href="#1-计算机" class="headerlink" title="(1)计算机"></a>(1)计算机</h3><h3 id="2-计算机硬件"><a href="#2-计算机硬件" class="headerlink" title="(2)计算机硬件"></a>(2)计算机硬件</h3><h3 id="3-计算机软件"><a href="#3-计算机软件" class="headerlink" title="(3)计算机软件"></a>(3)计算机软件</h3><pre><code>    系统软件：window,linux,mac    应用软件：qq,yy,飞秋</code></pre><h3 id="4-软件开发-理解"><a href="#4-软件开发-理解" class="headerlink" title="(4)软件开发(理解)"></a>(4)软件开发(理解)</h3><pre><code>    软件：是由数据和指令组成的。(计算器)    开发：就是把软件做出来。    如何实现软件开发呢?        就是使用开发工具和计算机语言做出东西来</code></pre><h3 id="5-语言"><a href="#5-语言" class="headerlink" title="(5)语言"></a>(5)语言</h3><pre><code>    自然语言：人与人交流沟通的    计算机语言：人与计算机交流沟通的        C,C++,C#,Java</code></pre><h3 id="6-人机交换"><a href="#6-人机交换" class="headerlink" title="(6)人机交换"></a>(6)人机交换</h3><pre><code>    图形界面：操作方便只管    DOS命令：需要记忆一些常见的命令</code></pre><h2 id="2-键盘功能键的认识和快捷键-掌握"><a href="#2-键盘功能键的认识和快捷键-掌握" class="headerlink" title="2:键盘功能键的认识和快捷键(掌握)"></a>2:键盘功能键的认识和快捷键(掌握)</h2><h3 id="1-功能键的认识"><a href="#1-功能键的认识" class="headerlink" title="(1)功能键的认识"></a>(1)功能键的认识</h3><pre><code>    tab    shift    ctrl    alt    windos    空格    上下左右    回车    截图</code></pre><h3 id="2-快捷键"><a href="#2-快捷键" class="headerlink" title="(2)快捷键"></a>(2)快捷键</h3><pre><code>    全选    Ctrl+A    复制    Ctrl+C    粘贴    Ctrl+V    剪切    Ctrl+X    撤销    Ctrl+Z    保存    Ctrl+S</code></pre><h2 id="3-常见的DOS命令-掌握"><a href="#3-常见的DOS命令-掌握" class="headerlink" title="3:常见的DOS命令(掌握)"></a>3:常见的DOS命令(掌握)</h2><h3 id="1-常见的如下"><a href="#1-常见的如下" class="headerlink" title="(1)常见的如下"></a>(1)常见的如下</h3><pre><code>    盘符的切换        d:回车    目录的进入        cd javase        cd javase\day01\code    目录的回退        cd..        cd\    清屏        cls    退出        exit</code></pre><h3 id="2-其他的几个-了解"><a href="#2-其他的几个-了解" class="headerlink" title="(2)其他的几个(了解)"></a>(2)其他的几个(了解)</h3><pre><code>    创建目录    删除目录    创建文件    删除文件    显示目录下的内容    删除带内容的目录</code></pre><h2 id="4-Java语言概述-了解"><a href="#4-Java语言概述-了解" class="headerlink" title="4:Java语言概述(了解)"></a>4:Java语言概述(了解)</h2><h3 id="1-Java语言的发展史"><a href="#1-Java语言的发展史" class="headerlink" title="(1)Java语言的发展史"></a>(1)Java语言的发展史</h3><pre><code>    Java之父    JDK1.4.2    JDK5    JDK7</code></pre><h3 id="2-Java语言的特点"><a href="#2-Java语言的特点" class="headerlink" title="(2)Java语言的特点"></a>(2)Java语言的特点</h3><pre><code>    有很多小特点，重点有两个开源，跨平台</code></pre><h3 id="3-Java语言是跨平台的，请问是如何保证的呢-理解"><a href="#3-Java语言是跨平台的，请问是如何保证的呢-理解" class="headerlink" title="(3)Java语言是跨平台的，请问是如何保证的呢?(理解)"></a>(3)Java语言是跨平台的，请问是如何保证的呢?(理解)</h3><pre><code>    我们是通过翻译的案例讲解的。    针对不同的操作系统，提高不同的jvm来实现的。</code></pre><h3 id="4-Java语言的平台"><a href="#4-Java语言的平台" class="headerlink" title="(4)Java语言的平台"></a>(4)Java语言的平台</h3><pre><code>    JavaSE    JavaME--Android    JavaEE</code></pre><h2 id="5-JDK-JRE-JVM的作用及关系-掌握"><a href="#5-JDK-JRE-JVM的作用及关系-掌握" class="headerlink" title="5:JDK,JRE,JVM的作用及关系(掌握)"></a>5:JDK,JRE,JVM的作用及关系(掌握)</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="(1)作用"></a>(1)作用</h3><pre><code>    JVM：保证Java语言跨平台    JRE：Java程序的运行环境    JDK：Java程序的开发环境</code></pre><h3 id="2-关系"><a href="#2-关系" class="headerlink" title="(2)关系"></a>(2)关系</h3><pre><code>    JDK：JRE+工具    JRE：JVM+类库</code></pre><h2 id="6-JDK的下载-安装-卸载-掌握"><a href="#6-JDK的下载-安装-卸载-掌握" class="headerlink" title="6:JDK的下载,安装,卸载(掌握)"></a>6:JDK的下载,安装,卸载(掌握)</h2><h3 id="1-下载到官网。"><a href="#1-下载到官网。" class="headerlink" title="(1)下载到官网。"></a>(1)下载到官网。</h3><pre><code>    A:也可以到百度搜索即可。    B:我给你。</code></pre><h3 id="2-安装"><a href="#2-安装" class="headerlink" title="(2)安装"></a>(2)安装</h3><pre><code>    A:绿色版    解压就可以使用    B:安装版    必须一步一步的安装，一般只要会点击下一步即可    注意：        建议所有跟开发相关的软件都不要安装在有中文或者空格的目录下。</code></pre><h3 id="3-卸载"><a href="#3-卸载" class="headerlink" title="(3)卸载"></a>(3)卸载</h3><pre><code>    A:绿色版    直接删除文件夹    B:安装版            a:控制面板 -- 添加删除程序        b:通过专业的软件卸载工具。(比如360的软件管家卸载)</code></pre><h2 id="7-第一个程序：HelloWorld案例-掌握"><a href="#7-第一个程序：HelloWorld案例-掌握" class="headerlink" title="7:第一个程序：HelloWorld案例(掌握)"></a>7:第一个程序：HelloWorld案例(掌握)</h2><pre><code>class HelloWorld {    public static void main(String[] args) {        System.out.println(&quot;HelloWorld&quot;);    }}</code></pre><h3 id="1-程序解释："><a href="#1-程序解释：" class="headerlink" title="(1)程序解释："></a>(1)程序解释：</h3><pre><code>    A:Java程序的最基本单位是类，所以我们要定义一个类。        格式：class 类名        举例：class HelloWorld    B:在类中写内容的时候，用大括号括起来。    C:Java程序要想执行，必须有main方法。        格式：public static void main(String[] args)    D:要指向那些东西呢，也用大括号括起来。    E:你要做什么呢?今天我们仅仅做了一个简单的输出        格式：System.out.println(&quot;HelloWorld&quot;);        注意：&quot;&quot;里面的内容是可以改动的。</code></pre><h3 id="2-Java程序的开发执行流程："><a href="#2-Java程序的开发执行流程：" class="headerlink" title="(2)Java程序的开发执行流程："></a>(2)Java程序的开发执行流程：</h3><pre><code>    A:编写java源程序(.java)    B:通过javac命令编译生成.class文件    C:通过java命令运行.class文件</code></pre><h2 id="8-常见的问题-掌握"><a href="#8-常见的问题-掌握" class="headerlink" title="8:常见的问题(掌握)"></a>8:常见的问题(掌握)</h2><h3 id="1-扩展名被隐藏"><a href="#1-扩展名被隐藏" class="headerlink" title="(1)扩展名被隐藏"></a>(1)扩展名被隐藏</h3><pre><code>    如何找到：工具--文件夹选项--查看--去除隐藏扩展名的那个勾勾</code></pre><h3 id="2-我要求文件名称和类名一致。"><a href="#2-我要求文件名称和类名一致。" class="headerlink" title="(2)我要求文件名称和类名一致。"></a>(2)我要求文件名称和类名一致。</h3><pre><code>    实际上不这样做也是可以的。    但是，注意：        javac后面跟的是文件名+扩展名        java后面跟的类名不带扩展名</code></pre><h3 id="3-Java语言严格区分大小写，请注意。"><a href="#3-Java语言严格区分大小写，请注意。" class="headerlink" title="(3)Java语言严格区分大小写，请注意。"></a>(3)Java语言严格区分大小写，请注意。</h3><pre><code>     还有就是单词不要写错了。</code></pre><h3 id="4-见到非法字符-65307肯定是中文问题。"><a href="#4-见到非法字符-65307肯定是中文问题。" class="headerlink" title="(4)见到非法字符: \65307肯定是中文问题。"></a>(4)见到非法字符: \65307肯定是中文问题。</h3><pre><code>    我们写程序要求标点符号必须全部是英文状态。</code></pre><h3 id="5-括号的配对问题。"><a href="#5-括号的配对问题。" class="headerlink" title="(5)括号的配对问题。"></a>(5)括号的配对问题。</h3><pre><code>    一般来说，括号都是成对出现的。</code></pre><h3 id="6-遇到"><a href="#6-遇到" class="headerlink" title="(6)遇到"></a>(6)遇到</h3><pre><code>    在类 HelloWorld 中找不到主方法, 请将主方法定义为    肯定是主方法的格式问题。</code></pre><h2 id="9-path环境变量-掌握"><a href="#9-path环境变量-掌握" class="headerlink" title="9:path环境变量(掌握)"></a>9:path环境变量(掌握)</h2><h3 id="1-path环境变量的作用"><a href="#1-path环境变量的作用" class="headerlink" title="(1)path环境变量的作用"></a>(1)path环境变量的作用</h3><pre><code>    保证javac命令可以在任意目录下运行。    同理可以配置qq等</code></pre><h3 id="2-path配置的两种方案："><a href="#2-path配置的两种方案：" class="headerlink" title="(2)path配置的两种方案："></a>(2)path配置的两种方案：</h3><pre><code>    A:方案1(了解)    B:方案2        找到环境变量的位置，在系统变量里面        新建：            变量名：JAVA_HOME            变量值：D:\develop\Java\jdk1.7.0_60        修改：            变量名：Path            变量值：%JAVA_HOME%\bin;以前的内容</code></pre><h2 id="10-classpath环境变量-理解"><a href="#10-classpath环境变量-理解" class="headerlink" title="10:classpath环境变量(理解)"></a>10:classpath环境变量(理解)</h2><h3 id="1-classpath环境变量的作用"><a href="#1-classpath环境变量的作用" class="headerlink" title="(1)classpath环境变量的作用"></a>(1)classpath环境变量的作用</h3><pre><code>    保证class文件可以在任意目录下运行</code></pre><h3 id="2-classpath环境变量的配置"><a href="#2-classpath环境变量的配置" class="headerlink" title="(2)classpath环境变量的配置"></a>(2)classpath环境变量的配置</h3><pre><code>    找到环境变量的位置，在系统变量里面    新建：        变量名：classpath        变量值：E:\JavaSE\day01\code\HelloWorld案例</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CCS5.5——快速傅里叶变换(FFT)</title>
      <link href="/2020/052749146.html"/>
      <url>/2020/052749146.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h1><p>1、离散傅里叶变换DFT的定义：将时域的采样变换成频域的周期性离散函数，频域的采样也可以变换成时域的周期性离散函数，这样的变化称为离散傅里叶变换，简称DFT。  </p><p>2、FFT是DFT的一种快速算法。由于在计算DFT是一次复数乘法需用四次实数乘法和两次实数加法；一次复数加法需要两次实数加法。每运算一个X(k)需要4N次复数乘法及 实数加法。所以整个DFT运算总共需要 次实数乘法及 次实数加法。如此，计算时乘法次数和加法次数都是和 成正比的，当N很大时，运算量是客观的，因而需要改进带DFT的算法减少运算速度。  </p><p>根据傅里叶变换的对称性和周期性，我们可以将DFT运算中有些项合并。假设序列长度为 ,L为整数。将 的序列x(n)(n=0,1,…,N-1),按N的奇偶分成两组，分解成两个N/2点的DFT，重新组合成一个如下式表达的N点DFT:<br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P05271.jpg" alt="">  </p><p>将DFT的 步运算减少为 步，极大地提高了运算的速度；  </p><p>3、    旋转因子的变化规律；  </p><p>4、    碟形运算规律；  </p><p>5、    基于2FFT算法。  </p><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P05272.jpg" alt=""></p><h1 id="2-记录实验数据"><a href="#2-记录实验数据" class="headerlink" title="2.记录实验数据"></a>2.记录实验数据</h1><p>按照图6-2，3进行输入信号时域，频域以及输出信号时域波形的设置。<br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P05273.jpg" alt=""><br>输入信号及输出信号的波形如图6-4,5,6所示：<br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P05274.jpg" alt=""><br>代码：</p><pre><code>#include&quot;math.h&quot;#define PI 3.1415926#define SAMPLENUMBER 128void InitForFFT();void MakeWave();int INPUT[SAMPLENUMBER],DATA[SAMPLENUMBER];float fWaveR[SAMPLENUMBER],fWaveI[SAMPLENUMBER],w[SAMPLENUMBER];float sin_tab[SAMPLENUMBER],cos_tab[SAMPLENUMBER];void FFT(float dataR[SAMPLENUMBER],float dataI[SAMPLENUMBER]){    int x0, x1, x2, x3, x4, x5, x6, xx;    int i, j, k, b, p, L;    float TR, TI, temp;/***************fllowing code invert sequence***************/    for( i = 0; i &lt; SAMPLENUMBER; i++)    {        x0=x1=x2=x3=x4=x5=x6=0;        x0=i&amp;0x01;x1=(i/2)&amp;0x01;x2=(i/4)&amp;0x01;x3=(i/8)&amp;0x01;x4=(i/16)&amp;0x01;x5=(i/32)&amp;0x01;x6=(i/64)&amp;0x01;        xx=x0*64+x1*32+x2*16+x3*8+x4*4+x5*2+x6;        dataI[xx]=dataR[i];    }    for( i = 0; i &lt; SAMPLENUMBER; i++)    {        dataR[i]=dataI[i];dataI[i]=0;    }/***********fllowing code FFT***************/    for( L = 1; L &lt;= 7; L++)    {        b=1;i=L-1;        while( i &gt; 0 ){            b=b*2;i--;        }/*b= 2^(L-1)*/        for( j = 0; j &lt;= b-1; j++ )        {            p=1;i=7-L;            while( i &gt; 0 ) /*p=pow(2,7-L)*j;*/            {                p=p*2;i--;            }            p=p*j;            for( k = j; k &lt; 128; k = k+2*b )            {                TR=dataR[k];TI=dataI[k];temp=dataR[k+b];                dataR[k]=dataR[k]+dataR[k+b]*cos_tab[p]+dataI[k+b]*sin_tab[p];                dataI[k]=dataI[k]-dataR[k+b]*sin_tab[p]+dataI[k+b]*cos_tab[p];                dataR[k+b]=TR-dataR[k+b]*cos_tab[p]-dataI[k+b]*sin_tab[p];                dataI[k+b]=TI+temp*sin_tab[p]-dataI[k+b]*cos_tab[p];            }        }    }    for( i = 0; i &lt; SAMPLENUMBER/2; i++)    {        w[i]=sqrt(dataR[i]*dataR[i]+dataI[i]*dataI[i]);    }}/*END FFT*/main(){    int i;    InitForFFT();    MakeWave();    for( i = 0; i &lt; SAMPLENUMBER; i++)    {        fWaveR[i]=INPUT[i];        fWaveI[i]=0.0f;        w[i]=0.0f;    }    FFT(fWaveR,fWaveI);    for(i = 0; i &lt; SAMPLENUMBER; i++)    {        DATA[i]=w[i];    }    while(1);  //break point}void InitForFFT(){    int i;    for(i = 0; i &lt; SAMPLENUMBER; i++)    {        sin_tab[i]=sin(PI*2*i/SAMPLENUMBER);        cos_tab[i]=cos(PI*2*i/SAMPLENUMBER);    }}void MakeWave(){    int i;    for( i=0; i&lt;SAMPLENUMBER; i++ )    {        INPUT[i]=sin(PI*2*i/SAMPLENUMBER*3)*1024;    }}  </code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客之备份与恢复</title>
      <link href="/2020/050127743.html"/>
      <url>/2020/050127743.html</url>
      
        <content type="html"><![CDATA[<h1 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h1><p>1、在你的博客仓库创建一个分支<code>hexo</code>（这个命名随意）；</p><p>2、设置<code>hexo</code>为默认分支（不知道怎么设的可以百度）；<br>( <font color="ff0000">第一步和第二步都在<a href="https://github.com/" target="_blank" rel="noopener">github</a>网站中操作</font>)  </p><p>3、将博客仓库<code>hexo分支</code>clone至本地，<br>在本地新建一个文件夹<code>hexo</code>，并在此文件夹中右击鼠标打开<code>git bash</code>,执行命令  </p><pre><code>git clone git@github.com:Username/Username.github.io.git  </code></pre><p>(<font color="ff0000"><code>Username</code>为你自己的名字</font>)<br>克隆完之后在<code>hexo</code>文件夹中会出现新的Username.github.io文件夹，将其中的文件全部删除，只保留<code>.git\</code>文件夹。</p><p>将之前的博客根目录文件夹中的<br><code>_config.yml</code>，<code>themes/</code>，<code>source</code>，<code>scffolds/</code>，<code>package.json</code>，<code>.gitignore</code>复制到Username.github.io文件夹；（<code>Username</code>是你自己的用户名）</p><a id="more"></a><p>4、将themes/next/(是NexT主题)中的<code>.git/</code>删除，否则无法将主题文件夹<code>push</code>；( <font color="ff0000"><code>matery</code>主题中没有这个文件夹，应该就不用删除了</font>)</p><p>5、在Username.github.io文件夹执行<code>git add .</code>，<code>git commit -m &quot;提交文件&quot;</code>，<code>git push origin hexo</code>来提交hexo网站源文件；( <font color="ff0000">命令中的<code>hexo</code>为你创建的分支的名字</font>)    </p><p>6、执行<code>hexo g -d</code>生成静态网页部署到github上。<br>这样，Username.github.io仓库就有master分支保存静态网页，hexo分支保存源文件。<br>到这里备份就完成了。  </p><h1 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h1><h2 id="此后所有的博客操作都在Username-github-io文件夹中进行"><a href="#此后所有的博客操作都在Username-github-io文件夹中进行" class="headerlink" title="( 此后所有的博客操作都在Username.github.io文件夹中进行)"></a>( <font color="ff0000">此后所有的博客操作都在Username.github.io文件夹中进行</font>)</h2><h3 id="在本地对博客修改（包括修改主题样式、发布新文章等）后在Username-github-io文件夹中依次执行命令"><a href="#在本地对博客修改（包括修改主题样式、发布新文章等）后在Username-github-io文件夹中依次执行命令" class="headerlink" title="在本地对博客修改（包括修改主题样式、发布新文章等）后在Username.github.io文件夹中依次执行命令"></a>在本地对博客修改（包括修改主题样式、发布新文章等）后在Username.github.io文件夹中依次执行命令</h3><pre><code>git add .  git commit -m &quot;提交文件  git push origin hexo  hexo g -d  </code></pre><p>即在每次修改完本地博客后重复执行5、6步来完成来提交hexo网站源文件和生成静态网页部署到github上。  </p><h1 id="恢复博客"><a href="#恢复博客" class="headerlink" title="恢复博客"></a>恢复博客</h1><p>换电脑想改博客：  </p><p>1、安装git；  </p><p>2、安装Nodejs和npm；  </p><p>3、使用克隆命令<code>git clone git@github.com:Username/Username.github.io.git</code>将仓库拷贝至本地；  </p><p>4、在文件夹内执行命令<code>npm install hexo-cli -g</code>、<code>npm install</code>、<code>npm install hexo-deployer-git</code>；</p><h2 id="添加ssh-keys"><a href="#添加ssh-keys" class="headerlink" title="添加ssh-keys"></a>添加ssh-keys</h2><p>在终端下运行：<code>ssh-keygen -t rsa -C &quot;yourname@email.com&quot;</code>，一路回车；<br>会在.ssh目录生成<code>id_rsa</code>、<code>id_rsa.pub</code>两个文件，这就是密钥对，<code>id_rsa</code>是私钥，千万不能泄漏出去；  </p><p>登录<a href="https://github.com/" target="_blank" rel="noopener">Github</a>，打开「Settings」–&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥<code>id_rsa.pub</code>文件的内容，注意不要粘贴成<code>id_rsa</code>，最后点击「Add SSH Key」。</p><blockquote><p><font color="ff0000">版权声明：本文为个人总结，欢迎转载，转载请注明出处，勿用于商业用途！</font>   </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 网站搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建Hexo+Coding(最新教程)</title>
      <link href="/2020/042226283.html"/>
      <url>/2020/042226283.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-Hexo搭建"><a href="#1-Hexo搭建" class="headerlink" title="1. Hexo搭建"></a>1. Hexo搭建</h1><h2 id="1-nodejs，Git环境搭建："><a href="#1-nodejs，Git环境搭建：" class="headerlink" title="1.nodejs，Git环境搭建："></a>1.nodejs，Git环境搭建：</h2><ul><li><a href="https://blog.csdn.net/qq_43285335/article/details/90696126" target="_blank" rel="noopener">node.js搭建</a> </li><li><a href="https://www.cnblogs.com/xueweisuoyong/p/11914045.html" target="_blank" rel="noopener">git搭建</a>-<br><a href="https://www.cnblogs.com/luyuandatabase/p/12145707.html" target="_blank" rel="noopener">淘宝云配置</a> </li></ul><h2 id="2-注册github"><a href="#2-注册github" class="headerlink" title="2.注册github"></a>2.注册github</h2><ol><li>注册就不用我说了，创建仓库视频里有，然后这个也很简单，不会就百度（应该没人去百度<br>的，太简单了）</li><li>格式要求：gfyuan.github.io</li></ol><h2 id="3-快速利用hexo搭建博客："><a href="#3-快速利用hexo搭建博客：" class="headerlink" title="3.快速利用hexo搭建博客："></a>3.快速利用hexo搭建博客：</h2><p> 1.<a href="https://hexoscript.gitbook.io/hexo-script/" target="_blank" rel="noopener">Hexo脚本教程</a>  </p><p> 2.<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">主题安装及优化</a>  </p><h1 id="2-Coding创建项目"><a href="#2-Coding创建项目" class="headerlink" title="2.Coding创建项目"></a>2.Coding创建项目</h1><h3 id="1-首先，去Coding官网注册一个账号，接着，点击“-创建项目”-创建一个新项目。"><a href="#1-首先，去Coding官网注册一个账号，接着，点击“-创建项目”-创建一个新项目。" class="headerlink" title="1.首先，去Coding官网注册一个账号，接着，点击“+ 创建项目”,创建一个新项目。"></a>1.首先，去Coding<a href="coding.net">官网注册</a>一个账号，接着，点击“+ 创建项目”,创建一个新项目。</h3><ul><li>选择项目模板<br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P052211.jpg" alt=""><ul><li>创建项目<br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P052212.jpg" alt=""> <h3 id="2-同步本地hexo到coding上"><a href="#2-同步本地hexo到coding上" class="headerlink" title="2.同步本地hexo到coding上"></a>2.同步本地hexo到coding上</h3>把获取到了ssh配置在上面的<code>_config.yml</code>文件中的deploy下，<pre><code>deploy:type: gitrepo:    github: git@github.com:你的用户名/你的仓库名.github.io.git   coding: git@e.coding.net:你的用户名/你的仓库名.gitbranch: master</code></pre>如果是第一次使用coding的话，需要设置SSH公钥，生成的方法可以参考<a href="https://help.coding.net/" target="_blank" rel="noopener">coding帮助中心</a>   </li></ul></li></ul><p>当然这里直接使用之前部署github时已经生成的公钥。<br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P052213.jpg" alt="">    </p><p>添加后，在<code>git bash</code>命令输入：</p><pre><code>ssh -T git@git.coding.net</code></pre><p>如果得到下面提示就表示公钥添加成功了：</p><pre><code>Coding.net Tips : [Hello ! You&#39;ve conected to Coding.net by SSH successfully! ]</code></pre><p>最后使用部署命令就能把博客同步到coding上面：</p><pre><code>hexo g -d</code></pre><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P052214.jpg" alt=""> </p><h1 id="3-pages服务方式部署"><a href="#3-pages服务方式部署" class="headerlink" title="3.pages服务方式部署"></a>3.pages服务方式部署</h1><ul><li><p>你在你的仓库里是找不到pages页面的需要进行以下操作<br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P1.png" alt="">   </p><ul><li>勾选上持续部署和持续集成<br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P2.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P3.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P4.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P5.png" alt=""><br>然后就可通过访问地址访问自己的博客啦！</li></ul></li><li><p>如果你有自己的私人域名也可以绑定自己的域名<br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P6.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/P7.png" alt="">  然后在你的域名服务台解析到你的博客访问地址即可通过域名访问博客。  </p></li></ul><blockquote><p><font color="ff0000">版权声明：本文为个人总结，欢迎转载，转载请注明出处，勿用于商业用途！</font>  </p></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1443900438&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> 网站搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你若安好，便是晴天</title>
      <link href="/2020/032134362.html"/>
      <url>/2020/032134362.html</url>
      
        <content type="html"><![CDATA[<hr><p> 晨起，窗外的阳光已是浩浩荡荡，远山苍绿如黛。夏天，就这样不慌不忙地来到身边，草木深深，风华绝代。</p><p>人生匆匆的聚散里，往事如烟，陌上花开如旧，而我们，却在凡俗的烟火里，承担岁月带给我们的浮世沧桑。青梅煮酒，一如旧时的味道，而那些走散的人，却再不会再回来。</p><p>我们都是光阴里的过客，有些人只是擦肩而过，有些人会短暂的停留，而有些人会携手白头。凡尘的烟火缭绕，我们总是在如烟的世海里丢了自己。岁月，偷换的又岂止是青春红颜，还有那些最初的情怀。</p><p>我们都只是拥挤红尘里孤独的赶路人，寂寞时，我们需要回忆相伴；迷茫时，我们需要情怀偎依取暖。</p><p>世间所有女子都曾如精灵般存在，或是柔情，或是灵动，在光阴里含笑，为一场雨动情。爱人间的莺歌燕舞，爱江南的山温水软，爱世间一切美好的东西。</p><p>世间所有女子都曾有过绝代的风华，有些人将这风华酿成一坛芬芳的酒酿，沉醉岁月；而有些，却在生活的枝头渐次苍白，一一凋落。</p><p>生活百味纷杂，尝过人情世味，看过世态炎凉，浸泡在红尘的染缸里，她们都不复当初的模样。世事如刀，所有最初的情怀、柔肠和优雅，被一点点削减。 </p><p><img src="https://cdn.jsdelivr.net/gh/MoreInterests/CDN/MoreInterests-PIC21a87bce-674a-4981-b056-60c22a7935d3.jpg" alt=""> </p><p>风景生动的城里，古城温暖的阳光里，江南水乡的石桥上，总有那怀着温润洁净情怀的女子走过；寻常的巷陌里，小镇的溪水旁，乡间的田野里，总有女子在为生活而奔忙。从她们降生在人间开始，便有万千色彩的故事等着她们去演绎。有悲欢，有离合，有酸甜，有苦辣。</p><p>不知在什么时候，便喜欢上这两个字：惜缘。佛说，前世五百次的回眸，换来今生的擦肩而过。</p><p>张爱玲也说：于千万人之中遇见你所要遇见的人, 于千万年之中, 时间的无涯的荒野里, 没有早一步, 也没有晚一步, 刚巧赶上了, 没有别的话可说, 惟有轻轻地问一声: “ 噢, 你也在这里?”</p><p>可见人与人的相遇是多么难得的缘分，所以我们应该学会珍惜，任何错过和伤害都是对缘分的蹉跎。</p><p>有时，行走在摩肩接踵的人群中，心中便会涌出莫名的感动，每一个来来去去的生命，都有他们的烟火幸福，有他们完整的故事。</p><p>邂逅一个人，只需片刻，爱上一个人，往往会是一生。</p><p>徐志摩说：一生至少该有一次,为了某个人而忘了自己,不求结果,不求同行,不求曾经拥有,甚至不求你爱我.只求在我最美的年华里,遇见你！</p><p>爱上一个人，是涅槃，亦是重生。因为爱了，所以听风含情，花柳带笑；因为爱了，所以感时花溅泪，恨别鸟惊心；因为爱了！   </p><hr><pre><code>                         初心亦在 有缘再见</code></pre>]]></content>
      
      
      <categories>
          
          <category> 美文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 情感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Github博客搭建入门</title>
      <link href="/2020/031034155.html"/>
      <url>/2020/031034155.html</url>
      
        <content type="html"><![CDATA[<h1 id="网站搭建"><a href="#网站搭建" class="headerlink" title="网站搭建"></a>网站搭建</h1><h2 id="安装需要的编辑软件"><a href="#安装需要的编辑软件" class="headerlink" title="安装需要的编辑软件"></a>安装需要的编辑软件</h2><ul><li>Typora<br>个人建议在国内的软件上下载，不要去官网，下载慢  </li><li>vs code<br>轻量级文档编辑器  </li></ul><h2 id="1-nodejs，Git环境搭建："><a href="#1-nodejs，Git环境搭建：" class="headerlink" title="1.nodejs，Git环境搭建："></a>1.nodejs，Git环境搭建：</h2><ul><li><a href="https://blog.csdn.net/qq_43285335/article/details/90696126" target="_blank" rel="noopener">node.js搭建</a> </li><li><a href="https://www.cnblogs.com/xueweisuoyong/p/11914045.html" target="_blank" rel="noopener">git搭建</a>-<br><a href="https://www.cnblogs.com/luyuandatabase/p/12145707.html" target="_blank" rel="noopener">淘宝云配置</a> </li></ul><h2 id="2-注册github"><a href="#2-注册github" class="headerlink" title="2.注册github"></a>2.注册github</h2><ol><li>注册就不用我说了，创建仓库视频里有，然后这个也很简单，不会就百度（应该没人去百度<br>的，太简单了）</li><li>格式要求：gfyuan.github.io</li></ol><h2 id="3-快速利用hexo搭建博客："><a href="#3-快速利用hexo搭建博客：" class="headerlink" title="3.快速利用hexo搭建博客："></a>3.快速利用hexo搭建博客：</h2><p> 1.<a href="https://hexoscript.gitbook.io/hexo-script/" target="_blank" rel="noopener">脚本教程</a>  </p><p> 2.<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">主题安装及优化</a> </p><p> <a href="https://www.jianshu.com/p/1e402922ee32" target="_blank" rel="noopener">Markdown入门</a></p>]]></content>
      
      
      <categories>
          
          <category> 网站搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客撰写教程</title>
      <link href="/2020/022054914.html"/>
      <url>/2020/022054914.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Markdown——入门指南"><a href="#1-Markdown——入门指南" class="headerlink" title="1.Markdown——入门指南"></a>1.Markdown——入门指南</h2><h1 id="导语："><a href="#导语：" class="headerlink" title="导语："></a>导语：</h1><p>Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的 HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。 </p><h2 id="Markdown-语法的简要规则"><a href="#Markdown-语法的简要规则" class="headerlink" title="Markdown 语法的简要规则"></a>Markdown 语法的简要规则</h2><ul><li><p>标题 </p><p>  #一级标题</p><p>  ##二级标题</p><p>  ###三级标题 </p></li><li><p>无序列表  </p></li></ul><p>*1<br>*2<br>*3</p><ul><li>有序列表   </li></ul><p>1.1<br>1.2<br>1.3  </p><ul><li>图片与链接<br>图片为：! [ ] ( )<br>链接为：[ ] ( )  </li><li>粗体  </li></ul><p><strong>中文本为斜体<br>**</strong>中为粗体  </p><ul><li>分割线<br>三个*为分割线  </li><li>代码框<br>一个``<br>例如：<br><code>if(a&lt;b)   {c=b;}</code>     </li><li>行内代码  <pre><code>coding: git@e.coding.net:</code></pre></li></ul><p><a href="https://www.jianshu.com/p/1e402922ee32" target="_blank" rel="noopener">文章出处</a>  </p><hr><h2 id="2-文章-Front-matter-介绍"><a href="#2-文章-Front-matter-介绍" class="headerlink" title="2.文章 Front-matter 介绍"></a>2.文章 Front-matter 介绍</h2><p>Front-matter 选项详解<br>Front-matter 选项中的所有内容均为非必填的。但我仍然建议至少填写 title 和 date 的值。</p><p>配置选项    默认值    描述<br><strong>title</strong>    Markdown 的文件标题    文章标题，强烈建议填写此选项<br><strong>date</strong>    文件创建时的日期时间    发布时间，强烈建议填写此选项，且最好保证全局唯一<br><strong>author</strong>    根 _config.yml 中的 author    文章作者<br><strong>img</strong>    featureImages 中的某个值    文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <a href="http://xxx.com/xxx.jpg" target="_blank" rel="noopener">http://xxx.com/xxx.jpg</a></p><p>  其余规则见<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" target="_blank" rel="noopener">文章出处</a></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/021516107.html"/>
      <url>/2020/021516107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
